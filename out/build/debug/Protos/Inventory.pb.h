// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: Inventory.proto
// Protobuf C++ Version: 5.29.0-dev

#ifndef GOOGLE_PROTOBUF_INCLUDED_Inventory_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_Inventory_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029000
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "_Item.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_Inventory_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_Inventory_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_Inventory_2eproto;
namespace DC {
namespace Packet {
class INVENTORY_SWAP_DST_INFO;
struct INVENTORY_SWAP_DST_INFODefaultTypeInternal;
extern INVENTORY_SWAP_DST_INFODefaultTypeInternal _INVENTORY_SWAP_DST_INFO_default_instance_;
class SC2S_INVENTORY_ALL_UPDATE_REQ;
struct SC2S_INVENTORY_ALL_UPDATE_REQDefaultTypeInternal;
extern SC2S_INVENTORY_ALL_UPDATE_REQDefaultTypeInternal _SC2S_INVENTORY_ALL_UPDATE_REQ_default_instance_;
class SC2S_INVENTORY_EXPAND_STORAGE_REQ;
struct SC2S_INVENTORY_EXPAND_STORAGE_REQDefaultTypeInternal;
extern SC2S_INVENTORY_EXPAND_STORAGE_REQDefaultTypeInternal _SC2S_INVENTORY_EXPAND_STORAGE_REQ_default_instance_;
class SC2S_INVENTORY_INFO_REQ;
struct SC2S_INVENTORY_INFO_REQDefaultTypeInternal;
extern SC2S_INVENTORY_INFO_REQDefaultTypeInternal _SC2S_INVENTORY_INFO_REQ_default_instance_;
class SC2S_INVENTORY_MERGE_REQ;
struct SC2S_INVENTORY_MERGE_REQDefaultTypeInternal;
extern SC2S_INVENTORY_MERGE_REQDefaultTypeInternal _SC2S_INVENTORY_MERGE_REQ_default_instance_;
class SC2S_INVENTORY_MOVE_REQ;
struct SC2S_INVENTORY_MOVE_REQDefaultTypeInternal;
extern SC2S_INVENTORY_MOVE_REQDefaultTypeInternal _SC2S_INVENTORY_MOVE_REQ_default_instance_;
class SC2S_INVENTORY_SINGLE_UPDATE_REQ;
struct SC2S_INVENTORY_SINGLE_UPDATE_REQDefaultTypeInternal;
extern SC2S_INVENTORY_SINGLE_UPDATE_REQDefaultTypeInternal _SC2S_INVENTORY_SINGLE_UPDATE_REQ_default_instance_;
class SC2S_INVENTORY_SPLIT_MERGE_REQ;
struct SC2S_INVENTORY_SPLIT_MERGE_REQDefaultTypeInternal;
extern SC2S_INVENTORY_SPLIT_MERGE_REQDefaultTypeInternal _SC2S_INVENTORY_SPLIT_MERGE_REQ_default_instance_;
class SC2S_INVENTORY_SPLIT_MOVE_REQ;
struct SC2S_INVENTORY_SPLIT_MOVE_REQDefaultTypeInternal;
extern SC2S_INVENTORY_SPLIT_MOVE_REQDefaultTypeInternal _SC2S_INVENTORY_SPLIT_MOVE_REQ_default_instance_;
class SC2S_INVENTORY_SPLIT_SWAP_REQ;
struct SC2S_INVENTORY_SPLIT_SWAP_REQDefaultTypeInternal;
extern SC2S_INVENTORY_SPLIT_SWAP_REQDefaultTypeInternal _SC2S_INVENTORY_SPLIT_SWAP_REQ_default_instance_;
class SC2S_INVENTORY_SWAP_REQ;
struct SC2S_INVENTORY_SWAP_REQDefaultTypeInternal;
extern SC2S_INVENTORY_SWAP_REQDefaultTypeInternal _SC2S_INVENTORY_SWAP_REQ_default_instance_;
class SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ;
struct SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQDefaultTypeInternal;
extern SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQDefaultTypeInternal _SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ_default_instance_;
class SC2S_STORAGE_INFO_REQ;
struct SC2S_STORAGE_INFO_REQDefaultTypeInternal;
extern SC2S_STORAGE_INFO_REQDefaultTypeInternal _SC2S_STORAGE_INFO_REQ_default_instance_;
class SINVENTORY_ITEM_REQ_INFO;
struct SINVENTORY_ITEM_REQ_INFODefaultTypeInternal;
extern SINVENTORY_ITEM_REQ_INFODefaultTypeInternal _SINVENTORY_ITEM_REQ_INFO_default_instance_;
class SS2C_INVENTORY_ALL_UPDATE_RES;
struct SS2C_INVENTORY_ALL_UPDATE_RESDefaultTypeInternal;
extern SS2C_INVENTORY_ALL_UPDATE_RESDefaultTypeInternal _SS2C_INVENTORY_ALL_UPDATE_RES_default_instance_;
class SS2C_INVENTORY_EXPAND_STORAGE_RES;
struct SS2C_INVENTORY_EXPAND_STORAGE_RESDefaultTypeInternal;
extern SS2C_INVENTORY_EXPAND_STORAGE_RESDefaultTypeInternal _SS2C_INVENTORY_EXPAND_STORAGE_RES_default_instance_;
class SS2C_INVENTORY_INFO_RES;
struct SS2C_INVENTORY_INFO_RESDefaultTypeInternal;
extern SS2C_INVENTORY_INFO_RESDefaultTypeInternal _SS2C_INVENTORY_INFO_RES_default_instance_;
class SS2C_INVENTORY_MERGE_RES;
struct SS2C_INVENTORY_MERGE_RESDefaultTypeInternal;
extern SS2C_INVENTORY_MERGE_RESDefaultTypeInternal _SS2C_INVENTORY_MERGE_RES_default_instance_;
class SS2C_INVENTORY_MOVE_RES;
struct SS2C_INVENTORY_MOVE_RESDefaultTypeInternal;
extern SS2C_INVENTORY_MOVE_RESDefaultTypeInternal _SS2C_INVENTORY_MOVE_RES_default_instance_;
class SS2C_INVENTORY_SINGLE_UPDATE_RES;
struct SS2C_INVENTORY_SINGLE_UPDATE_RESDefaultTypeInternal;
extern SS2C_INVENTORY_SINGLE_UPDATE_RESDefaultTypeInternal _SS2C_INVENTORY_SINGLE_UPDATE_RES_default_instance_;
class SS2C_INVENTORY_SPLIT_MERGE_RES;
struct SS2C_INVENTORY_SPLIT_MERGE_RESDefaultTypeInternal;
extern SS2C_INVENTORY_SPLIT_MERGE_RESDefaultTypeInternal _SS2C_INVENTORY_SPLIT_MERGE_RES_default_instance_;
class SS2C_INVENTORY_SPLIT_MOVE_RES;
struct SS2C_INVENTORY_SPLIT_MOVE_RESDefaultTypeInternal;
extern SS2C_INVENTORY_SPLIT_MOVE_RESDefaultTypeInternal _SS2C_INVENTORY_SPLIT_MOVE_RES_default_instance_;
class SS2C_INVENTORY_SPLIT_SWAP_RES;
struct SS2C_INVENTORY_SPLIT_SWAP_RESDefaultTypeInternal;
extern SS2C_INVENTORY_SPLIT_SWAP_RESDefaultTypeInternal _SS2C_INVENTORY_SPLIT_SWAP_RES_default_instance_;
class SS2C_INVENTORY_SWAP_RES;
struct SS2C_INVENTORY_SWAP_RESDefaultTypeInternal;
extern SS2C_INVENTORY_SWAP_RESDefaultTypeInternal _SS2C_INVENTORY_SWAP_RES_default_instance_;
class SS2C_INVENTORY_TWO_HANDED_WEAPON_SWAP_RES;
struct SS2C_INVENTORY_TWO_HANDED_WEAPON_SWAP_RESDefaultTypeInternal;
extern SS2C_INVENTORY_TWO_HANDED_WEAPON_SWAP_RESDefaultTypeInternal _SS2C_INVENTORY_TWO_HANDED_WEAPON_SWAP_RES_default_instance_;
class SS2C_STORAGE_INFO_RES;
struct SS2C_STORAGE_INFO_RESDefaultTypeInternal;
extern SS2C_STORAGE_INFO_RESDefaultTypeInternal _SS2C_STORAGE_INFO_RES_default_instance_;
}  // namespace Packet
}  // namespace DC
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace DC {
namespace Packet {
enum SS2C_INVENTORY_INFO_RES_RESULT_INVENTORY_INFO_INFO : int {
  SS2C_INVENTORY_INFO_RES_RESULT_INVENTORY_INFO_INFO_NONE = 0,
  SS2C_INVENTORY_INFO_RES_RESULT_INVENTORY_INFO_INFO_OK_SEND_DATA = 1,
  SS2C_INVENTORY_INFO_RES_RESULT_INVENTORY_INFO_INFO_OK_NOT_CHANGE = 2,
  SS2C_INVENTORY_INFO_RES_RESULT_INVENTORY_INFO_INFO_FAIL = 3,
  SS2C_INVENTORY_INFO_RES_RESULT_INVENTORY_INFO_INFO_SS2C_INVENTORY_INFO_RES_RESULT_INVENTORY_INFO_INFO_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SS2C_INVENTORY_INFO_RES_RESULT_INVENTORY_INFO_INFO_SS2C_INVENTORY_INFO_RES_RESULT_INVENTORY_INFO_INFO_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool SS2C_INVENTORY_INFO_RES_RESULT_INVENTORY_INFO_INFO_IsValid(int value);
extern const uint32_t SS2C_INVENTORY_INFO_RES_RESULT_INVENTORY_INFO_INFO_internal_data_[];
constexpr SS2C_INVENTORY_INFO_RES_RESULT_INVENTORY_INFO_INFO SS2C_INVENTORY_INFO_RES_RESULT_INVENTORY_INFO_INFO_RESULT_INVENTORY_INFO_INFO_MIN = static_cast<SS2C_INVENTORY_INFO_RES_RESULT_INVENTORY_INFO_INFO>(0);
constexpr SS2C_INVENTORY_INFO_RES_RESULT_INVENTORY_INFO_INFO SS2C_INVENTORY_INFO_RES_RESULT_INVENTORY_INFO_INFO_RESULT_INVENTORY_INFO_INFO_MAX = static_cast<SS2C_INVENTORY_INFO_RES_RESULT_INVENTORY_INFO_INFO>(3);
constexpr int SS2C_INVENTORY_INFO_RES_RESULT_INVENTORY_INFO_INFO_RESULT_INVENTORY_INFO_INFO_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
SS2C_INVENTORY_INFO_RES_RESULT_INVENTORY_INFO_INFO_descriptor();
template <typename T>
const std::string& SS2C_INVENTORY_INFO_RES_RESULT_INVENTORY_INFO_INFO_Name(T value) {
  static_assert(std::is_same<T, SS2C_INVENTORY_INFO_RES_RESULT_INVENTORY_INFO_INFO>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RESULT_INVENTORY_INFO_INFO_Name().");
  return SS2C_INVENTORY_INFO_RES_RESULT_INVENTORY_INFO_INFO_Name(static_cast<SS2C_INVENTORY_INFO_RES_RESULT_INVENTORY_INFO_INFO>(value));
}
template <>
inline const std::string& SS2C_INVENTORY_INFO_RES_RESULT_INVENTORY_INFO_INFO_Name(SS2C_INVENTORY_INFO_RES_RESULT_INVENTORY_INFO_INFO value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SS2C_INVENTORY_INFO_RES_RESULT_INVENTORY_INFO_INFO_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool SS2C_INVENTORY_INFO_RES_RESULT_INVENTORY_INFO_INFO_Parse(absl::string_view name, SS2C_INVENTORY_INFO_RES_RESULT_INVENTORY_INFO_INFO* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SS2C_INVENTORY_INFO_RES_RESULT_INVENTORY_INFO_INFO>(
      SS2C_INVENTORY_INFO_RES_RESULT_INVENTORY_INFO_INFO_descriptor(), name, value);
}
enum SS2C_INVENTORY_ALL_UPDATE_RES_RESULT_INVENTORY_UPDATE : int {
  SS2C_INVENTORY_ALL_UPDATE_RES_RESULT_INVENTORY_UPDATE_NONE = 0,
  SS2C_INVENTORY_ALL_UPDATE_RES_RESULT_INVENTORY_UPDATE_OK = 1,
  SS2C_INVENTORY_ALL_UPDATE_RES_RESULT_INVENTORY_UPDATE_FAIL = 2,
  SS2C_INVENTORY_ALL_UPDATE_RES_RESULT_INVENTORY_UPDATE_SS2C_INVENTORY_ALL_UPDATE_RES_RESULT_INVENTORY_UPDATE_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SS2C_INVENTORY_ALL_UPDATE_RES_RESULT_INVENTORY_UPDATE_SS2C_INVENTORY_ALL_UPDATE_RES_RESULT_INVENTORY_UPDATE_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool SS2C_INVENTORY_ALL_UPDATE_RES_RESULT_INVENTORY_UPDATE_IsValid(int value);
extern const uint32_t SS2C_INVENTORY_ALL_UPDATE_RES_RESULT_INVENTORY_UPDATE_internal_data_[];
constexpr SS2C_INVENTORY_ALL_UPDATE_RES_RESULT_INVENTORY_UPDATE SS2C_INVENTORY_ALL_UPDATE_RES_RESULT_INVENTORY_UPDATE_RESULT_INVENTORY_UPDATE_MIN = static_cast<SS2C_INVENTORY_ALL_UPDATE_RES_RESULT_INVENTORY_UPDATE>(0);
constexpr SS2C_INVENTORY_ALL_UPDATE_RES_RESULT_INVENTORY_UPDATE SS2C_INVENTORY_ALL_UPDATE_RES_RESULT_INVENTORY_UPDATE_RESULT_INVENTORY_UPDATE_MAX = static_cast<SS2C_INVENTORY_ALL_UPDATE_RES_RESULT_INVENTORY_UPDATE>(2);
constexpr int SS2C_INVENTORY_ALL_UPDATE_RES_RESULT_INVENTORY_UPDATE_RESULT_INVENTORY_UPDATE_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
SS2C_INVENTORY_ALL_UPDATE_RES_RESULT_INVENTORY_UPDATE_descriptor();
template <typename T>
const std::string& SS2C_INVENTORY_ALL_UPDATE_RES_RESULT_INVENTORY_UPDATE_Name(T value) {
  static_assert(std::is_same<T, SS2C_INVENTORY_ALL_UPDATE_RES_RESULT_INVENTORY_UPDATE>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RESULT_INVENTORY_UPDATE_Name().");
  return SS2C_INVENTORY_ALL_UPDATE_RES_RESULT_INVENTORY_UPDATE_Name(static_cast<SS2C_INVENTORY_ALL_UPDATE_RES_RESULT_INVENTORY_UPDATE>(value));
}
template <>
inline const std::string& SS2C_INVENTORY_ALL_UPDATE_RES_RESULT_INVENTORY_UPDATE_Name(SS2C_INVENTORY_ALL_UPDATE_RES_RESULT_INVENTORY_UPDATE value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SS2C_INVENTORY_ALL_UPDATE_RES_RESULT_INVENTORY_UPDATE_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool SS2C_INVENTORY_ALL_UPDATE_RES_RESULT_INVENTORY_UPDATE_Parse(absl::string_view name, SS2C_INVENTORY_ALL_UPDATE_RES_RESULT_INVENTORY_UPDATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SS2C_INVENTORY_ALL_UPDATE_RES_RESULT_INVENTORY_UPDATE>(
      SS2C_INVENTORY_ALL_UPDATE_RES_RESULT_INVENTORY_UPDATE_descriptor(), name, value);
}
enum SS2C_INVENTORY_SINGLE_UPDATE_RES_RESULT_INVENTORY_SINGLE_UPDATE : int {
  SS2C_INVENTORY_SINGLE_UPDATE_RES_RESULT_INVENTORY_SINGLE_UPDATE_NONE = 0,
  SS2C_INVENTORY_SINGLE_UPDATE_RES_RESULT_INVENTORY_SINGLE_UPDATE_OK = 1,
  SS2C_INVENTORY_SINGLE_UPDATE_RES_RESULT_INVENTORY_SINGLE_UPDATE_FAIL = 2,
  SS2C_INVENTORY_SINGLE_UPDATE_RES_RESULT_INVENTORY_SINGLE_UPDATE_FAIL_VALID_CHECK_OLD_ITEM = 3,
  SS2C_INVENTORY_SINGLE_UPDATE_RES_RESULT_INVENTORY_SINGLE_UPDATE_FAIL_VALID_CHECK_NEW_ITEM = 4,
  SS2C_INVENTORY_SINGLE_UPDATE_RES_RESULT_INVENTORY_SINGLE_UPDATE_FAIL_CHECK_LOGIC_LOG = 5,
  SS2C_INVENTORY_SINGLE_UPDATE_RES_RESULT_INVENTORY_SINGLE_UPDATE_SS2C_INVENTORY_SINGLE_UPDATE_RES_RESULT_INVENTORY_SINGLE_UPDATE_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SS2C_INVENTORY_SINGLE_UPDATE_RES_RESULT_INVENTORY_SINGLE_UPDATE_SS2C_INVENTORY_SINGLE_UPDATE_RES_RESULT_INVENTORY_SINGLE_UPDATE_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool SS2C_INVENTORY_SINGLE_UPDATE_RES_RESULT_INVENTORY_SINGLE_UPDATE_IsValid(int value);
extern const uint32_t SS2C_INVENTORY_SINGLE_UPDATE_RES_RESULT_INVENTORY_SINGLE_UPDATE_internal_data_[];
constexpr SS2C_INVENTORY_SINGLE_UPDATE_RES_RESULT_INVENTORY_SINGLE_UPDATE SS2C_INVENTORY_SINGLE_UPDATE_RES_RESULT_INVENTORY_SINGLE_UPDATE_RESULT_INVENTORY_SINGLE_UPDATE_MIN = static_cast<SS2C_INVENTORY_SINGLE_UPDATE_RES_RESULT_INVENTORY_SINGLE_UPDATE>(0);
constexpr SS2C_INVENTORY_SINGLE_UPDATE_RES_RESULT_INVENTORY_SINGLE_UPDATE SS2C_INVENTORY_SINGLE_UPDATE_RES_RESULT_INVENTORY_SINGLE_UPDATE_RESULT_INVENTORY_SINGLE_UPDATE_MAX = static_cast<SS2C_INVENTORY_SINGLE_UPDATE_RES_RESULT_INVENTORY_SINGLE_UPDATE>(5);
constexpr int SS2C_INVENTORY_SINGLE_UPDATE_RES_RESULT_INVENTORY_SINGLE_UPDATE_RESULT_INVENTORY_SINGLE_UPDATE_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
SS2C_INVENTORY_SINGLE_UPDATE_RES_RESULT_INVENTORY_SINGLE_UPDATE_descriptor();
template <typename T>
const std::string& SS2C_INVENTORY_SINGLE_UPDATE_RES_RESULT_INVENTORY_SINGLE_UPDATE_Name(T value) {
  static_assert(std::is_same<T, SS2C_INVENTORY_SINGLE_UPDATE_RES_RESULT_INVENTORY_SINGLE_UPDATE>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RESULT_INVENTORY_SINGLE_UPDATE_Name().");
  return SS2C_INVENTORY_SINGLE_UPDATE_RES_RESULT_INVENTORY_SINGLE_UPDATE_Name(static_cast<SS2C_INVENTORY_SINGLE_UPDATE_RES_RESULT_INVENTORY_SINGLE_UPDATE>(value));
}
template <>
inline const std::string& SS2C_INVENTORY_SINGLE_UPDATE_RES_RESULT_INVENTORY_SINGLE_UPDATE_Name(SS2C_INVENTORY_SINGLE_UPDATE_RES_RESULT_INVENTORY_SINGLE_UPDATE value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SS2C_INVENTORY_SINGLE_UPDATE_RES_RESULT_INVENTORY_SINGLE_UPDATE_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool SS2C_INVENTORY_SINGLE_UPDATE_RES_RESULT_INVENTORY_SINGLE_UPDATE_Parse(absl::string_view name, SS2C_INVENTORY_SINGLE_UPDATE_RES_RESULT_INVENTORY_SINGLE_UPDATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SS2C_INVENTORY_SINGLE_UPDATE_RES_RESULT_INVENTORY_SINGLE_UPDATE>(
      SS2C_INVENTORY_SINGLE_UPDATE_RES_RESULT_INVENTORY_SINGLE_UPDATE_descriptor(), name, value);
}
enum SS2C_STORAGE_INFO_RES_RESULT_STORAGE_INFO : int {
  SS2C_STORAGE_INFO_RES_RESULT_STORAGE_INFO_NONE = 0,
  SS2C_STORAGE_INFO_RES_RESULT_STORAGE_INFO_OK_SEND_DATA = 1,
  SS2C_STORAGE_INFO_RES_RESULT_STORAGE_INFO_OK_NOT_CHANGE = 2,
  SS2C_STORAGE_INFO_RES_RESULT_STORAGE_INFO_FAIL = 3,
  SS2C_STORAGE_INFO_RES_RESULT_STORAGE_INFO_SS2C_STORAGE_INFO_RES_RESULT_STORAGE_INFO_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SS2C_STORAGE_INFO_RES_RESULT_STORAGE_INFO_SS2C_STORAGE_INFO_RES_RESULT_STORAGE_INFO_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool SS2C_STORAGE_INFO_RES_RESULT_STORAGE_INFO_IsValid(int value);
extern const uint32_t SS2C_STORAGE_INFO_RES_RESULT_STORAGE_INFO_internal_data_[];
constexpr SS2C_STORAGE_INFO_RES_RESULT_STORAGE_INFO SS2C_STORAGE_INFO_RES_RESULT_STORAGE_INFO_RESULT_STORAGE_INFO_MIN = static_cast<SS2C_STORAGE_INFO_RES_RESULT_STORAGE_INFO>(0);
constexpr SS2C_STORAGE_INFO_RES_RESULT_STORAGE_INFO SS2C_STORAGE_INFO_RES_RESULT_STORAGE_INFO_RESULT_STORAGE_INFO_MAX = static_cast<SS2C_STORAGE_INFO_RES_RESULT_STORAGE_INFO>(3);
constexpr int SS2C_STORAGE_INFO_RES_RESULT_STORAGE_INFO_RESULT_STORAGE_INFO_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
SS2C_STORAGE_INFO_RES_RESULT_STORAGE_INFO_descriptor();
template <typename T>
const std::string& SS2C_STORAGE_INFO_RES_RESULT_STORAGE_INFO_Name(T value) {
  static_assert(std::is_same<T, SS2C_STORAGE_INFO_RES_RESULT_STORAGE_INFO>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RESULT_STORAGE_INFO_Name().");
  return SS2C_STORAGE_INFO_RES_RESULT_STORAGE_INFO_Name(static_cast<SS2C_STORAGE_INFO_RES_RESULT_STORAGE_INFO>(value));
}
template <>
inline const std::string& SS2C_STORAGE_INFO_RES_RESULT_STORAGE_INFO_Name(SS2C_STORAGE_INFO_RES_RESULT_STORAGE_INFO value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SS2C_STORAGE_INFO_RES_RESULT_STORAGE_INFO_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool SS2C_STORAGE_INFO_RES_RESULT_STORAGE_INFO_Parse(absl::string_view name, SS2C_STORAGE_INFO_RES_RESULT_STORAGE_INFO* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SS2C_STORAGE_INFO_RES_RESULT_STORAGE_INFO>(
      SS2C_STORAGE_INFO_RES_RESULT_STORAGE_INFO_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class SS2C_INVENTORY_TWO_HANDED_WEAPON_SWAP_RES final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:DC.Packet.SS2C_INVENTORY_TWO_HANDED_WEAPON_SWAP_RES) */ {
 public:
  inline SS2C_INVENTORY_TWO_HANDED_WEAPON_SWAP_RES() : SS2C_INVENTORY_TWO_HANDED_WEAPON_SWAP_RES(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SS2C_INVENTORY_TWO_HANDED_WEAPON_SWAP_RES(
      ::google::protobuf::internal::ConstantInitialized);

  inline SS2C_INVENTORY_TWO_HANDED_WEAPON_SWAP_RES(const SS2C_INVENTORY_TWO_HANDED_WEAPON_SWAP_RES& from) : SS2C_INVENTORY_TWO_HANDED_WEAPON_SWAP_RES(nullptr, from) {}
  inline SS2C_INVENTORY_TWO_HANDED_WEAPON_SWAP_RES(SS2C_INVENTORY_TWO_HANDED_WEAPON_SWAP_RES&& from) noexcept
      : SS2C_INVENTORY_TWO_HANDED_WEAPON_SWAP_RES(nullptr, std::move(from)) {}
  inline SS2C_INVENTORY_TWO_HANDED_WEAPON_SWAP_RES& operator=(const SS2C_INVENTORY_TWO_HANDED_WEAPON_SWAP_RES& from) {
    CopyFrom(from);
    return *this;
  }
  inline SS2C_INVENTORY_TWO_HANDED_WEAPON_SWAP_RES& operator=(SS2C_INVENTORY_TWO_HANDED_WEAPON_SWAP_RES&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SS2C_INVENTORY_TWO_HANDED_WEAPON_SWAP_RES& default_instance() {
    return *internal_default_instance();
  }
  static inline const SS2C_INVENTORY_TWO_HANDED_WEAPON_SWAP_RES* internal_default_instance() {
    return reinterpret_cast<const SS2C_INVENTORY_TWO_HANDED_WEAPON_SWAP_RES*>(
        &_SS2C_INVENTORY_TWO_HANDED_WEAPON_SWAP_RES_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(SS2C_INVENTORY_TWO_HANDED_WEAPON_SWAP_RES& a, SS2C_INVENTORY_TWO_HANDED_WEAPON_SWAP_RES& b) { a.Swap(&b); }
  inline void Swap(SS2C_INVENTORY_TWO_HANDED_WEAPON_SWAP_RES* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SS2C_INVENTORY_TWO_HANDED_WEAPON_SWAP_RES* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SS2C_INVENTORY_TWO_HANDED_WEAPON_SWAP_RES* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<SS2C_INVENTORY_TWO_HANDED_WEAPON_SWAP_RES>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SS2C_INVENTORY_TWO_HANDED_WEAPON_SWAP_RES& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SS2C_INVENTORY_TWO_HANDED_WEAPON_SWAP_RES& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DC.Packet.SS2C_INVENTORY_TWO_HANDED_WEAPON_SWAP_RES"; }

 protected:
  explicit SS2C_INVENTORY_TWO_HANDED_WEAPON_SWAP_RES(::google::protobuf::Arena* arena);
  SS2C_INVENTORY_TWO_HANDED_WEAPON_SWAP_RES(::google::protobuf::Arena* arena, const SS2C_INVENTORY_TWO_HANDED_WEAPON_SWAP_RES& from);
  SS2C_INVENTORY_TWO_HANDED_WEAPON_SWAP_RES(::google::protobuf::Arena* arena, SS2C_INVENTORY_TWO_HANDED_WEAPON_SWAP_RES&& from) noexcept
      : SS2C_INVENTORY_TWO_HANDED_WEAPON_SWAP_RES(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:DC.Packet.SS2C_INVENTORY_TWO_HANDED_WEAPON_SWAP_RES)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SS2C_INVENTORY_TWO_HANDED_WEAPON_SWAP_RES_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SS2C_INVENTORY_TWO_HANDED_WEAPON_SWAP_RES& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_Inventory_2eproto;
};
// -------------------------------------------------------------------

class SS2C_INVENTORY_SWAP_RES final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:DC.Packet.SS2C_INVENTORY_SWAP_RES) */ {
 public:
  inline SS2C_INVENTORY_SWAP_RES() : SS2C_INVENTORY_SWAP_RES(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SS2C_INVENTORY_SWAP_RES(
      ::google::protobuf::internal::ConstantInitialized);

  inline SS2C_INVENTORY_SWAP_RES(const SS2C_INVENTORY_SWAP_RES& from) : SS2C_INVENTORY_SWAP_RES(nullptr, from) {}
  inline SS2C_INVENTORY_SWAP_RES(SS2C_INVENTORY_SWAP_RES&& from) noexcept
      : SS2C_INVENTORY_SWAP_RES(nullptr, std::move(from)) {}
  inline SS2C_INVENTORY_SWAP_RES& operator=(const SS2C_INVENTORY_SWAP_RES& from) {
    CopyFrom(from);
    return *this;
  }
  inline SS2C_INVENTORY_SWAP_RES& operator=(SS2C_INVENTORY_SWAP_RES&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SS2C_INVENTORY_SWAP_RES& default_instance() {
    return *internal_default_instance();
  }
  static inline const SS2C_INVENTORY_SWAP_RES* internal_default_instance() {
    return reinterpret_cast<const SS2C_INVENTORY_SWAP_RES*>(
        &_SS2C_INVENTORY_SWAP_RES_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(SS2C_INVENTORY_SWAP_RES& a, SS2C_INVENTORY_SWAP_RES& b) { a.Swap(&b); }
  inline void Swap(SS2C_INVENTORY_SWAP_RES* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SS2C_INVENTORY_SWAP_RES* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SS2C_INVENTORY_SWAP_RES* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<SS2C_INVENTORY_SWAP_RES>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SS2C_INVENTORY_SWAP_RES& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SS2C_INVENTORY_SWAP_RES& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DC.Packet.SS2C_INVENTORY_SWAP_RES"; }

 protected:
  explicit SS2C_INVENTORY_SWAP_RES(::google::protobuf::Arena* arena);
  SS2C_INVENTORY_SWAP_RES(::google::protobuf::Arena* arena, const SS2C_INVENTORY_SWAP_RES& from);
  SS2C_INVENTORY_SWAP_RES(::google::protobuf::Arena* arena, SS2C_INVENTORY_SWAP_RES&& from) noexcept
      : SS2C_INVENTORY_SWAP_RES(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:DC.Packet.SS2C_INVENTORY_SWAP_RES)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SS2C_INVENTORY_SWAP_RES_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SS2C_INVENTORY_SWAP_RES& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_Inventory_2eproto;
};
// -------------------------------------------------------------------

class SS2C_INVENTORY_SPLIT_SWAP_RES final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DC.Packet.SS2C_INVENTORY_SPLIT_SWAP_RES) */ {
 public:
  inline SS2C_INVENTORY_SPLIT_SWAP_RES() : SS2C_INVENTORY_SPLIT_SWAP_RES(nullptr) {}
  ~SS2C_INVENTORY_SPLIT_SWAP_RES() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SS2C_INVENTORY_SPLIT_SWAP_RES(
      ::google::protobuf::internal::ConstantInitialized);

  inline SS2C_INVENTORY_SPLIT_SWAP_RES(const SS2C_INVENTORY_SPLIT_SWAP_RES& from) : SS2C_INVENTORY_SPLIT_SWAP_RES(nullptr, from) {}
  inline SS2C_INVENTORY_SPLIT_SWAP_RES(SS2C_INVENTORY_SPLIT_SWAP_RES&& from) noexcept
      : SS2C_INVENTORY_SPLIT_SWAP_RES(nullptr, std::move(from)) {}
  inline SS2C_INVENTORY_SPLIT_SWAP_RES& operator=(const SS2C_INVENTORY_SPLIT_SWAP_RES& from) {
    CopyFrom(from);
    return *this;
  }
  inline SS2C_INVENTORY_SPLIT_SWAP_RES& operator=(SS2C_INVENTORY_SPLIT_SWAP_RES&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SS2C_INVENTORY_SPLIT_SWAP_RES& default_instance() {
    return *internal_default_instance();
  }
  static inline const SS2C_INVENTORY_SPLIT_SWAP_RES* internal_default_instance() {
    return reinterpret_cast<const SS2C_INVENTORY_SPLIT_SWAP_RES*>(
        &_SS2C_INVENTORY_SPLIT_SWAP_RES_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(SS2C_INVENTORY_SPLIT_SWAP_RES& a, SS2C_INVENTORY_SPLIT_SWAP_RES& b) { a.Swap(&b); }
  inline void Swap(SS2C_INVENTORY_SPLIT_SWAP_RES* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SS2C_INVENTORY_SPLIT_SWAP_RES* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SS2C_INVENTORY_SPLIT_SWAP_RES* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<SS2C_INVENTORY_SPLIT_SWAP_RES>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SS2C_INVENTORY_SPLIT_SWAP_RES& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SS2C_INVENTORY_SPLIT_SWAP_RES& from) { SS2C_INVENTORY_SPLIT_SWAP_RES::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SS2C_INVENTORY_SPLIT_SWAP_RES* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DC.Packet.SS2C_INVENTORY_SPLIT_SWAP_RES"; }

 protected:
  explicit SS2C_INVENTORY_SPLIT_SWAP_RES(::google::protobuf::Arena* arena);
  SS2C_INVENTORY_SPLIT_SWAP_RES(::google::protobuf::Arena* arena, const SS2C_INVENTORY_SPLIT_SWAP_RES& from);
  SS2C_INVENTORY_SPLIT_SWAP_RES(::google::protobuf::Arena* arena, SS2C_INVENTORY_SPLIT_SWAP_RES&& from) noexcept
      : SS2C_INVENTORY_SPLIT_SWAP_RES(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNewUniqueIdFieldNumber = 1,
    kNewInventoryIdFieldNumber = 2,
    kNewSlotIdFieldNumber = 3,
  };
  // uint64 newUniqueId = 1;
  void clear_newuniqueid() ;
  ::uint64_t newuniqueid() const;
  void set_newuniqueid(::uint64_t value);

  private:
  ::uint64_t _internal_newuniqueid() const;
  void _internal_set_newuniqueid(::uint64_t value);

  public:
  // uint32 newInventoryId = 2;
  void clear_newinventoryid() ;
  ::uint32_t newinventoryid() const;
  void set_newinventoryid(::uint32_t value);

  private:
  ::uint32_t _internal_newinventoryid() const;
  void _internal_set_newinventoryid(::uint32_t value);

  public:
  // uint32 newSlotId = 3;
  void clear_newslotid() ;
  ::uint32_t newslotid() const;
  void set_newslotid(::uint32_t value);

  private:
  ::uint32_t _internal_newslotid() const;
  void _internal_set_newslotid(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:DC.Packet.SS2C_INVENTORY_SPLIT_SWAP_RES)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SS2C_INVENTORY_SPLIT_SWAP_RES_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SS2C_INVENTORY_SPLIT_SWAP_RES& from_msg);
    ::uint64_t newuniqueid_;
    ::uint32_t newinventoryid_;
    ::uint32_t newslotid_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Inventory_2eproto;
};
// -------------------------------------------------------------------

class SS2C_INVENTORY_SPLIT_MOVE_RES final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DC.Packet.SS2C_INVENTORY_SPLIT_MOVE_RES) */ {
 public:
  inline SS2C_INVENTORY_SPLIT_MOVE_RES() : SS2C_INVENTORY_SPLIT_MOVE_RES(nullptr) {}
  ~SS2C_INVENTORY_SPLIT_MOVE_RES() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SS2C_INVENTORY_SPLIT_MOVE_RES(
      ::google::protobuf::internal::ConstantInitialized);

  inline SS2C_INVENTORY_SPLIT_MOVE_RES(const SS2C_INVENTORY_SPLIT_MOVE_RES& from) : SS2C_INVENTORY_SPLIT_MOVE_RES(nullptr, from) {}
  inline SS2C_INVENTORY_SPLIT_MOVE_RES(SS2C_INVENTORY_SPLIT_MOVE_RES&& from) noexcept
      : SS2C_INVENTORY_SPLIT_MOVE_RES(nullptr, std::move(from)) {}
  inline SS2C_INVENTORY_SPLIT_MOVE_RES& operator=(const SS2C_INVENTORY_SPLIT_MOVE_RES& from) {
    CopyFrom(from);
    return *this;
  }
  inline SS2C_INVENTORY_SPLIT_MOVE_RES& operator=(SS2C_INVENTORY_SPLIT_MOVE_RES&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SS2C_INVENTORY_SPLIT_MOVE_RES& default_instance() {
    return *internal_default_instance();
  }
  static inline const SS2C_INVENTORY_SPLIT_MOVE_RES* internal_default_instance() {
    return reinterpret_cast<const SS2C_INVENTORY_SPLIT_MOVE_RES*>(
        &_SS2C_INVENTORY_SPLIT_MOVE_RES_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(SS2C_INVENTORY_SPLIT_MOVE_RES& a, SS2C_INVENTORY_SPLIT_MOVE_RES& b) { a.Swap(&b); }
  inline void Swap(SS2C_INVENTORY_SPLIT_MOVE_RES* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SS2C_INVENTORY_SPLIT_MOVE_RES* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SS2C_INVENTORY_SPLIT_MOVE_RES* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<SS2C_INVENTORY_SPLIT_MOVE_RES>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SS2C_INVENTORY_SPLIT_MOVE_RES& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SS2C_INVENTORY_SPLIT_MOVE_RES& from) { SS2C_INVENTORY_SPLIT_MOVE_RES::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SS2C_INVENTORY_SPLIT_MOVE_RES* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DC.Packet.SS2C_INVENTORY_SPLIT_MOVE_RES"; }

 protected:
  explicit SS2C_INVENTORY_SPLIT_MOVE_RES(::google::protobuf::Arena* arena);
  SS2C_INVENTORY_SPLIT_MOVE_RES(::google::protobuf::Arena* arena, const SS2C_INVENTORY_SPLIT_MOVE_RES& from);
  SS2C_INVENTORY_SPLIT_MOVE_RES(::google::protobuf::Arena* arena, SS2C_INVENTORY_SPLIT_MOVE_RES&& from) noexcept
      : SS2C_INVENTORY_SPLIT_MOVE_RES(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNewUniqueIdFieldNumber = 1,
    kNewInventoryIdFieldNumber = 2,
    kNewSlotIdFieldNumber = 3,
  };
  // uint64 newUniqueId = 1;
  void clear_newuniqueid() ;
  ::uint64_t newuniqueid() const;
  void set_newuniqueid(::uint64_t value);

  private:
  ::uint64_t _internal_newuniqueid() const;
  void _internal_set_newuniqueid(::uint64_t value);

  public:
  // uint32 newInventoryId = 2;
  void clear_newinventoryid() ;
  ::uint32_t newinventoryid() const;
  void set_newinventoryid(::uint32_t value);

  private:
  ::uint32_t _internal_newinventoryid() const;
  void _internal_set_newinventoryid(::uint32_t value);

  public:
  // uint32 newSlotId = 3;
  void clear_newslotid() ;
  ::uint32_t newslotid() const;
  void set_newslotid(::uint32_t value);

  private:
  ::uint32_t _internal_newslotid() const;
  void _internal_set_newslotid(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:DC.Packet.SS2C_INVENTORY_SPLIT_MOVE_RES)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SS2C_INVENTORY_SPLIT_MOVE_RES_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SS2C_INVENTORY_SPLIT_MOVE_RES& from_msg);
    ::uint64_t newuniqueid_;
    ::uint32_t newinventoryid_;
    ::uint32_t newslotid_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Inventory_2eproto;
};
// -------------------------------------------------------------------

class SS2C_INVENTORY_SPLIT_MERGE_RES final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:DC.Packet.SS2C_INVENTORY_SPLIT_MERGE_RES) */ {
 public:
  inline SS2C_INVENTORY_SPLIT_MERGE_RES() : SS2C_INVENTORY_SPLIT_MERGE_RES(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SS2C_INVENTORY_SPLIT_MERGE_RES(
      ::google::protobuf::internal::ConstantInitialized);

  inline SS2C_INVENTORY_SPLIT_MERGE_RES(const SS2C_INVENTORY_SPLIT_MERGE_RES& from) : SS2C_INVENTORY_SPLIT_MERGE_RES(nullptr, from) {}
  inline SS2C_INVENTORY_SPLIT_MERGE_RES(SS2C_INVENTORY_SPLIT_MERGE_RES&& from) noexcept
      : SS2C_INVENTORY_SPLIT_MERGE_RES(nullptr, std::move(from)) {}
  inline SS2C_INVENTORY_SPLIT_MERGE_RES& operator=(const SS2C_INVENTORY_SPLIT_MERGE_RES& from) {
    CopyFrom(from);
    return *this;
  }
  inline SS2C_INVENTORY_SPLIT_MERGE_RES& operator=(SS2C_INVENTORY_SPLIT_MERGE_RES&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SS2C_INVENTORY_SPLIT_MERGE_RES& default_instance() {
    return *internal_default_instance();
  }
  static inline const SS2C_INVENTORY_SPLIT_MERGE_RES* internal_default_instance() {
    return reinterpret_cast<const SS2C_INVENTORY_SPLIT_MERGE_RES*>(
        &_SS2C_INVENTORY_SPLIT_MERGE_RES_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(SS2C_INVENTORY_SPLIT_MERGE_RES& a, SS2C_INVENTORY_SPLIT_MERGE_RES& b) { a.Swap(&b); }
  inline void Swap(SS2C_INVENTORY_SPLIT_MERGE_RES* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SS2C_INVENTORY_SPLIT_MERGE_RES* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SS2C_INVENTORY_SPLIT_MERGE_RES* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<SS2C_INVENTORY_SPLIT_MERGE_RES>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SS2C_INVENTORY_SPLIT_MERGE_RES& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SS2C_INVENTORY_SPLIT_MERGE_RES& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DC.Packet.SS2C_INVENTORY_SPLIT_MERGE_RES"; }

 protected:
  explicit SS2C_INVENTORY_SPLIT_MERGE_RES(::google::protobuf::Arena* arena);
  SS2C_INVENTORY_SPLIT_MERGE_RES(::google::protobuf::Arena* arena, const SS2C_INVENTORY_SPLIT_MERGE_RES& from);
  SS2C_INVENTORY_SPLIT_MERGE_RES(::google::protobuf::Arena* arena, SS2C_INVENTORY_SPLIT_MERGE_RES&& from) noexcept
      : SS2C_INVENTORY_SPLIT_MERGE_RES(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:DC.Packet.SS2C_INVENTORY_SPLIT_MERGE_RES)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SS2C_INVENTORY_SPLIT_MERGE_RES_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SS2C_INVENTORY_SPLIT_MERGE_RES& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_Inventory_2eproto;
};
// -------------------------------------------------------------------

class SS2C_INVENTORY_MOVE_RES final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:DC.Packet.SS2C_INVENTORY_MOVE_RES) */ {
 public:
  inline SS2C_INVENTORY_MOVE_RES() : SS2C_INVENTORY_MOVE_RES(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SS2C_INVENTORY_MOVE_RES(
      ::google::protobuf::internal::ConstantInitialized);

  inline SS2C_INVENTORY_MOVE_RES(const SS2C_INVENTORY_MOVE_RES& from) : SS2C_INVENTORY_MOVE_RES(nullptr, from) {}
  inline SS2C_INVENTORY_MOVE_RES(SS2C_INVENTORY_MOVE_RES&& from) noexcept
      : SS2C_INVENTORY_MOVE_RES(nullptr, std::move(from)) {}
  inline SS2C_INVENTORY_MOVE_RES& operator=(const SS2C_INVENTORY_MOVE_RES& from) {
    CopyFrom(from);
    return *this;
  }
  inline SS2C_INVENTORY_MOVE_RES& operator=(SS2C_INVENTORY_MOVE_RES&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SS2C_INVENTORY_MOVE_RES& default_instance() {
    return *internal_default_instance();
  }
  static inline const SS2C_INVENTORY_MOVE_RES* internal_default_instance() {
    return reinterpret_cast<const SS2C_INVENTORY_MOVE_RES*>(
        &_SS2C_INVENTORY_MOVE_RES_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(SS2C_INVENTORY_MOVE_RES& a, SS2C_INVENTORY_MOVE_RES& b) { a.Swap(&b); }
  inline void Swap(SS2C_INVENTORY_MOVE_RES* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SS2C_INVENTORY_MOVE_RES* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SS2C_INVENTORY_MOVE_RES* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<SS2C_INVENTORY_MOVE_RES>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SS2C_INVENTORY_MOVE_RES& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SS2C_INVENTORY_MOVE_RES& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DC.Packet.SS2C_INVENTORY_MOVE_RES"; }

 protected:
  explicit SS2C_INVENTORY_MOVE_RES(::google::protobuf::Arena* arena);
  SS2C_INVENTORY_MOVE_RES(::google::protobuf::Arena* arena, const SS2C_INVENTORY_MOVE_RES& from);
  SS2C_INVENTORY_MOVE_RES(::google::protobuf::Arena* arena, SS2C_INVENTORY_MOVE_RES&& from) noexcept
      : SS2C_INVENTORY_MOVE_RES(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:DC.Packet.SS2C_INVENTORY_MOVE_RES)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SS2C_INVENTORY_MOVE_RES_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SS2C_INVENTORY_MOVE_RES& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_Inventory_2eproto;
};
// -------------------------------------------------------------------

class SS2C_INVENTORY_MERGE_RES final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:DC.Packet.SS2C_INVENTORY_MERGE_RES) */ {
 public:
  inline SS2C_INVENTORY_MERGE_RES() : SS2C_INVENTORY_MERGE_RES(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SS2C_INVENTORY_MERGE_RES(
      ::google::protobuf::internal::ConstantInitialized);

  inline SS2C_INVENTORY_MERGE_RES(const SS2C_INVENTORY_MERGE_RES& from) : SS2C_INVENTORY_MERGE_RES(nullptr, from) {}
  inline SS2C_INVENTORY_MERGE_RES(SS2C_INVENTORY_MERGE_RES&& from) noexcept
      : SS2C_INVENTORY_MERGE_RES(nullptr, std::move(from)) {}
  inline SS2C_INVENTORY_MERGE_RES& operator=(const SS2C_INVENTORY_MERGE_RES& from) {
    CopyFrom(from);
    return *this;
  }
  inline SS2C_INVENTORY_MERGE_RES& operator=(SS2C_INVENTORY_MERGE_RES&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SS2C_INVENTORY_MERGE_RES& default_instance() {
    return *internal_default_instance();
  }
  static inline const SS2C_INVENTORY_MERGE_RES* internal_default_instance() {
    return reinterpret_cast<const SS2C_INVENTORY_MERGE_RES*>(
        &_SS2C_INVENTORY_MERGE_RES_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(SS2C_INVENTORY_MERGE_RES& a, SS2C_INVENTORY_MERGE_RES& b) { a.Swap(&b); }
  inline void Swap(SS2C_INVENTORY_MERGE_RES* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SS2C_INVENTORY_MERGE_RES* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SS2C_INVENTORY_MERGE_RES* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<SS2C_INVENTORY_MERGE_RES>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SS2C_INVENTORY_MERGE_RES& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SS2C_INVENTORY_MERGE_RES& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DC.Packet.SS2C_INVENTORY_MERGE_RES"; }

 protected:
  explicit SS2C_INVENTORY_MERGE_RES(::google::protobuf::Arena* arena);
  SS2C_INVENTORY_MERGE_RES(::google::protobuf::Arena* arena, const SS2C_INVENTORY_MERGE_RES& from);
  SS2C_INVENTORY_MERGE_RES(::google::protobuf::Arena* arena, SS2C_INVENTORY_MERGE_RES&& from) noexcept
      : SS2C_INVENTORY_MERGE_RES(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:DC.Packet.SS2C_INVENTORY_MERGE_RES)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SS2C_INVENTORY_MERGE_RES_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SS2C_INVENTORY_MERGE_RES& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_Inventory_2eproto;
};
// -------------------------------------------------------------------

class SS2C_INVENTORY_EXPAND_STORAGE_RES final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DC.Packet.SS2C_INVENTORY_EXPAND_STORAGE_RES) */ {
 public:
  inline SS2C_INVENTORY_EXPAND_STORAGE_RES() : SS2C_INVENTORY_EXPAND_STORAGE_RES(nullptr) {}
  ~SS2C_INVENTORY_EXPAND_STORAGE_RES() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SS2C_INVENTORY_EXPAND_STORAGE_RES(
      ::google::protobuf::internal::ConstantInitialized);

  inline SS2C_INVENTORY_EXPAND_STORAGE_RES(const SS2C_INVENTORY_EXPAND_STORAGE_RES& from) : SS2C_INVENTORY_EXPAND_STORAGE_RES(nullptr, from) {}
  inline SS2C_INVENTORY_EXPAND_STORAGE_RES(SS2C_INVENTORY_EXPAND_STORAGE_RES&& from) noexcept
      : SS2C_INVENTORY_EXPAND_STORAGE_RES(nullptr, std::move(from)) {}
  inline SS2C_INVENTORY_EXPAND_STORAGE_RES& operator=(const SS2C_INVENTORY_EXPAND_STORAGE_RES& from) {
    CopyFrom(from);
    return *this;
  }
  inline SS2C_INVENTORY_EXPAND_STORAGE_RES& operator=(SS2C_INVENTORY_EXPAND_STORAGE_RES&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SS2C_INVENTORY_EXPAND_STORAGE_RES& default_instance() {
    return *internal_default_instance();
  }
  static inline const SS2C_INVENTORY_EXPAND_STORAGE_RES* internal_default_instance() {
    return reinterpret_cast<const SS2C_INVENTORY_EXPAND_STORAGE_RES*>(
        &_SS2C_INVENTORY_EXPAND_STORAGE_RES_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 25;
  friend void swap(SS2C_INVENTORY_EXPAND_STORAGE_RES& a, SS2C_INVENTORY_EXPAND_STORAGE_RES& b) { a.Swap(&b); }
  inline void Swap(SS2C_INVENTORY_EXPAND_STORAGE_RES* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SS2C_INVENTORY_EXPAND_STORAGE_RES* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SS2C_INVENTORY_EXPAND_STORAGE_RES* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<SS2C_INVENTORY_EXPAND_STORAGE_RES>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SS2C_INVENTORY_EXPAND_STORAGE_RES& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SS2C_INVENTORY_EXPAND_STORAGE_RES& from) { SS2C_INVENTORY_EXPAND_STORAGE_RES::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SS2C_INVENTORY_EXPAND_STORAGE_RES* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DC.Packet.SS2C_INVENTORY_EXPAND_STORAGE_RES"; }

 protected:
  explicit SS2C_INVENTORY_EXPAND_STORAGE_RES(::google::protobuf::Arena* arena);
  SS2C_INVENTORY_EXPAND_STORAGE_RES(::google::protobuf::Arena* arena, const SS2C_INVENTORY_EXPAND_STORAGE_RES& from);
  SS2C_INVENTORY_EXPAND_STORAGE_RES(::google::protobuf::Arena* arena, SS2C_INVENTORY_EXPAND_STORAGE_RES&& from) noexcept
      : SS2C_INVENTORY_EXPAND_STORAGE_RES(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kResultFieldNumber = 1,
  };
  // uint32 result = 1;
  void clear_result() ;
  ::uint32_t result() const;
  void set_result(::uint32_t value);

  private:
  ::uint32_t _internal_result() const;
  void _internal_set_result(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:DC.Packet.SS2C_INVENTORY_EXPAND_STORAGE_RES)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SS2C_INVENTORY_EXPAND_STORAGE_RES_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SS2C_INVENTORY_EXPAND_STORAGE_RES& from_msg);
    ::uint32_t result_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Inventory_2eproto;
};
// -------------------------------------------------------------------

class SINVENTORY_ITEM_REQ_INFO final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DC.Packet.SINVENTORY_ITEM_REQ_INFO) */ {
 public:
  inline SINVENTORY_ITEM_REQ_INFO() : SINVENTORY_ITEM_REQ_INFO(nullptr) {}
  ~SINVENTORY_ITEM_REQ_INFO() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SINVENTORY_ITEM_REQ_INFO(
      ::google::protobuf::internal::ConstantInitialized);

  inline SINVENTORY_ITEM_REQ_INFO(const SINVENTORY_ITEM_REQ_INFO& from) : SINVENTORY_ITEM_REQ_INFO(nullptr, from) {}
  inline SINVENTORY_ITEM_REQ_INFO(SINVENTORY_ITEM_REQ_INFO&& from) noexcept
      : SINVENTORY_ITEM_REQ_INFO(nullptr, std::move(from)) {}
  inline SINVENTORY_ITEM_REQ_INFO& operator=(const SINVENTORY_ITEM_REQ_INFO& from) {
    CopyFrom(from);
    return *this;
  }
  inline SINVENTORY_ITEM_REQ_INFO& operator=(SINVENTORY_ITEM_REQ_INFO&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SINVENTORY_ITEM_REQ_INFO& default_instance() {
    return *internal_default_instance();
  }
  static inline const SINVENTORY_ITEM_REQ_INFO* internal_default_instance() {
    return reinterpret_cast<const SINVENTORY_ITEM_REQ_INFO*>(
        &_SINVENTORY_ITEM_REQ_INFO_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(SINVENTORY_ITEM_REQ_INFO& a, SINVENTORY_ITEM_REQ_INFO& b) { a.Swap(&b); }
  inline void Swap(SINVENTORY_ITEM_REQ_INFO* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SINVENTORY_ITEM_REQ_INFO* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SINVENTORY_ITEM_REQ_INFO* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<SINVENTORY_ITEM_REQ_INFO>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SINVENTORY_ITEM_REQ_INFO& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SINVENTORY_ITEM_REQ_INFO& from) { SINVENTORY_ITEM_REQ_INFO::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SINVENTORY_ITEM_REQ_INFO* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DC.Packet.SINVENTORY_ITEM_REQ_INFO"; }

 protected:
  explicit SINVENTORY_ITEM_REQ_INFO(::google::protobuf::Arena* arena);
  SINVENTORY_ITEM_REQ_INFO(::google::protobuf::Arena* arena, const SINVENTORY_ITEM_REQ_INFO& from);
  SINVENTORY_ITEM_REQ_INFO(::google::protobuf::Arena* arena, SINVENTORY_ITEM_REQ_INFO&& from) noexcept
      : SINVENTORY_ITEM_REQ_INFO(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUniqueIdFieldNumber = 1,
    kInventoryIdFieldNumber = 2,
    kSlotIdFieldNumber = 3,
  };
  // uint64 uniqueId = 1;
  void clear_uniqueid() ;
  ::uint64_t uniqueid() const;
  void set_uniqueid(::uint64_t value);

  private:
  ::uint64_t _internal_uniqueid() const;
  void _internal_set_uniqueid(::uint64_t value);

  public:
  // uint32 inventoryId = 2;
  void clear_inventoryid() ;
  ::uint32_t inventoryid() const;
  void set_inventoryid(::uint32_t value);

  private:
  ::uint32_t _internal_inventoryid() const;
  void _internal_set_inventoryid(::uint32_t value);

  public:
  // uint32 slotId = 3;
  void clear_slotid() ;
  ::uint32_t slotid() const;
  void set_slotid(::uint32_t value);

  private:
  ::uint32_t _internal_slotid() const;
  void _internal_set_slotid(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:DC.Packet.SINVENTORY_ITEM_REQ_INFO)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SINVENTORY_ITEM_REQ_INFO_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SINVENTORY_ITEM_REQ_INFO& from_msg);
    ::uint64_t uniqueid_;
    ::uint32_t inventoryid_;
    ::uint32_t slotid_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Inventory_2eproto;
};
// -------------------------------------------------------------------

class SC2S_STORAGE_INFO_REQ final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DC.Packet.SC2S_STORAGE_INFO_REQ) */ {
 public:
  inline SC2S_STORAGE_INFO_REQ() : SC2S_STORAGE_INFO_REQ(nullptr) {}
  ~SC2S_STORAGE_INFO_REQ() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SC2S_STORAGE_INFO_REQ(
      ::google::protobuf::internal::ConstantInitialized);

  inline SC2S_STORAGE_INFO_REQ(const SC2S_STORAGE_INFO_REQ& from) : SC2S_STORAGE_INFO_REQ(nullptr, from) {}
  inline SC2S_STORAGE_INFO_REQ(SC2S_STORAGE_INFO_REQ&& from) noexcept
      : SC2S_STORAGE_INFO_REQ(nullptr, std::move(from)) {}
  inline SC2S_STORAGE_INFO_REQ& operator=(const SC2S_STORAGE_INFO_REQ& from) {
    CopyFrom(from);
    return *this;
  }
  inline SC2S_STORAGE_INFO_REQ& operator=(SC2S_STORAGE_INFO_REQ&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SC2S_STORAGE_INFO_REQ& default_instance() {
    return *internal_default_instance();
  }
  static inline const SC2S_STORAGE_INFO_REQ* internal_default_instance() {
    return reinterpret_cast<const SC2S_STORAGE_INFO_REQ*>(
        &_SC2S_STORAGE_INFO_REQ_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(SC2S_STORAGE_INFO_REQ& a, SC2S_STORAGE_INFO_REQ& b) { a.Swap(&b); }
  inline void Swap(SC2S_STORAGE_INFO_REQ* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SC2S_STORAGE_INFO_REQ* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SC2S_STORAGE_INFO_REQ* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<SC2S_STORAGE_INFO_REQ>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SC2S_STORAGE_INFO_REQ& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SC2S_STORAGE_INFO_REQ& from) { SC2S_STORAGE_INFO_REQ::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SC2S_STORAGE_INFO_REQ* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DC.Packet.SC2S_STORAGE_INFO_REQ"; }

 protected:
  explicit SC2S_STORAGE_INFO_REQ(::google::protobuf::Arena* arena);
  SC2S_STORAGE_INFO_REQ(::google::protobuf::Arena* arena, const SC2S_STORAGE_INFO_REQ& from);
  SC2S_STORAGE_INFO_REQ(::google::protobuf::Arena* arena, SC2S_STORAGE_INFO_REQ&& from) noexcept
      : SC2S_STORAGE_INFO_REQ(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIsRefreshFieldNumber = 1,
  };
  // uint32 isRefresh = 1;
  void clear_isrefresh() ;
  ::uint32_t isrefresh() const;
  void set_isrefresh(::uint32_t value);

  private:
  ::uint32_t _internal_isrefresh() const;
  void _internal_set_isrefresh(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:DC.Packet.SC2S_STORAGE_INFO_REQ)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SC2S_STORAGE_INFO_REQ_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SC2S_STORAGE_INFO_REQ& from_msg);
    ::uint32_t isrefresh_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Inventory_2eproto;
};
// -------------------------------------------------------------------

class SC2S_INVENTORY_INFO_REQ final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:DC.Packet.SC2S_INVENTORY_INFO_REQ) */ {
 public:
  inline SC2S_INVENTORY_INFO_REQ() : SC2S_INVENTORY_INFO_REQ(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SC2S_INVENTORY_INFO_REQ(
      ::google::protobuf::internal::ConstantInitialized);

  inline SC2S_INVENTORY_INFO_REQ(const SC2S_INVENTORY_INFO_REQ& from) : SC2S_INVENTORY_INFO_REQ(nullptr, from) {}
  inline SC2S_INVENTORY_INFO_REQ(SC2S_INVENTORY_INFO_REQ&& from) noexcept
      : SC2S_INVENTORY_INFO_REQ(nullptr, std::move(from)) {}
  inline SC2S_INVENTORY_INFO_REQ& operator=(const SC2S_INVENTORY_INFO_REQ& from) {
    CopyFrom(from);
    return *this;
  }
  inline SC2S_INVENTORY_INFO_REQ& operator=(SC2S_INVENTORY_INFO_REQ&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SC2S_INVENTORY_INFO_REQ& default_instance() {
    return *internal_default_instance();
  }
  static inline const SC2S_INVENTORY_INFO_REQ* internal_default_instance() {
    return reinterpret_cast<const SC2S_INVENTORY_INFO_REQ*>(
        &_SC2S_INVENTORY_INFO_REQ_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(SC2S_INVENTORY_INFO_REQ& a, SC2S_INVENTORY_INFO_REQ& b) { a.Swap(&b); }
  inline void Swap(SC2S_INVENTORY_INFO_REQ* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SC2S_INVENTORY_INFO_REQ* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SC2S_INVENTORY_INFO_REQ* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<SC2S_INVENTORY_INFO_REQ>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SC2S_INVENTORY_INFO_REQ& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SC2S_INVENTORY_INFO_REQ& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DC.Packet.SC2S_INVENTORY_INFO_REQ"; }

 protected:
  explicit SC2S_INVENTORY_INFO_REQ(::google::protobuf::Arena* arena);
  SC2S_INVENTORY_INFO_REQ(::google::protobuf::Arena* arena, const SC2S_INVENTORY_INFO_REQ& from);
  SC2S_INVENTORY_INFO_REQ(::google::protobuf::Arena* arena, SC2S_INVENTORY_INFO_REQ&& from) noexcept
      : SC2S_INVENTORY_INFO_REQ(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:DC.Packet.SC2S_INVENTORY_INFO_REQ)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SC2S_INVENTORY_INFO_REQ_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SC2S_INVENTORY_INFO_REQ& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_Inventory_2eproto;
};
// -------------------------------------------------------------------

class SC2S_INVENTORY_EXPAND_STORAGE_REQ final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DC.Packet.SC2S_INVENTORY_EXPAND_STORAGE_REQ) */ {
 public:
  inline SC2S_INVENTORY_EXPAND_STORAGE_REQ() : SC2S_INVENTORY_EXPAND_STORAGE_REQ(nullptr) {}
  ~SC2S_INVENTORY_EXPAND_STORAGE_REQ() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SC2S_INVENTORY_EXPAND_STORAGE_REQ(
      ::google::protobuf::internal::ConstantInitialized);

  inline SC2S_INVENTORY_EXPAND_STORAGE_REQ(const SC2S_INVENTORY_EXPAND_STORAGE_REQ& from) : SC2S_INVENTORY_EXPAND_STORAGE_REQ(nullptr, from) {}
  inline SC2S_INVENTORY_EXPAND_STORAGE_REQ(SC2S_INVENTORY_EXPAND_STORAGE_REQ&& from) noexcept
      : SC2S_INVENTORY_EXPAND_STORAGE_REQ(nullptr, std::move(from)) {}
  inline SC2S_INVENTORY_EXPAND_STORAGE_REQ& operator=(const SC2S_INVENTORY_EXPAND_STORAGE_REQ& from) {
    CopyFrom(from);
    return *this;
  }
  inline SC2S_INVENTORY_EXPAND_STORAGE_REQ& operator=(SC2S_INVENTORY_EXPAND_STORAGE_REQ&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SC2S_INVENTORY_EXPAND_STORAGE_REQ& default_instance() {
    return *internal_default_instance();
  }
  static inline const SC2S_INVENTORY_EXPAND_STORAGE_REQ* internal_default_instance() {
    return reinterpret_cast<const SC2S_INVENTORY_EXPAND_STORAGE_REQ*>(
        &_SC2S_INVENTORY_EXPAND_STORAGE_REQ_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(SC2S_INVENTORY_EXPAND_STORAGE_REQ& a, SC2S_INVENTORY_EXPAND_STORAGE_REQ& b) { a.Swap(&b); }
  inline void Swap(SC2S_INVENTORY_EXPAND_STORAGE_REQ* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SC2S_INVENTORY_EXPAND_STORAGE_REQ* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SC2S_INVENTORY_EXPAND_STORAGE_REQ* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<SC2S_INVENTORY_EXPAND_STORAGE_REQ>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SC2S_INVENTORY_EXPAND_STORAGE_REQ& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SC2S_INVENTORY_EXPAND_STORAGE_REQ& from) { SC2S_INVENTORY_EXPAND_STORAGE_REQ::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SC2S_INVENTORY_EXPAND_STORAGE_REQ* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DC.Packet.SC2S_INVENTORY_EXPAND_STORAGE_REQ"; }

 protected:
  explicit SC2S_INVENTORY_EXPAND_STORAGE_REQ(::google::protobuf::Arena* arena);
  SC2S_INVENTORY_EXPAND_STORAGE_REQ(::google::protobuf::Arena* arena, const SC2S_INVENTORY_EXPAND_STORAGE_REQ& from);
  SC2S_INVENTORY_EXPAND_STORAGE_REQ(::google::protobuf::Arena* arena, SC2S_INVENTORY_EXPAND_STORAGE_REQ&& from) noexcept
      : SC2S_INVENTORY_EXPAND_STORAGE_REQ(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBuyInventoryIdFieldNumber = 1,
  };
  // int32 buyInventoryId = 1;
  void clear_buyinventoryid() ;
  ::int32_t buyinventoryid() const;
  void set_buyinventoryid(::int32_t value);

  private:
  ::int32_t _internal_buyinventoryid() const;
  void _internal_set_buyinventoryid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:DC.Packet.SC2S_INVENTORY_EXPAND_STORAGE_REQ)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SC2S_INVENTORY_EXPAND_STORAGE_REQ_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SC2S_INVENTORY_EXPAND_STORAGE_REQ& from_msg);
    ::int32_t buyinventoryid_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Inventory_2eproto;
};
// -------------------------------------------------------------------

class SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DC.Packet.SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ) */ {
 public:
  inline SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ() : SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ(nullptr) {}
  ~SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ(
      ::google::protobuf::internal::ConstantInitialized);

  inline SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ(const SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ& from) : SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ(nullptr, from) {}
  inline SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ(SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ&& from) noexcept
      : SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ(nullptr, std::move(from)) {}
  inline SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ& operator=(const SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ& from) {
    CopyFrom(from);
    return *this;
  }
  inline SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ& operator=(SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ& default_instance() {
    return *internal_default_instance();
  }
  static inline const SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ* internal_default_instance() {
    return reinterpret_cast<const SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ*>(
        &_SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ& a, SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ& b) { a.Swap(&b); }
  inline void Swap(SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ& from) { SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DC.Packet.SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ"; }

 protected:
  explicit SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ(::google::protobuf::Arena* arena);
  SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ(::google::protobuf::Arena* arena, const SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ& from);
  SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ(::google::protobuf::Arena* arena, SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ&& from) noexcept
      : SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSrcInfoFieldNumber = 1,
    kDstInfoFieldNumber = 2,
    kNewSlotIdFieldNumber = 3,
    kNewInventoryIdFieldNumber = 4,
  };
  // .DC.Packet.SINVENTORY_ITEM_REQ_INFO srcInfo = 1;
  bool has_srcinfo() const;
  void clear_srcinfo() ;
  const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& srcinfo() const;
  PROTOBUF_NODISCARD ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* release_srcinfo();
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* mutable_srcinfo();
  void set_allocated_srcinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value);
  void unsafe_arena_set_allocated_srcinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value);
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* unsafe_arena_release_srcinfo();

  private:
  const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& _internal_srcinfo() const;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* _internal_mutable_srcinfo();

  public:
  // .DC.Packet.SINVENTORY_ITEM_REQ_INFO dstInfo = 2;
  bool has_dstinfo() const;
  void clear_dstinfo() ;
  const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& dstinfo() const;
  PROTOBUF_NODISCARD ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* release_dstinfo();
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* mutable_dstinfo();
  void set_allocated_dstinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value);
  void unsafe_arena_set_allocated_dstinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value);
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* unsafe_arena_release_dstinfo();

  private:
  const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& _internal_dstinfo() const;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* _internal_mutable_dstinfo();

  public:
  // uint32 newSlotId = 3;
  void clear_newslotid() ;
  ::uint32_t newslotid() const;
  void set_newslotid(::uint32_t value);

  private:
  ::uint32_t _internal_newslotid() const;
  void _internal_set_newslotid(::uint32_t value);

  public:
  // uint32 newInventoryId = 4;
  void clear_newinventoryid() ;
  ::uint32_t newinventoryid() const;
  void set_newinventoryid(::uint32_t value);

  private:
  ::uint32_t _internal_newinventoryid() const;
  void _internal_set_newinventoryid(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:DC.Packet.SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* srcinfo_;
    ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* dstinfo_;
    ::uint32_t newslotid_;
    ::uint32_t newinventoryid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Inventory_2eproto;
};
// -------------------------------------------------------------------

class SC2S_INVENTORY_SPLIT_SWAP_REQ final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DC.Packet.SC2S_INVENTORY_SPLIT_SWAP_REQ) */ {
 public:
  inline SC2S_INVENTORY_SPLIT_SWAP_REQ() : SC2S_INVENTORY_SPLIT_SWAP_REQ(nullptr) {}
  ~SC2S_INVENTORY_SPLIT_SWAP_REQ() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SC2S_INVENTORY_SPLIT_SWAP_REQ(
      ::google::protobuf::internal::ConstantInitialized);

  inline SC2S_INVENTORY_SPLIT_SWAP_REQ(const SC2S_INVENTORY_SPLIT_SWAP_REQ& from) : SC2S_INVENTORY_SPLIT_SWAP_REQ(nullptr, from) {}
  inline SC2S_INVENTORY_SPLIT_SWAP_REQ(SC2S_INVENTORY_SPLIT_SWAP_REQ&& from) noexcept
      : SC2S_INVENTORY_SPLIT_SWAP_REQ(nullptr, std::move(from)) {}
  inline SC2S_INVENTORY_SPLIT_SWAP_REQ& operator=(const SC2S_INVENTORY_SPLIT_SWAP_REQ& from) {
    CopyFrom(from);
    return *this;
  }
  inline SC2S_INVENTORY_SPLIT_SWAP_REQ& operator=(SC2S_INVENTORY_SPLIT_SWAP_REQ&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SC2S_INVENTORY_SPLIT_SWAP_REQ& default_instance() {
    return *internal_default_instance();
  }
  static inline const SC2S_INVENTORY_SPLIT_SWAP_REQ* internal_default_instance() {
    return reinterpret_cast<const SC2S_INVENTORY_SPLIT_SWAP_REQ*>(
        &_SC2S_INVENTORY_SPLIT_SWAP_REQ_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(SC2S_INVENTORY_SPLIT_SWAP_REQ& a, SC2S_INVENTORY_SPLIT_SWAP_REQ& b) { a.Swap(&b); }
  inline void Swap(SC2S_INVENTORY_SPLIT_SWAP_REQ* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SC2S_INVENTORY_SPLIT_SWAP_REQ* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SC2S_INVENTORY_SPLIT_SWAP_REQ* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<SC2S_INVENTORY_SPLIT_SWAP_REQ>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SC2S_INVENTORY_SPLIT_SWAP_REQ& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SC2S_INVENTORY_SPLIT_SWAP_REQ& from) { SC2S_INVENTORY_SPLIT_SWAP_REQ::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SC2S_INVENTORY_SPLIT_SWAP_REQ* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DC.Packet.SC2S_INVENTORY_SPLIT_SWAP_REQ"; }

 protected:
  explicit SC2S_INVENTORY_SPLIT_SWAP_REQ(::google::protobuf::Arena* arena);
  SC2S_INVENTORY_SPLIT_SWAP_REQ(::google::protobuf::Arena* arena, const SC2S_INVENTORY_SPLIT_SWAP_REQ& from);
  SC2S_INVENTORY_SPLIT_SWAP_REQ(::google::protobuf::Arena* arena, SC2S_INVENTORY_SPLIT_SWAP_REQ&& from) noexcept
      : SC2S_INVENTORY_SPLIT_SWAP_REQ(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSrcInfoFieldNumber = 1,
    kDstInfoFieldNumber = 2,
    kCountFieldNumber = 3,
    kNewSlotIdFieldNumber = 4,
    kNewInventoryIdFieldNumber = 5,
  };
  // .DC.Packet.SINVENTORY_ITEM_REQ_INFO srcInfo = 1;
  bool has_srcinfo() const;
  void clear_srcinfo() ;
  const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& srcinfo() const;
  PROTOBUF_NODISCARD ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* release_srcinfo();
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* mutable_srcinfo();
  void set_allocated_srcinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value);
  void unsafe_arena_set_allocated_srcinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value);
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* unsafe_arena_release_srcinfo();

  private:
  const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& _internal_srcinfo() const;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* _internal_mutable_srcinfo();

  public:
  // .DC.Packet.SINVENTORY_ITEM_REQ_INFO dstInfo = 2;
  bool has_dstinfo() const;
  void clear_dstinfo() ;
  const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& dstinfo() const;
  PROTOBUF_NODISCARD ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* release_dstinfo();
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* mutable_dstinfo();
  void set_allocated_dstinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value);
  void unsafe_arena_set_allocated_dstinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value);
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* unsafe_arena_release_dstinfo();

  private:
  const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& _internal_dstinfo() const;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* _internal_mutable_dstinfo();

  public:
  // uint32 count = 3;
  void clear_count() ;
  ::uint32_t count() const;
  void set_count(::uint32_t value);

  private:
  ::uint32_t _internal_count() const;
  void _internal_set_count(::uint32_t value);

  public:
  // uint32 newSlotId = 4;
  void clear_newslotid() ;
  ::uint32_t newslotid() const;
  void set_newslotid(::uint32_t value);

  private:
  ::uint32_t _internal_newslotid() const;
  void _internal_set_newslotid(::uint32_t value);

  public:
  // uint32 newInventoryId = 5;
  void clear_newinventoryid() ;
  ::uint32_t newinventoryid() const;
  void set_newinventoryid(::uint32_t value);

  private:
  ::uint32_t _internal_newinventoryid() const;
  void _internal_set_newinventoryid(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:DC.Packet.SC2S_INVENTORY_SPLIT_SWAP_REQ)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SC2S_INVENTORY_SPLIT_SWAP_REQ_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SC2S_INVENTORY_SPLIT_SWAP_REQ& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* srcinfo_;
    ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* dstinfo_;
    ::uint32_t count_;
    ::uint32_t newslotid_;
    ::uint32_t newinventoryid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Inventory_2eproto;
};
// -------------------------------------------------------------------

class SC2S_INVENTORY_SPLIT_MOVE_REQ final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DC.Packet.SC2S_INVENTORY_SPLIT_MOVE_REQ) */ {
 public:
  inline SC2S_INVENTORY_SPLIT_MOVE_REQ() : SC2S_INVENTORY_SPLIT_MOVE_REQ(nullptr) {}
  ~SC2S_INVENTORY_SPLIT_MOVE_REQ() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SC2S_INVENTORY_SPLIT_MOVE_REQ(
      ::google::protobuf::internal::ConstantInitialized);

  inline SC2S_INVENTORY_SPLIT_MOVE_REQ(const SC2S_INVENTORY_SPLIT_MOVE_REQ& from) : SC2S_INVENTORY_SPLIT_MOVE_REQ(nullptr, from) {}
  inline SC2S_INVENTORY_SPLIT_MOVE_REQ(SC2S_INVENTORY_SPLIT_MOVE_REQ&& from) noexcept
      : SC2S_INVENTORY_SPLIT_MOVE_REQ(nullptr, std::move(from)) {}
  inline SC2S_INVENTORY_SPLIT_MOVE_REQ& operator=(const SC2S_INVENTORY_SPLIT_MOVE_REQ& from) {
    CopyFrom(from);
    return *this;
  }
  inline SC2S_INVENTORY_SPLIT_MOVE_REQ& operator=(SC2S_INVENTORY_SPLIT_MOVE_REQ&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SC2S_INVENTORY_SPLIT_MOVE_REQ& default_instance() {
    return *internal_default_instance();
  }
  static inline const SC2S_INVENTORY_SPLIT_MOVE_REQ* internal_default_instance() {
    return reinterpret_cast<const SC2S_INVENTORY_SPLIT_MOVE_REQ*>(
        &_SC2S_INVENTORY_SPLIT_MOVE_REQ_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(SC2S_INVENTORY_SPLIT_MOVE_REQ& a, SC2S_INVENTORY_SPLIT_MOVE_REQ& b) { a.Swap(&b); }
  inline void Swap(SC2S_INVENTORY_SPLIT_MOVE_REQ* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SC2S_INVENTORY_SPLIT_MOVE_REQ* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SC2S_INVENTORY_SPLIT_MOVE_REQ* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<SC2S_INVENTORY_SPLIT_MOVE_REQ>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SC2S_INVENTORY_SPLIT_MOVE_REQ& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SC2S_INVENTORY_SPLIT_MOVE_REQ& from) { SC2S_INVENTORY_SPLIT_MOVE_REQ::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SC2S_INVENTORY_SPLIT_MOVE_REQ* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DC.Packet.SC2S_INVENTORY_SPLIT_MOVE_REQ"; }

 protected:
  explicit SC2S_INVENTORY_SPLIT_MOVE_REQ(::google::protobuf::Arena* arena);
  SC2S_INVENTORY_SPLIT_MOVE_REQ(::google::protobuf::Arena* arena, const SC2S_INVENTORY_SPLIT_MOVE_REQ& from);
  SC2S_INVENTORY_SPLIT_MOVE_REQ(::google::protobuf::Arena* arena, SC2S_INVENTORY_SPLIT_MOVE_REQ&& from) noexcept
      : SC2S_INVENTORY_SPLIT_MOVE_REQ(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSrcInfoFieldNumber = 1,
    kCountFieldNumber = 2,
    kDstInventoryIdFieldNumber = 3,
    kDstSlotIdFieldNumber = 4,
  };
  // .DC.Packet.SINVENTORY_ITEM_REQ_INFO srcInfo = 1;
  bool has_srcinfo() const;
  void clear_srcinfo() ;
  const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& srcinfo() const;
  PROTOBUF_NODISCARD ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* release_srcinfo();
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* mutable_srcinfo();
  void set_allocated_srcinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value);
  void unsafe_arena_set_allocated_srcinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value);
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* unsafe_arena_release_srcinfo();

  private:
  const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& _internal_srcinfo() const;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* _internal_mutable_srcinfo();

  public:
  // uint32 count = 2;
  void clear_count() ;
  ::uint32_t count() const;
  void set_count(::uint32_t value);

  private:
  ::uint32_t _internal_count() const;
  void _internal_set_count(::uint32_t value);

  public:
  // uint32 dstInventoryId = 3;
  void clear_dstinventoryid() ;
  ::uint32_t dstinventoryid() const;
  void set_dstinventoryid(::uint32_t value);

  private:
  ::uint32_t _internal_dstinventoryid() const;
  void _internal_set_dstinventoryid(::uint32_t value);

  public:
  // uint32 dstSlotId = 4;
  void clear_dstslotid() ;
  ::uint32_t dstslotid() const;
  void set_dstslotid(::uint32_t value);

  private:
  ::uint32_t _internal_dstslotid() const;
  void _internal_set_dstslotid(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:DC.Packet.SC2S_INVENTORY_SPLIT_MOVE_REQ)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SC2S_INVENTORY_SPLIT_MOVE_REQ_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SC2S_INVENTORY_SPLIT_MOVE_REQ& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* srcinfo_;
    ::uint32_t count_;
    ::uint32_t dstinventoryid_;
    ::uint32_t dstslotid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Inventory_2eproto;
};
// -------------------------------------------------------------------

class SC2S_INVENTORY_SPLIT_MERGE_REQ final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DC.Packet.SC2S_INVENTORY_SPLIT_MERGE_REQ) */ {
 public:
  inline SC2S_INVENTORY_SPLIT_MERGE_REQ() : SC2S_INVENTORY_SPLIT_MERGE_REQ(nullptr) {}
  ~SC2S_INVENTORY_SPLIT_MERGE_REQ() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SC2S_INVENTORY_SPLIT_MERGE_REQ(
      ::google::protobuf::internal::ConstantInitialized);

  inline SC2S_INVENTORY_SPLIT_MERGE_REQ(const SC2S_INVENTORY_SPLIT_MERGE_REQ& from) : SC2S_INVENTORY_SPLIT_MERGE_REQ(nullptr, from) {}
  inline SC2S_INVENTORY_SPLIT_MERGE_REQ(SC2S_INVENTORY_SPLIT_MERGE_REQ&& from) noexcept
      : SC2S_INVENTORY_SPLIT_MERGE_REQ(nullptr, std::move(from)) {}
  inline SC2S_INVENTORY_SPLIT_MERGE_REQ& operator=(const SC2S_INVENTORY_SPLIT_MERGE_REQ& from) {
    CopyFrom(from);
    return *this;
  }
  inline SC2S_INVENTORY_SPLIT_MERGE_REQ& operator=(SC2S_INVENTORY_SPLIT_MERGE_REQ&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SC2S_INVENTORY_SPLIT_MERGE_REQ& default_instance() {
    return *internal_default_instance();
  }
  static inline const SC2S_INVENTORY_SPLIT_MERGE_REQ* internal_default_instance() {
    return reinterpret_cast<const SC2S_INVENTORY_SPLIT_MERGE_REQ*>(
        &_SC2S_INVENTORY_SPLIT_MERGE_REQ_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(SC2S_INVENTORY_SPLIT_MERGE_REQ& a, SC2S_INVENTORY_SPLIT_MERGE_REQ& b) { a.Swap(&b); }
  inline void Swap(SC2S_INVENTORY_SPLIT_MERGE_REQ* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SC2S_INVENTORY_SPLIT_MERGE_REQ* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SC2S_INVENTORY_SPLIT_MERGE_REQ* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<SC2S_INVENTORY_SPLIT_MERGE_REQ>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SC2S_INVENTORY_SPLIT_MERGE_REQ& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SC2S_INVENTORY_SPLIT_MERGE_REQ& from) { SC2S_INVENTORY_SPLIT_MERGE_REQ::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SC2S_INVENTORY_SPLIT_MERGE_REQ* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DC.Packet.SC2S_INVENTORY_SPLIT_MERGE_REQ"; }

 protected:
  explicit SC2S_INVENTORY_SPLIT_MERGE_REQ(::google::protobuf::Arena* arena);
  SC2S_INVENTORY_SPLIT_MERGE_REQ(::google::protobuf::Arena* arena, const SC2S_INVENTORY_SPLIT_MERGE_REQ& from);
  SC2S_INVENTORY_SPLIT_MERGE_REQ(::google::protobuf::Arena* arena, SC2S_INVENTORY_SPLIT_MERGE_REQ&& from) noexcept
      : SC2S_INVENTORY_SPLIT_MERGE_REQ(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSrcInfoFieldNumber = 1,
    kDstInfoFieldNumber = 2,
    kCountFieldNumber = 3,
  };
  // .DC.Packet.SINVENTORY_ITEM_REQ_INFO srcInfo = 1;
  bool has_srcinfo() const;
  void clear_srcinfo() ;
  const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& srcinfo() const;
  PROTOBUF_NODISCARD ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* release_srcinfo();
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* mutable_srcinfo();
  void set_allocated_srcinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value);
  void unsafe_arena_set_allocated_srcinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value);
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* unsafe_arena_release_srcinfo();

  private:
  const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& _internal_srcinfo() const;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* _internal_mutable_srcinfo();

  public:
  // .DC.Packet.SINVENTORY_ITEM_REQ_INFO dstInfo = 2;
  bool has_dstinfo() const;
  void clear_dstinfo() ;
  const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& dstinfo() const;
  PROTOBUF_NODISCARD ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* release_dstinfo();
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* mutable_dstinfo();
  void set_allocated_dstinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value);
  void unsafe_arena_set_allocated_dstinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value);
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* unsafe_arena_release_dstinfo();

  private:
  const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& _internal_dstinfo() const;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* _internal_mutable_dstinfo();

  public:
  // uint32 count = 3;
  void clear_count() ;
  ::uint32_t count() const;
  void set_count(::uint32_t value);

  private:
  ::uint32_t _internal_count() const;
  void _internal_set_count(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:DC.Packet.SC2S_INVENTORY_SPLIT_MERGE_REQ)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SC2S_INVENTORY_SPLIT_MERGE_REQ_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SC2S_INVENTORY_SPLIT_MERGE_REQ& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* srcinfo_;
    ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* dstinfo_;
    ::uint32_t count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Inventory_2eproto;
};
// -------------------------------------------------------------------

class SC2S_INVENTORY_MOVE_REQ final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DC.Packet.SC2S_INVENTORY_MOVE_REQ) */ {
 public:
  inline SC2S_INVENTORY_MOVE_REQ() : SC2S_INVENTORY_MOVE_REQ(nullptr) {}
  ~SC2S_INVENTORY_MOVE_REQ() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SC2S_INVENTORY_MOVE_REQ(
      ::google::protobuf::internal::ConstantInitialized);

  inline SC2S_INVENTORY_MOVE_REQ(const SC2S_INVENTORY_MOVE_REQ& from) : SC2S_INVENTORY_MOVE_REQ(nullptr, from) {}
  inline SC2S_INVENTORY_MOVE_REQ(SC2S_INVENTORY_MOVE_REQ&& from) noexcept
      : SC2S_INVENTORY_MOVE_REQ(nullptr, std::move(from)) {}
  inline SC2S_INVENTORY_MOVE_REQ& operator=(const SC2S_INVENTORY_MOVE_REQ& from) {
    CopyFrom(from);
    return *this;
  }
  inline SC2S_INVENTORY_MOVE_REQ& operator=(SC2S_INVENTORY_MOVE_REQ&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SC2S_INVENTORY_MOVE_REQ& default_instance() {
    return *internal_default_instance();
  }
  static inline const SC2S_INVENTORY_MOVE_REQ* internal_default_instance() {
    return reinterpret_cast<const SC2S_INVENTORY_MOVE_REQ*>(
        &_SC2S_INVENTORY_MOVE_REQ_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(SC2S_INVENTORY_MOVE_REQ& a, SC2S_INVENTORY_MOVE_REQ& b) { a.Swap(&b); }
  inline void Swap(SC2S_INVENTORY_MOVE_REQ* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SC2S_INVENTORY_MOVE_REQ* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SC2S_INVENTORY_MOVE_REQ* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<SC2S_INVENTORY_MOVE_REQ>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SC2S_INVENTORY_MOVE_REQ& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SC2S_INVENTORY_MOVE_REQ& from) { SC2S_INVENTORY_MOVE_REQ::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SC2S_INVENTORY_MOVE_REQ* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DC.Packet.SC2S_INVENTORY_MOVE_REQ"; }

 protected:
  explicit SC2S_INVENTORY_MOVE_REQ(::google::protobuf::Arena* arena);
  SC2S_INVENTORY_MOVE_REQ(::google::protobuf::Arena* arena, const SC2S_INVENTORY_MOVE_REQ& from);
  SC2S_INVENTORY_MOVE_REQ(::google::protobuf::Arena* arena, SC2S_INVENTORY_MOVE_REQ&& from) noexcept
      : SC2S_INVENTORY_MOVE_REQ(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSrcInfoFieldNumber = 1,
    kDstInventoryIdFieldNumber = 2,
    kDstSlotIdFieldNumber = 3,
  };
  // .DC.Packet.SINVENTORY_ITEM_REQ_INFO srcInfo = 1;
  bool has_srcinfo() const;
  void clear_srcinfo() ;
  const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& srcinfo() const;
  PROTOBUF_NODISCARD ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* release_srcinfo();
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* mutable_srcinfo();
  void set_allocated_srcinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value);
  void unsafe_arena_set_allocated_srcinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value);
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* unsafe_arena_release_srcinfo();

  private:
  const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& _internal_srcinfo() const;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* _internal_mutable_srcinfo();

  public:
  // uint32 dstInventoryId = 2;
  void clear_dstinventoryid() ;
  ::uint32_t dstinventoryid() const;
  void set_dstinventoryid(::uint32_t value);

  private:
  ::uint32_t _internal_dstinventoryid() const;
  void _internal_set_dstinventoryid(::uint32_t value);

  public:
  // uint32 dstSlotId = 3;
  void clear_dstslotid() ;
  ::uint32_t dstslotid() const;
  void set_dstslotid(::uint32_t value);

  private:
  ::uint32_t _internal_dstslotid() const;
  void _internal_set_dstslotid(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:DC.Packet.SC2S_INVENTORY_MOVE_REQ)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SC2S_INVENTORY_MOVE_REQ_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SC2S_INVENTORY_MOVE_REQ& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* srcinfo_;
    ::uint32_t dstinventoryid_;
    ::uint32_t dstslotid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Inventory_2eproto;
};
// -------------------------------------------------------------------

class SC2S_INVENTORY_MERGE_REQ final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DC.Packet.SC2S_INVENTORY_MERGE_REQ) */ {
 public:
  inline SC2S_INVENTORY_MERGE_REQ() : SC2S_INVENTORY_MERGE_REQ(nullptr) {}
  ~SC2S_INVENTORY_MERGE_REQ() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SC2S_INVENTORY_MERGE_REQ(
      ::google::protobuf::internal::ConstantInitialized);

  inline SC2S_INVENTORY_MERGE_REQ(const SC2S_INVENTORY_MERGE_REQ& from) : SC2S_INVENTORY_MERGE_REQ(nullptr, from) {}
  inline SC2S_INVENTORY_MERGE_REQ(SC2S_INVENTORY_MERGE_REQ&& from) noexcept
      : SC2S_INVENTORY_MERGE_REQ(nullptr, std::move(from)) {}
  inline SC2S_INVENTORY_MERGE_REQ& operator=(const SC2S_INVENTORY_MERGE_REQ& from) {
    CopyFrom(from);
    return *this;
  }
  inline SC2S_INVENTORY_MERGE_REQ& operator=(SC2S_INVENTORY_MERGE_REQ&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SC2S_INVENTORY_MERGE_REQ& default_instance() {
    return *internal_default_instance();
  }
  static inline const SC2S_INVENTORY_MERGE_REQ* internal_default_instance() {
    return reinterpret_cast<const SC2S_INVENTORY_MERGE_REQ*>(
        &_SC2S_INVENTORY_MERGE_REQ_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(SC2S_INVENTORY_MERGE_REQ& a, SC2S_INVENTORY_MERGE_REQ& b) { a.Swap(&b); }
  inline void Swap(SC2S_INVENTORY_MERGE_REQ* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SC2S_INVENTORY_MERGE_REQ* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SC2S_INVENTORY_MERGE_REQ* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<SC2S_INVENTORY_MERGE_REQ>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SC2S_INVENTORY_MERGE_REQ& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SC2S_INVENTORY_MERGE_REQ& from) { SC2S_INVENTORY_MERGE_REQ::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SC2S_INVENTORY_MERGE_REQ* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DC.Packet.SC2S_INVENTORY_MERGE_REQ"; }

 protected:
  explicit SC2S_INVENTORY_MERGE_REQ(::google::protobuf::Arena* arena);
  SC2S_INVENTORY_MERGE_REQ(::google::protobuf::Arena* arena, const SC2S_INVENTORY_MERGE_REQ& from);
  SC2S_INVENTORY_MERGE_REQ(::google::protobuf::Arena* arena, SC2S_INVENTORY_MERGE_REQ&& from) noexcept
      : SC2S_INVENTORY_MERGE_REQ(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSrcInfoFieldNumber = 1,
    kDstInfoFieldNumber = 2,
  };
  // .DC.Packet.SINVENTORY_ITEM_REQ_INFO srcInfo = 1;
  bool has_srcinfo() const;
  void clear_srcinfo() ;
  const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& srcinfo() const;
  PROTOBUF_NODISCARD ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* release_srcinfo();
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* mutable_srcinfo();
  void set_allocated_srcinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value);
  void unsafe_arena_set_allocated_srcinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value);
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* unsafe_arena_release_srcinfo();

  private:
  const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& _internal_srcinfo() const;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* _internal_mutable_srcinfo();

  public:
  // .DC.Packet.SINVENTORY_ITEM_REQ_INFO dstInfo = 2;
  bool has_dstinfo() const;
  void clear_dstinfo() ;
  const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& dstinfo() const;
  PROTOBUF_NODISCARD ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* release_dstinfo();
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* mutable_dstinfo();
  void set_allocated_dstinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value);
  void unsafe_arena_set_allocated_dstinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value);
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* unsafe_arena_release_dstinfo();

  private:
  const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& _internal_dstinfo() const;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* _internal_mutable_dstinfo();

  public:
  // @@protoc_insertion_point(class_scope:DC.Packet.SC2S_INVENTORY_MERGE_REQ)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SC2S_INVENTORY_MERGE_REQ_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SC2S_INVENTORY_MERGE_REQ& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* srcinfo_;
    ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* dstinfo_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Inventory_2eproto;
};
// -------------------------------------------------------------------

class INVENTORY_SWAP_DST_INFO final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DC.Packet.INVENTORY_SWAP_DST_INFO) */ {
 public:
  inline INVENTORY_SWAP_DST_INFO() : INVENTORY_SWAP_DST_INFO(nullptr) {}
  ~INVENTORY_SWAP_DST_INFO() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR INVENTORY_SWAP_DST_INFO(
      ::google::protobuf::internal::ConstantInitialized);

  inline INVENTORY_SWAP_DST_INFO(const INVENTORY_SWAP_DST_INFO& from) : INVENTORY_SWAP_DST_INFO(nullptr, from) {}
  inline INVENTORY_SWAP_DST_INFO(INVENTORY_SWAP_DST_INFO&& from) noexcept
      : INVENTORY_SWAP_DST_INFO(nullptr, std::move(from)) {}
  inline INVENTORY_SWAP_DST_INFO& operator=(const INVENTORY_SWAP_DST_INFO& from) {
    CopyFrom(from);
    return *this;
  }
  inline INVENTORY_SWAP_DST_INFO& operator=(INVENTORY_SWAP_DST_INFO&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const INVENTORY_SWAP_DST_INFO& default_instance() {
    return *internal_default_instance();
  }
  static inline const INVENTORY_SWAP_DST_INFO* internal_default_instance() {
    return reinterpret_cast<const INVENTORY_SWAP_DST_INFO*>(
        &_INVENTORY_SWAP_DST_INFO_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(INVENTORY_SWAP_DST_INFO& a, INVENTORY_SWAP_DST_INFO& b) { a.Swap(&b); }
  inline void Swap(INVENTORY_SWAP_DST_INFO* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(INVENTORY_SWAP_DST_INFO* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  INVENTORY_SWAP_DST_INFO* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<INVENTORY_SWAP_DST_INFO>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const INVENTORY_SWAP_DST_INFO& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const INVENTORY_SWAP_DST_INFO& from) { INVENTORY_SWAP_DST_INFO::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(INVENTORY_SWAP_DST_INFO* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DC.Packet.INVENTORY_SWAP_DST_INFO"; }

 protected:
  explicit INVENTORY_SWAP_DST_INFO(::google::protobuf::Arena* arena);
  INVENTORY_SWAP_DST_INFO(::google::protobuf::Arena* arena, const INVENTORY_SWAP_DST_INFO& from);
  INVENTORY_SWAP_DST_INFO(::google::protobuf::Arena* arena, INVENTORY_SWAP_DST_INFO&& from) noexcept
      : INVENTORY_SWAP_DST_INFO(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDstInfoFieldNumber = 1,
    kNewSlotIdFieldNumber = 2,
    kNewInventoryIdFieldNumber = 3,
  };
  // .DC.Packet.SINVENTORY_ITEM_REQ_INFO dstInfo = 1;
  bool has_dstinfo() const;
  void clear_dstinfo() ;
  const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& dstinfo() const;
  PROTOBUF_NODISCARD ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* release_dstinfo();
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* mutable_dstinfo();
  void set_allocated_dstinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value);
  void unsafe_arena_set_allocated_dstinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value);
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* unsafe_arena_release_dstinfo();

  private:
  const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& _internal_dstinfo() const;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* _internal_mutable_dstinfo();

  public:
  // uint32 newSlotId = 2;
  void clear_newslotid() ;
  ::uint32_t newslotid() const;
  void set_newslotid(::uint32_t value);

  private:
  ::uint32_t _internal_newslotid() const;
  void _internal_set_newslotid(::uint32_t value);

  public:
  // uint32 newInventoryId = 3;
  void clear_newinventoryid() ;
  ::uint32_t newinventoryid() const;
  void set_newinventoryid(::uint32_t value);

  private:
  ::uint32_t _internal_newinventoryid() const;
  void _internal_set_newinventoryid(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:DC.Packet.INVENTORY_SWAP_DST_INFO)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_INVENTORY_SWAP_DST_INFO_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const INVENTORY_SWAP_DST_INFO& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* dstinfo_;
    ::uint32_t newslotid_;
    ::uint32_t newinventoryid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Inventory_2eproto;
};
// -------------------------------------------------------------------

class SS2C_STORAGE_INFO_RES final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DC.Packet.SS2C_STORAGE_INFO_RES) */ {
 public:
  inline SS2C_STORAGE_INFO_RES() : SS2C_STORAGE_INFO_RES(nullptr) {}
  ~SS2C_STORAGE_INFO_RES() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SS2C_STORAGE_INFO_RES(
      ::google::protobuf::internal::ConstantInitialized);

  inline SS2C_STORAGE_INFO_RES(const SS2C_STORAGE_INFO_RES& from) : SS2C_STORAGE_INFO_RES(nullptr, from) {}
  inline SS2C_STORAGE_INFO_RES(SS2C_STORAGE_INFO_RES&& from) noexcept
      : SS2C_STORAGE_INFO_RES(nullptr, std::move(from)) {}
  inline SS2C_STORAGE_INFO_RES& operator=(const SS2C_STORAGE_INFO_RES& from) {
    CopyFrom(from);
    return *this;
  }
  inline SS2C_STORAGE_INFO_RES& operator=(SS2C_STORAGE_INFO_RES&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SS2C_STORAGE_INFO_RES& default_instance() {
    return *internal_default_instance();
  }
  static inline const SS2C_STORAGE_INFO_RES* internal_default_instance() {
    return reinterpret_cast<const SS2C_STORAGE_INFO_RES*>(
        &_SS2C_STORAGE_INFO_RES_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(SS2C_STORAGE_INFO_RES& a, SS2C_STORAGE_INFO_RES& b) { a.Swap(&b); }
  inline void Swap(SS2C_STORAGE_INFO_RES* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SS2C_STORAGE_INFO_RES* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SS2C_STORAGE_INFO_RES* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<SS2C_STORAGE_INFO_RES>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SS2C_STORAGE_INFO_RES& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SS2C_STORAGE_INFO_RES& from) { SS2C_STORAGE_INFO_RES::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SS2C_STORAGE_INFO_RES* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DC.Packet.SS2C_STORAGE_INFO_RES"; }

 protected:
  explicit SS2C_STORAGE_INFO_RES(::google::protobuf::Arena* arena);
  SS2C_STORAGE_INFO_RES(::google::protobuf::Arena* arena, const SS2C_STORAGE_INFO_RES& from);
  SS2C_STORAGE_INFO_RES(::google::protobuf::Arena* arena, SS2C_STORAGE_INFO_RES&& from) noexcept
      : SS2C_STORAGE_INFO_RES(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using RESULT_STORAGE_INFO = SS2C_STORAGE_INFO_RES_RESULT_STORAGE_INFO;
  static constexpr RESULT_STORAGE_INFO NONE = SS2C_STORAGE_INFO_RES_RESULT_STORAGE_INFO_NONE;
  static constexpr RESULT_STORAGE_INFO OK_SEND_DATA = SS2C_STORAGE_INFO_RES_RESULT_STORAGE_INFO_OK_SEND_DATA;
  static constexpr RESULT_STORAGE_INFO OK_NOT_CHANGE = SS2C_STORAGE_INFO_RES_RESULT_STORAGE_INFO_OK_NOT_CHANGE;
  static constexpr RESULT_STORAGE_INFO FAIL = SS2C_STORAGE_INFO_RES_RESULT_STORAGE_INFO_FAIL;
  static inline bool RESULT_STORAGE_INFO_IsValid(int value) {
    return SS2C_STORAGE_INFO_RES_RESULT_STORAGE_INFO_IsValid(value);
  }
  static constexpr RESULT_STORAGE_INFO RESULT_STORAGE_INFO_MIN = SS2C_STORAGE_INFO_RES_RESULT_STORAGE_INFO_RESULT_STORAGE_INFO_MIN;
  static constexpr RESULT_STORAGE_INFO RESULT_STORAGE_INFO_MAX = SS2C_STORAGE_INFO_RES_RESULT_STORAGE_INFO_RESULT_STORAGE_INFO_MAX;
  static constexpr int RESULT_STORAGE_INFO_ARRAYSIZE = SS2C_STORAGE_INFO_RES_RESULT_STORAGE_INFO_RESULT_STORAGE_INFO_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* RESULT_STORAGE_INFO_descriptor() {
    return SS2C_STORAGE_INFO_RES_RESULT_STORAGE_INFO_descriptor();
  }
  template <typename T>
  static inline const std::string& RESULT_STORAGE_INFO_Name(T value) {
    return SS2C_STORAGE_INFO_RES_RESULT_STORAGE_INFO_Name(value);
  }
  static inline bool RESULT_STORAGE_INFO_Parse(absl::string_view name, RESULT_STORAGE_INFO* value) {
    return SS2C_STORAGE_INFO_RES_RESULT_STORAGE_INFO_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kStorageItemsFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // repeated .DC.Packet.SItem storageItems = 2;
  int storageitems_size() const;
  private:
  int _internal_storageitems_size() const;

  public:
  void clear_storageitems() ;
  ::DC::Packet::SItem* mutable_storageitems(int index);
  ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>* mutable_storageitems();

  private:
  const ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>& _internal_storageitems() const;
  ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>* _internal_mutable_storageitems();
  public:
  const ::DC::Packet::SItem& storageitems(int index) const;
  ::DC::Packet::SItem* add_storageitems();
  const ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>& storageitems() const;
  // uint32 result = 1;
  void clear_result() ;
  ::uint32_t result() const;
  void set_result(::uint32_t value);

  private:
  ::uint32_t _internal_result() const;
  void _internal_set_result(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:DC.Packet.SS2C_STORAGE_INFO_RES)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SS2C_STORAGE_INFO_RES_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SS2C_STORAGE_INFO_RES& from_msg);
    ::google::protobuf::RepeatedPtrField< ::DC::Packet::SItem > storageitems_;
    ::uint32_t result_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Inventory_2eproto;
};
// -------------------------------------------------------------------

class SS2C_INVENTORY_SINGLE_UPDATE_RES final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DC.Packet.SS2C_INVENTORY_SINGLE_UPDATE_RES) */ {
 public:
  inline SS2C_INVENTORY_SINGLE_UPDATE_RES() : SS2C_INVENTORY_SINGLE_UPDATE_RES(nullptr) {}
  ~SS2C_INVENTORY_SINGLE_UPDATE_RES() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SS2C_INVENTORY_SINGLE_UPDATE_RES(
      ::google::protobuf::internal::ConstantInitialized);

  inline SS2C_INVENTORY_SINGLE_UPDATE_RES(const SS2C_INVENTORY_SINGLE_UPDATE_RES& from) : SS2C_INVENTORY_SINGLE_UPDATE_RES(nullptr, from) {}
  inline SS2C_INVENTORY_SINGLE_UPDATE_RES(SS2C_INVENTORY_SINGLE_UPDATE_RES&& from) noexcept
      : SS2C_INVENTORY_SINGLE_UPDATE_RES(nullptr, std::move(from)) {}
  inline SS2C_INVENTORY_SINGLE_UPDATE_RES& operator=(const SS2C_INVENTORY_SINGLE_UPDATE_RES& from) {
    CopyFrom(from);
    return *this;
  }
  inline SS2C_INVENTORY_SINGLE_UPDATE_RES& operator=(SS2C_INVENTORY_SINGLE_UPDATE_RES&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SS2C_INVENTORY_SINGLE_UPDATE_RES& default_instance() {
    return *internal_default_instance();
  }
  static inline const SS2C_INVENTORY_SINGLE_UPDATE_RES* internal_default_instance() {
    return reinterpret_cast<const SS2C_INVENTORY_SINGLE_UPDATE_RES*>(
        &_SS2C_INVENTORY_SINGLE_UPDATE_RES_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(SS2C_INVENTORY_SINGLE_UPDATE_RES& a, SS2C_INVENTORY_SINGLE_UPDATE_RES& b) { a.Swap(&b); }
  inline void Swap(SS2C_INVENTORY_SINGLE_UPDATE_RES* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SS2C_INVENTORY_SINGLE_UPDATE_RES* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SS2C_INVENTORY_SINGLE_UPDATE_RES* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<SS2C_INVENTORY_SINGLE_UPDATE_RES>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SS2C_INVENTORY_SINGLE_UPDATE_RES& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SS2C_INVENTORY_SINGLE_UPDATE_RES& from) { SS2C_INVENTORY_SINGLE_UPDATE_RES::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SS2C_INVENTORY_SINGLE_UPDATE_RES* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DC.Packet.SS2C_INVENTORY_SINGLE_UPDATE_RES"; }

 protected:
  explicit SS2C_INVENTORY_SINGLE_UPDATE_RES(::google::protobuf::Arena* arena);
  SS2C_INVENTORY_SINGLE_UPDATE_RES(::google::protobuf::Arena* arena, const SS2C_INVENTORY_SINGLE_UPDATE_RES& from);
  SS2C_INVENTORY_SINGLE_UPDATE_RES(::google::protobuf::Arena* arena, SS2C_INVENTORY_SINGLE_UPDATE_RES&& from) noexcept
      : SS2C_INVENTORY_SINGLE_UPDATE_RES(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using RESULT_INVENTORY_SINGLE_UPDATE = SS2C_INVENTORY_SINGLE_UPDATE_RES_RESULT_INVENTORY_SINGLE_UPDATE;
  static constexpr RESULT_INVENTORY_SINGLE_UPDATE NONE = SS2C_INVENTORY_SINGLE_UPDATE_RES_RESULT_INVENTORY_SINGLE_UPDATE_NONE;
  static constexpr RESULT_INVENTORY_SINGLE_UPDATE OK = SS2C_INVENTORY_SINGLE_UPDATE_RES_RESULT_INVENTORY_SINGLE_UPDATE_OK;
  static constexpr RESULT_INVENTORY_SINGLE_UPDATE FAIL = SS2C_INVENTORY_SINGLE_UPDATE_RES_RESULT_INVENTORY_SINGLE_UPDATE_FAIL;
  static constexpr RESULT_INVENTORY_SINGLE_UPDATE FAIL_VALID_CHECK_OLD_ITEM = SS2C_INVENTORY_SINGLE_UPDATE_RES_RESULT_INVENTORY_SINGLE_UPDATE_FAIL_VALID_CHECK_OLD_ITEM;
  static constexpr RESULT_INVENTORY_SINGLE_UPDATE FAIL_VALID_CHECK_NEW_ITEM = SS2C_INVENTORY_SINGLE_UPDATE_RES_RESULT_INVENTORY_SINGLE_UPDATE_FAIL_VALID_CHECK_NEW_ITEM;
  static constexpr RESULT_INVENTORY_SINGLE_UPDATE FAIL_CHECK_LOGIC_LOG = SS2C_INVENTORY_SINGLE_UPDATE_RES_RESULT_INVENTORY_SINGLE_UPDATE_FAIL_CHECK_LOGIC_LOG;
  static inline bool RESULT_INVENTORY_SINGLE_UPDATE_IsValid(int value) {
    return SS2C_INVENTORY_SINGLE_UPDATE_RES_RESULT_INVENTORY_SINGLE_UPDATE_IsValid(value);
  }
  static constexpr RESULT_INVENTORY_SINGLE_UPDATE RESULT_INVENTORY_SINGLE_UPDATE_MIN = SS2C_INVENTORY_SINGLE_UPDATE_RES_RESULT_INVENTORY_SINGLE_UPDATE_RESULT_INVENTORY_SINGLE_UPDATE_MIN;
  static constexpr RESULT_INVENTORY_SINGLE_UPDATE RESULT_INVENTORY_SINGLE_UPDATE_MAX = SS2C_INVENTORY_SINGLE_UPDATE_RES_RESULT_INVENTORY_SINGLE_UPDATE_RESULT_INVENTORY_SINGLE_UPDATE_MAX;
  static constexpr int RESULT_INVENTORY_SINGLE_UPDATE_ARRAYSIZE = SS2C_INVENTORY_SINGLE_UPDATE_RES_RESULT_INVENTORY_SINGLE_UPDATE_RESULT_INVENTORY_SINGLE_UPDATE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* RESULT_INVENTORY_SINGLE_UPDATE_descriptor() {
    return SS2C_INVENTORY_SINGLE_UPDATE_RES_RESULT_INVENTORY_SINGLE_UPDATE_descriptor();
  }
  template <typename T>
  static inline const std::string& RESULT_INVENTORY_SINGLE_UPDATE_Name(T value) {
    return SS2C_INVENTORY_SINGLE_UPDATE_RES_RESULT_INVENTORY_SINGLE_UPDATE_Name(value);
  }
  static inline bool RESULT_INVENTORY_SINGLE_UPDATE_Parse(absl::string_view name, RESULT_INVENTORY_SINGLE_UPDATE* value) {
    return SS2C_INVENTORY_SINGLE_UPDATE_RES_RESULT_INVENTORY_SINGLE_UPDATE_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kOldItemFieldNumber = 2,
    kNewItemFieldNumber = 3,
    kResultFieldNumber = 1,
  };
  // repeated .DC.Packet.SItem oldItem = 2;
  int olditem_size() const;
  private:
  int _internal_olditem_size() const;

  public:
  void clear_olditem() ;
  ::DC::Packet::SItem* mutable_olditem(int index);
  ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>* mutable_olditem();

  private:
  const ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>& _internal_olditem() const;
  ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>* _internal_mutable_olditem();
  public:
  const ::DC::Packet::SItem& olditem(int index) const;
  ::DC::Packet::SItem* add_olditem();
  const ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>& olditem() const;
  // repeated .DC.Packet.SItem newItem = 3;
  int newitem_size() const;
  private:
  int _internal_newitem_size() const;

  public:
  void clear_newitem() ;
  ::DC::Packet::SItem* mutable_newitem(int index);
  ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>* mutable_newitem();

  private:
  const ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>& _internal_newitem() const;
  ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>* _internal_mutable_newitem();
  public:
  const ::DC::Packet::SItem& newitem(int index) const;
  ::DC::Packet::SItem* add_newitem();
  const ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>& newitem() const;
  // uint32 result = 1;
  void clear_result() ;
  ::uint32_t result() const;
  void set_result(::uint32_t value);

  private:
  ::uint32_t _internal_result() const;
  void _internal_set_result(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:DC.Packet.SS2C_INVENTORY_SINGLE_UPDATE_RES)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SS2C_INVENTORY_SINGLE_UPDATE_RES_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SS2C_INVENTORY_SINGLE_UPDATE_RES& from_msg);
    ::google::protobuf::RepeatedPtrField< ::DC::Packet::SItem > olditem_;
    ::google::protobuf::RepeatedPtrField< ::DC::Packet::SItem > newitem_;
    ::uint32_t result_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Inventory_2eproto;
};
// -------------------------------------------------------------------

class SS2C_INVENTORY_INFO_RES final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DC.Packet.SS2C_INVENTORY_INFO_RES) */ {
 public:
  inline SS2C_INVENTORY_INFO_RES() : SS2C_INVENTORY_INFO_RES(nullptr) {}
  ~SS2C_INVENTORY_INFO_RES() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SS2C_INVENTORY_INFO_RES(
      ::google::protobuf::internal::ConstantInitialized);

  inline SS2C_INVENTORY_INFO_RES(const SS2C_INVENTORY_INFO_RES& from) : SS2C_INVENTORY_INFO_RES(nullptr, from) {}
  inline SS2C_INVENTORY_INFO_RES(SS2C_INVENTORY_INFO_RES&& from) noexcept
      : SS2C_INVENTORY_INFO_RES(nullptr, std::move(from)) {}
  inline SS2C_INVENTORY_INFO_RES& operator=(const SS2C_INVENTORY_INFO_RES& from) {
    CopyFrom(from);
    return *this;
  }
  inline SS2C_INVENTORY_INFO_RES& operator=(SS2C_INVENTORY_INFO_RES&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SS2C_INVENTORY_INFO_RES& default_instance() {
    return *internal_default_instance();
  }
  static inline const SS2C_INVENTORY_INFO_RES* internal_default_instance() {
    return reinterpret_cast<const SS2C_INVENTORY_INFO_RES*>(
        &_SS2C_INVENTORY_INFO_RES_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(SS2C_INVENTORY_INFO_RES& a, SS2C_INVENTORY_INFO_RES& b) { a.Swap(&b); }
  inline void Swap(SS2C_INVENTORY_INFO_RES* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SS2C_INVENTORY_INFO_RES* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SS2C_INVENTORY_INFO_RES* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<SS2C_INVENTORY_INFO_RES>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SS2C_INVENTORY_INFO_RES& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SS2C_INVENTORY_INFO_RES& from) { SS2C_INVENTORY_INFO_RES::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SS2C_INVENTORY_INFO_RES* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DC.Packet.SS2C_INVENTORY_INFO_RES"; }

 protected:
  explicit SS2C_INVENTORY_INFO_RES(::google::protobuf::Arena* arena);
  SS2C_INVENTORY_INFO_RES(::google::protobuf::Arena* arena, const SS2C_INVENTORY_INFO_RES& from);
  SS2C_INVENTORY_INFO_RES(::google::protobuf::Arena* arena, SS2C_INVENTORY_INFO_RES&& from) noexcept
      : SS2C_INVENTORY_INFO_RES(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using RESULT_INVENTORY_INFO_INFO = SS2C_INVENTORY_INFO_RES_RESULT_INVENTORY_INFO_INFO;
  static constexpr RESULT_INVENTORY_INFO_INFO NONE = SS2C_INVENTORY_INFO_RES_RESULT_INVENTORY_INFO_INFO_NONE;
  static constexpr RESULT_INVENTORY_INFO_INFO OK_SEND_DATA = SS2C_INVENTORY_INFO_RES_RESULT_INVENTORY_INFO_INFO_OK_SEND_DATA;
  static constexpr RESULT_INVENTORY_INFO_INFO OK_NOT_CHANGE = SS2C_INVENTORY_INFO_RES_RESULT_INVENTORY_INFO_INFO_OK_NOT_CHANGE;
  static constexpr RESULT_INVENTORY_INFO_INFO FAIL = SS2C_INVENTORY_INFO_RES_RESULT_INVENTORY_INFO_INFO_FAIL;
  static inline bool RESULT_INVENTORY_INFO_INFO_IsValid(int value) {
    return SS2C_INVENTORY_INFO_RES_RESULT_INVENTORY_INFO_INFO_IsValid(value);
  }
  static constexpr RESULT_INVENTORY_INFO_INFO RESULT_INVENTORY_INFO_INFO_MIN = SS2C_INVENTORY_INFO_RES_RESULT_INVENTORY_INFO_INFO_RESULT_INVENTORY_INFO_INFO_MIN;
  static constexpr RESULT_INVENTORY_INFO_INFO RESULT_INVENTORY_INFO_INFO_MAX = SS2C_INVENTORY_INFO_RES_RESULT_INVENTORY_INFO_INFO_RESULT_INVENTORY_INFO_INFO_MAX;
  static constexpr int RESULT_INVENTORY_INFO_INFO_ARRAYSIZE = SS2C_INVENTORY_INFO_RES_RESULT_INVENTORY_INFO_INFO_RESULT_INVENTORY_INFO_INFO_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* RESULT_INVENTORY_INFO_INFO_descriptor() {
    return SS2C_INVENTORY_INFO_RES_RESULT_INVENTORY_INFO_INFO_descriptor();
  }
  template <typename T>
  static inline const std::string& RESULT_INVENTORY_INFO_INFO_Name(T value) {
    return SS2C_INVENTORY_INFO_RES_RESULT_INVENTORY_INFO_INFO_Name(value);
  }
  static inline bool RESULT_INVENTORY_INFO_INFO_Parse(absl::string_view name, RESULT_INVENTORY_INFO_INFO* value) {
    return SS2C_INVENTORY_INFO_RES_RESULT_INVENTORY_INFO_INFO_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kInventoryItemsFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // repeated .DC.Packet.SItem inventoryItems = 2;
  int inventoryitems_size() const;
  private:
  int _internal_inventoryitems_size() const;

  public:
  void clear_inventoryitems() ;
  ::DC::Packet::SItem* mutable_inventoryitems(int index);
  ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>* mutable_inventoryitems();

  private:
  const ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>& _internal_inventoryitems() const;
  ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>* _internal_mutable_inventoryitems();
  public:
  const ::DC::Packet::SItem& inventoryitems(int index) const;
  ::DC::Packet::SItem* add_inventoryitems();
  const ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>& inventoryitems() const;
  // uint32 result = 1;
  void clear_result() ;
  ::uint32_t result() const;
  void set_result(::uint32_t value);

  private:
  ::uint32_t _internal_result() const;
  void _internal_set_result(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:DC.Packet.SS2C_INVENTORY_INFO_RES)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SS2C_INVENTORY_INFO_RES_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SS2C_INVENTORY_INFO_RES& from_msg);
    ::google::protobuf::RepeatedPtrField< ::DC::Packet::SItem > inventoryitems_;
    ::uint32_t result_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Inventory_2eproto;
};
// -------------------------------------------------------------------

class SS2C_INVENTORY_ALL_UPDATE_RES final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DC.Packet.SS2C_INVENTORY_ALL_UPDATE_RES) */ {
 public:
  inline SS2C_INVENTORY_ALL_UPDATE_RES() : SS2C_INVENTORY_ALL_UPDATE_RES(nullptr) {}
  ~SS2C_INVENTORY_ALL_UPDATE_RES() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SS2C_INVENTORY_ALL_UPDATE_RES(
      ::google::protobuf::internal::ConstantInitialized);

  inline SS2C_INVENTORY_ALL_UPDATE_RES(const SS2C_INVENTORY_ALL_UPDATE_RES& from) : SS2C_INVENTORY_ALL_UPDATE_RES(nullptr, from) {}
  inline SS2C_INVENTORY_ALL_UPDATE_RES(SS2C_INVENTORY_ALL_UPDATE_RES&& from) noexcept
      : SS2C_INVENTORY_ALL_UPDATE_RES(nullptr, std::move(from)) {}
  inline SS2C_INVENTORY_ALL_UPDATE_RES& operator=(const SS2C_INVENTORY_ALL_UPDATE_RES& from) {
    CopyFrom(from);
    return *this;
  }
  inline SS2C_INVENTORY_ALL_UPDATE_RES& operator=(SS2C_INVENTORY_ALL_UPDATE_RES&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SS2C_INVENTORY_ALL_UPDATE_RES& default_instance() {
    return *internal_default_instance();
  }
  static inline const SS2C_INVENTORY_ALL_UPDATE_RES* internal_default_instance() {
    return reinterpret_cast<const SS2C_INVENTORY_ALL_UPDATE_RES*>(
        &_SS2C_INVENTORY_ALL_UPDATE_RES_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(SS2C_INVENTORY_ALL_UPDATE_RES& a, SS2C_INVENTORY_ALL_UPDATE_RES& b) { a.Swap(&b); }
  inline void Swap(SS2C_INVENTORY_ALL_UPDATE_RES* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SS2C_INVENTORY_ALL_UPDATE_RES* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SS2C_INVENTORY_ALL_UPDATE_RES* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<SS2C_INVENTORY_ALL_UPDATE_RES>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SS2C_INVENTORY_ALL_UPDATE_RES& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SS2C_INVENTORY_ALL_UPDATE_RES& from) { SS2C_INVENTORY_ALL_UPDATE_RES::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SS2C_INVENTORY_ALL_UPDATE_RES* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DC.Packet.SS2C_INVENTORY_ALL_UPDATE_RES"; }

 protected:
  explicit SS2C_INVENTORY_ALL_UPDATE_RES(::google::protobuf::Arena* arena);
  SS2C_INVENTORY_ALL_UPDATE_RES(::google::protobuf::Arena* arena, const SS2C_INVENTORY_ALL_UPDATE_RES& from);
  SS2C_INVENTORY_ALL_UPDATE_RES(::google::protobuf::Arena* arena, SS2C_INVENTORY_ALL_UPDATE_RES&& from) noexcept
      : SS2C_INVENTORY_ALL_UPDATE_RES(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using RESULT_INVENTORY_UPDATE = SS2C_INVENTORY_ALL_UPDATE_RES_RESULT_INVENTORY_UPDATE;
  static constexpr RESULT_INVENTORY_UPDATE NONE = SS2C_INVENTORY_ALL_UPDATE_RES_RESULT_INVENTORY_UPDATE_NONE;
  static constexpr RESULT_INVENTORY_UPDATE OK = SS2C_INVENTORY_ALL_UPDATE_RES_RESULT_INVENTORY_UPDATE_OK;
  static constexpr RESULT_INVENTORY_UPDATE FAIL = SS2C_INVENTORY_ALL_UPDATE_RES_RESULT_INVENTORY_UPDATE_FAIL;
  static inline bool RESULT_INVENTORY_UPDATE_IsValid(int value) {
    return SS2C_INVENTORY_ALL_UPDATE_RES_RESULT_INVENTORY_UPDATE_IsValid(value);
  }
  static constexpr RESULT_INVENTORY_UPDATE RESULT_INVENTORY_UPDATE_MIN = SS2C_INVENTORY_ALL_UPDATE_RES_RESULT_INVENTORY_UPDATE_RESULT_INVENTORY_UPDATE_MIN;
  static constexpr RESULT_INVENTORY_UPDATE RESULT_INVENTORY_UPDATE_MAX = SS2C_INVENTORY_ALL_UPDATE_RES_RESULT_INVENTORY_UPDATE_RESULT_INVENTORY_UPDATE_MAX;
  static constexpr int RESULT_INVENTORY_UPDATE_ARRAYSIZE = SS2C_INVENTORY_ALL_UPDATE_RES_RESULT_INVENTORY_UPDATE_RESULT_INVENTORY_UPDATE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* RESULT_INVENTORY_UPDATE_descriptor() {
    return SS2C_INVENTORY_ALL_UPDATE_RES_RESULT_INVENTORY_UPDATE_descriptor();
  }
  template <typename T>
  static inline const std::string& RESULT_INVENTORY_UPDATE_Name(T value) {
    return SS2C_INVENTORY_ALL_UPDATE_RES_RESULT_INVENTORY_UPDATE_Name(value);
  }
  static inline bool RESULT_INVENTORY_UPDATE_Parse(absl::string_view name, RESULT_INVENTORY_UPDATE* value) {
    return SS2C_INVENTORY_ALL_UPDATE_RES_RESULT_INVENTORY_UPDATE_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kInventoryItemsFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // repeated .DC.Packet.SItem inventoryItems = 2;
  int inventoryitems_size() const;
  private:
  int _internal_inventoryitems_size() const;

  public:
  void clear_inventoryitems() ;
  ::DC::Packet::SItem* mutable_inventoryitems(int index);
  ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>* mutable_inventoryitems();

  private:
  const ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>& _internal_inventoryitems() const;
  ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>* _internal_mutable_inventoryitems();
  public:
  const ::DC::Packet::SItem& inventoryitems(int index) const;
  ::DC::Packet::SItem* add_inventoryitems();
  const ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>& inventoryitems() const;
  // uint32 result = 1;
  void clear_result() ;
  ::uint32_t result() const;
  void set_result(::uint32_t value);

  private:
  ::uint32_t _internal_result() const;
  void _internal_set_result(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:DC.Packet.SS2C_INVENTORY_ALL_UPDATE_RES)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SS2C_INVENTORY_ALL_UPDATE_RES_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SS2C_INVENTORY_ALL_UPDATE_RES& from_msg);
    ::google::protobuf::RepeatedPtrField< ::DC::Packet::SItem > inventoryitems_;
    ::uint32_t result_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Inventory_2eproto;
};
// -------------------------------------------------------------------

class SC2S_INVENTORY_SWAP_REQ final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DC.Packet.SC2S_INVENTORY_SWAP_REQ) */ {
 public:
  inline SC2S_INVENTORY_SWAP_REQ() : SC2S_INVENTORY_SWAP_REQ(nullptr) {}
  ~SC2S_INVENTORY_SWAP_REQ() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SC2S_INVENTORY_SWAP_REQ(
      ::google::protobuf::internal::ConstantInitialized);

  inline SC2S_INVENTORY_SWAP_REQ(const SC2S_INVENTORY_SWAP_REQ& from) : SC2S_INVENTORY_SWAP_REQ(nullptr, from) {}
  inline SC2S_INVENTORY_SWAP_REQ(SC2S_INVENTORY_SWAP_REQ&& from) noexcept
      : SC2S_INVENTORY_SWAP_REQ(nullptr, std::move(from)) {}
  inline SC2S_INVENTORY_SWAP_REQ& operator=(const SC2S_INVENTORY_SWAP_REQ& from) {
    CopyFrom(from);
    return *this;
  }
  inline SC2S_INVENTORY_SWAP_REQ& operator=(SC2S_INVENTORY_SWAP_REQ&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SC2S_INVENTORY_SWAP_REQ& default_instance() {
    return *internal_default_instance();
  }
  static inline const SC2S_INVENTORY_SWAP_REQ* internal_default_instance() {
    return reinterpret_cast<const SC2S_INVENTORY_SWAP_REQ*>(
        &_SC2S_INVENTORY_SWAP_REQ_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(SC2S_INVENTORY_SWAP_REQ& a, SC2S_INVENTORY_SWAP_REQ& b) { a.Swap(&b); }
  inline void Swap(SC2S_INVENTORY_SWAP_REQ* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SC2S_INVENTORY_SWAP_REQ* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SC2S_INVENTORY_SWAP_REQ* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<SC2S_INVENTORY_SWAP_REQ>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SC2S_INVENTORY_SWAP_REQ& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SC2S_INVENTORY_SWAP_REQ& from) { SC2S_INVENTORY_SWAP_REQ::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SC2S_INVENTORY_SWAP_REQ* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DC.Packet.SC2S_INVENTORY_SWAP_REQ"; }

 protected:
  explicit SC2S_INVENTORY_SWAP_REQ(::google::protobuf::Arena* arena);
  SC2S_INVENTORY_SWAP_REQ(::google::protobuf::Arena* arena, const SC2S_INVENTORY_SWAP_REQ& from);
  SC2S_INVENTORY_SWAP_REQ(::google::protobuf::Arena* arena, SC2S_INVENTORY_SWAP_REQ&& from) noexcept
      : SC2S_INVENTORY_SWAP_REQ(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSwapInfosFieldNumber = 3,
    kSrcInfoFieldNumber = 1,
    kDstInfoFieldNumber = 2,
  };
  // repeated .DC.Packet.INVENTORY_SWAP_DST_INFO swapInfos = 3;
  int swapinfos_size() const;
  private:
  int _internal_swapinfos_size() const;

  public:
  void clear_swapinfos() ;
  ::DC::Packet::INVENTORY_SWAP_DST_INFO* mutable_swapinfos(int index);
  ::google::protobuf::RepeatedPtrField<::DC::Packet::INVENTORY_SWAP_DST_INFO>* mutable_swapinfos();

  private:
  const ::google::protobuf::RepeatedPtrField<::DC::Packet::INVENTORY_SWAP_DST_INFO>& _internal_swapinfos() const;
  ::google::protobuf::RepeatedPtrField<::DC::Packet::INVENTORY_SWAP_DST_INFO>* _internal_mutable_swapinfos();
  public:
  const ::DC::Packet::INVENTORY_SWAP_DST_INFO& swapinfos(int index) const;
  ::DC::Packet::INVENTORY_SWAP_DST_INFO* add_swapinfos();
  const ::google::protobuf::RepeatedPtrField<::DC::Packet::INVENTORY_SWAP_DST_INFO>& swapinfos() const;
  // .DC.Packet.SINVENTORY_ITEM_REQ_INFO srcInfo = 1;
  bool has_srcinfo() const;
  void clear_srcinfo() ;
  const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& srcinfo() const;
  PROTOBUF_NODISCARD ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* release_srcinfo();
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* mutable_srcinfo();
  void set_allocated_srcinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value);
  void unsafe_arena_set_allocated_srcinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value);
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* unsafe_arena_release_srcinfo();

  private:
  const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& _internal_srcinfo() const;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* _internal_mutable_srcinfo();

  public:
  // .DC.Packet.SINVENTORY_ITEM_REQ_INFO dstInfo = 2;
  bool has_dstinfo() const;
  void clear_dstinfo() ;
  const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& dstinfo() const;
  PROTOBUF_NODISCARD ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* release_dstinfo();
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* mutable_dstinfo();
  void set_allocated_dstinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value);
  void unsafe_arena_set_allocated_dstinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value);
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* unsafe_arena_release_dstinfo();

  private:
  const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& _internal_dstinfo() const;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* _internal_mutable_dstinfo();

  public:
  // @@protoc_insertion_point(class_scope:DC.Packet.SC2S_INVENTORY_SWAP_REQ)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SC2S_INVENTORY_SWAP_REQ_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SC2S_INVENTORY_SWAP_REQ& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::DC::Packet::INVENTORY_SWAP_DST_INFO > swapinfos_;
    ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* srcinfo_;
    ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* dstinfo_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Inventory_2eproto;
};
// -------------------------------------------------------------------

class SC2S_INVENTORY_SINGLE_UPDATE_REQ final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DC.Packet.SC2S_INVENTORY_SINGLE_UPDATE_REQ) */ {
 public:
  inline SC2S_INVENTORY_SINGLE_UPDATE_REQ() : SC2S_INVENTORY_SINGLE_UPDATE_REQ(nullptr) {}
  ~SC2S_INVENTORY_SINGLE_UPDATE_REQ() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SC2S_INVENTORY_SINGLE_UPDATE_REQ(
      ::google::protobuf::internal::ConstantInitialized);

  inline SC2S_INVENTORY_SINGLE_UPDATE_REQ(const SC2S_INVENTORY_SINGLE_UPDATE_REQ& from) : SC2S_INVENTORY_SINGLE_UPDATE_REQ(nullptr, from) {}
  inline SC2S_INVENTORY_SINGLE_UPDATE_REQ(SC2S_INVENTORY_SINGLE_UPDATE_REQ&& from) noexcept
      : SC2S_INVENTORY_SINGLE_UPDATE_REQ(nullptr, std::move(from)) {}
  inline SC2S_INVENTORY_SINGLE_UPDATE_REQ& operator=(const SC2S_INVENTORY_SINGLE_UPDATE_REQ& from) {
    CopyFrom(from);
    return *this;
  }
  inline SC2S_INVENTORY_SINGLE_UPDATE_REQ& operator=(SC2S_INVENTORY_SINGLE_UPDATE_REQ&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SC2S_INVENTORY_SINGLE_UPDATE_REQ& default_instance() {
    return *internal_default_instance();
  }
  static inline const SC2S_INVENTORY_SINGLE_UPDATE_REQ* internal_default_instance() {
    return reinterpret_cast<const SC2S_INVENTORY_SINGLE_UPDATE_REQ*>(
        &_SC2S_INVENTORY_SINGLE_UPDATE_REQ_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(SC2S_INVENTORY_SINGLE_UPDATE_REQ& a, SC2S_INVENTORY_SINGLE_UPDATE_REQ& b) { a.Swap(&b); }
  inline void Swap(SC2S_INVENTORY_SINGLE_UPDATE_REQ* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SC2S_INVENTORY_SINGLE_UPDATE_REQ* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SC2S_INVENTORY_SINGLE_UPDATE_REQ* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<SC2S_INVENTORY_SINGLE_UPDATE_REQ>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SC2S_INVENTORY_SINGLE_UPDATE_REQ& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SC2S_INVENTORY_SINGLE_UPDATE_REQ& from) { SC2S_INVENTORY_SINGLE_UPDATE_REQ::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SC2S_INVENTORY_SINGLE_UPDATE_REQ* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DC.Packet.SC2S_INVENTORY_SINGLE_UPDATE_REQ"; }

 protected:
  explicit SC2S_INVENTORY_SINGLE_UPDATE_REQ(::google::protobuf::Arena* arena);
  SC2S_INVENTORY_SINGLE_UPDATE_REQ(::google::protobuf::Arena* arena, const SC2S_INVENTORY_SINGLE_UPDATE_REQ& from);
  SC2S_INVENTORY_SINGLE_UPDATE_REQ(::google::protobuf::Arena* arena, SC2S_INVENTORY_SINGLE_UPDATE_REQ&& from) noexcept
      : SC2S_INVENTORY_SINGLE_UPDATE_REQ(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOldItemFieldNumber = 2,
    kNewItemFieldNumber = 3,
    kSingleUpdateFlagFieldNumber = 1,
  };
  // repeated .DC.Packet.SItem oldItem = 2;
  int olditem_size() const;
  private:
  int _internal_olditem_size() const;

  public:
  void clear_olditem() ;
  ::DC::Packet::SItem* mutable_olditem(int index);
  ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>* mutable_olditem();

  private:
  const ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>& _internal_olditem() const;
  ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>* _internal_mutable_olditem();
  public:
  const ::DC::Packet::SItem& olditem(int index) const;
  ::DC::Packet::SItem* add_olditem();
  const ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>& olditem() const;
  // repeated .DC.Packet.SItem newItem = 3;
  int newitem_size() const;
  private:
  int _internal_newitem_size() const;

  public:
  void clear_newitem() ;
  ::DC::Packet::SItem* mutable_newitem(int index);
  ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>* mutable_newitem();

  private:
  const ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>& _internal_newitem() const;
  ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>* _internal_mutable_newitem();
  public:
  const ::DC::Packet::SItem& newitem(int index) const;
  ::DC::Packet::SItem* add_newitem();
  const ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>& newitem() const;
  // uint32 singleUpdateFlag = 1;
  void clear_singleupdateflag() ;
  ::uint32_t singleupdateflag() const;
  void set_singleupdateflag(::uint32_t value);

  private:
  ::uint32_t _internal_singleupdateflag() const;
  void _internal_set_singleupdateflag(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:DC.Packet.SC2S_INVENTORY_SINGLE_UPDATE_REQ)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SC2S_INVENTORY_SINGLE_UPDATE_REQ_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SC2S_INVENTORY_SINGLE_UPDATE_REQ& from_msg);
    ::google::protobuf::RepeatedPtrField< ::DC::Packet::SItem > olditem_;
    ::google::protobuf::RepeatedPtrField< ::DC::Packet::SItem > newitem_;
    ::uint32_t singleupdateflag_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Inventory_2eproto;
};
// -------------------------------------------------------------------

class SC2S_INVENTORY_ALL_UPDATE_REQ final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DC.Packet.SC2S_INVENTORY_ALL_UPDATE_REQ) */ {
 public:
  inline SC2S_INVENTORY_ALL_UPDATE_REQ() : SC2S_INVENTORY_ALL_UPDATE_REQ(nullptr) {}
  ~SC2S_INVENTORY_ALL_UPDATE_REQ() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SC2S_INVENTORY_ALL_UPDATE_REQ(
      ::google::protobuf::internal::ConstantInitialized);

  inline SC2S_INVENTORY_ALL_UPDATE_REQ(const SC2S_INVENTORY_ALL_UPDATE_REQ& from) : SC2S_INVENTORY_ALL_UPDATE_REQ(nullptr, from) {}
  inline SC2S_INVENTORY_ALL_UPDATE_REQ(SC2S_INVENTORY_ALL_UPDATE_REQ&& from) noexcept
      : SC2S_INVENTORY_ALL_UPDATE_REQ(nullptr, std::move(from)) {}
  inline SC2S_INVENTORY_ALL_UPDATE_REQ& operator=(const SC2S_INVENTORY_ALL_UPDATE_REQ& from) {
    CopyFrom(from);
    return *this;
  }
  inline SC2S_INVENTORY_ALL_UPDATE_REQ& operator=(SC2S_INVENTORY_ALL_UPDATE_REQ&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SC2S_INVENTORY_ALL_UPDATE_REQ& default_instance() {
    return *internal_default_instance();
  }
  static inline const SC2S_INVENTORY_ALL_UPDATE_REQ* internal_default_instance() {
    return reinterpret_cast<const SC2S_INVENTORY_ALL_UPDATE_REQ*>(
        &_SC2S_INVENTORY_ALL_UPDATE_REQ_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(SC2S_INVENTORY_ALL_UPDATE_REQ& a, SC2S_INVENTORY_ALL_UPDATE_REQ& b) { a.Swap(&b); }
  inline void Swap(SC2S_INVENTORY_ALL_UPDATE_REQ* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SC2S_INVENTORY_ALL_UPDATE_REQ* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SC2S_INVENTORY_ALL_UPDATE_REQ* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<SC2S_INVENTORY_ALL_UPDATE_REQ>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SC2S_INVENTORY_ALL_UPDATE_REQ& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SC2S_INVENTORY_ALL_UPDATE_REQ& from) { SC2S_INVENTORY_ALL_UPDATE_REQ::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SC2S_INVENTORY_ALL_UPDATE_REQ* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DC.Packet.SC2S_INVENTORY_ALL_UPDATE_REQ"; }

 protected:
  explicit SC2S_INVENTORY_ALL_UPDATE_REQ(::google::protobuf::Arena* arena);
  SC2S_INVENTORY_ALL_UPDATE_REQ(::google::protobuf::Arena* arena, const SC2S_INVENTORY_ALL_UPDATE_REQ& from);
  SC2S_INVENTORY_ALL_UPDATE_REQ(::google::protobuf::Arena* arena, SC2S_INVENTORY_ALL_UPDATE_REQ&& from) noexcept
      : SC2S_INVENTORY_ALL_UPDATE_REQ(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInventoryItemsFieldNumber = 1,
  };
  // repeated .DC.Packet.SItem inventoryItems = 1;
  int inventoryitems_size() const;
  private:
  int _internal_inventoryitems_size() const;

  public:
  void clear_inventoryitems() ;
  ::DC::Packet::SItem* mutable_inventoryitems(int index);
  ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>* mutable_inventoryitems();

  private:
  const ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>& _internal_inventoryitems() const;
  ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>* _internal_mutable_inventoryitems();
  public:
  const ::DC::Packet::SItem& inventoryitems(int index) const;
  ::DC::Packet::SItem* add_inventoryitems();
  const ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>& inventoryitems() const;
  // @@protoc_insertion_point(class_scope:DC.Packet.SC2S_INVENTORY_ALL_UPDATE_REQ)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SC2S_INVENTORY_ALL_UPDATE_REQ_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SC2S_INVENTORY_ALL_UPDATE_REQ& from_msg);
    ::google::protobuf::RepeatedPtrField< ::DC::Packet::SItem > inventoryitems_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Inventory_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// SC2S_INVENTORY_INFO_REQ

// -------------------------------------------------------------------

// SS2C_INVENTORY_INFO_RES

// uint32 result = 1;
inline void SS2C_INVENTORY_INFO_RES::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = 0u;
}
inline ::uint32_t SS2C_INVENTORY_INFO_RES::result() const {
  // @@protoc_insertion_point(field_get:DC.Packet.SS2C_INVENTORY_INFO_RES.result)
  return _internal_result();
}
inline void SS2C_INVENTORY_INFO_RES::set_result(::uint32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:DC.Packet.SS2C_INVENTORY_INFO_RES.result)
}
inline ::uint32_t SS2C_INVENTORY_INFO_RES::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.result_;
}
inline void SS2C_INVENTORY_INFO_RES::_internal_set_result(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = value;
}

// repeated .DC.Packet.SItem inventoryItems = 2;
inline int SS2C_INVENTORY_INFO_RES::_internal_inventoryitems_size() const {
  return _internal_inventoryitems().size();
}
inline int SS2C_INVENTORY_INFO_RES::inventoryitems_size() const {
  return _internal_inventoryitems_size();
}
inline ::DC::Packet::SItem* SS2C_INVENTORY_INFO_RES::mutable_inventoryitems(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:DC.Packet.SS2C_INVENTORY_INFO_RES.inventoryItems)
  return _internal_mutable_inventoryitems()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>* SS2C_INVENTORY_INFO_RES::mutable_inventoryitems()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:DC.Packet.SS2C_INVENTORY_INFO_RES.inventoryItems)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_inventoryitems();
}
inline const ::DC::Packet::SItem& SS2C_INVENTORY_INFO_RES::inventoryitems(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DC.Packet.SS2C_INVENTORY_INFO_RES.inventoryItems)
  return _internal_inventoryitems().Get(index);
}
inline ::DC::Packet::SItem* SS2C_INVENTORY_INFO_RES::add_inventoryitems() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::DC::Packet::SItem* _add = _internal_mutable_inventoryitems()->Add();
  // @@protoc_insertion_point(field_add:DC.Packet.SS2C_INVENTORY_INFO_RES.inventoryItems)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>& SS2C_INVENTORY_INFO_RES::inventoryitems() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:DC.Packet.SS2C_INVENTORY_INFO_RES.inventoryItems)
  return _internal_inventoryitems();
}
inline const ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>&
SS2C_INVENTORY_INFO_RES::_internal_inventoryitems() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.inventoryitems_;
}
inline ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>*
SS2C_INVENTORY_INFO_RES::_internal_mutable_inventoryitems() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.inventoryitems_;
}

// -------------------------------------------------------------------

// SC2S_INVENTORY_ALL_UPDATE_REQ

// repeated .DC.Packet.SItem inventoryItems = 1;
inline int SC2S_INVENTORY_ALL_UPDATE_REQ::_internal_inventoryitems_size() const {
  return _internal_inventoryitems().size();
}
inline int SC2S_INVENTORY_ALL_UPDATE_REQ::inventoryitems_size() const {
  return _internal_inventoryitems_size();
}
inline ::DC::Packet::SItem* SC2S_INVENTORY_ALL_UPDATE_REQ::mutable_inventoryitems(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:DC.Packet.SC2S_INVENTORY_ALL_UPDATE_REQ.inventoryItems)
  return _internal_mutable_inventoryitems()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>* SC2S_INVENTORY_ALL_UPDATE_REQ::mutable_inventoryitems()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:DC.Packet.SC2S_INVENTORY_ALL_UPDATE_REQ.inventoryItems)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_inventoryitems();
}
inline const ::DC::Packet::SItem& SC2S_INVENTORY_ALL_UPDATE_REQ::inventoryitems(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DC.Packet.SC2S_INVENTORY_ALL_UPDATE_REQ.inventoryItems)
  return _internal_inventoryitems().Get(index);
}
inline ::DC::Packet::SItem* SC2S_INVENTORY_ALL_UPDATE_REQ::add_inventoryitems() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::DC::Packet::SItem* _add = _internal_mutable_inventoryitems()->Add();
  // @@protoc_insertion_point(field_add:DC.Packet.SC2S_INVENTORY_ALL_UPDATE_REQ.inventoryItems)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>& SC2S_INVENTORY_ALL_UPDATE_REQ::inventoryitems() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:DC.Packet.SC2S_INVENTORY_ALL_UPDATE_REQ.inventoryItems)
  return _internal_inventoryitems();
}
inline const ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>&
SC2S_INVENTORY_ALL_UPDATE_REQ::_internal_inventoryitems() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.inventoryitems_;
}
inline ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>*
SC2S_INVENTORY_ALL_UPDATE_REQ::_internal_mutable_inventoryitems() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.inventoryitems_;
}

// -------------------------------------------------------------------

// SS2C_INVENTORY_ALL_UPDATE_RES

// uint32 result = 1;
inline void SS2C_INVENTORY_ALL_UPDATE_RES::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = 0u;
}
inline ::uint32_t SS2C_INVENTORY_ALL_UPDATE_RES::result() const {
  // @@protoc_insertion_point(field_get:DC.Packet.SS2C_INVENTORY_ALL_UPDATE_RES.result)
  return _internal_result();
}
inline void SS2C_INVENTORY_ALL_UPDATE_RES::set_result(::uint32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:DC.Packet.SS2C_INVENTORY_ALL_UPDATE_RES.result)
}
inline ::uint32_t SS2C_INVENTORY_ALL_UPDATE_RES::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.result_;
}
inline void SS2C_INVENTORY_ALL_UPDATE_RES::_internal_set_result(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = value;
}

// repeated .DC.Packet.SItem inventoryItems = 2;
inline int SS2C_INVENTORY_ALL_UPDATE_RES::_internal_inventoryitems_size() const {
  return _internal_inventoryitems().size();
}
inline int SS2C_INVENTORY_ALL_UPDATE_RES::inventoryitems_size() const {
  return _internal_inventoryitems_size();
}
inline ::DC::Packet::SItem* SS2C_INVENTORY_ALL_UPDATE_RES::mutable_inventoryitems(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:DC.Packet.SS2C_INVENTORY_ALL_UPDATE_RES.inventoryItems)
  return _internal_mutable_inventoryitems()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>* SS2C_INVENTORY_ALL_UPDATE_RES::mutable_inventoryitems()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:DC.Packet.SS2C_INVENTORY_ALL_UPDATE_RES.inventoryItems)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_inventoryitems();
}
inline const ::DC::Packet::SItem& SS2C_INVENTORY_ALL_UPDATE_RES::inventoryitems(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DC.Packet.SS2C_INVENTORY_ALL_UPDATE_RES.inventoryItems)
  return _internal_inventoryitems().Get(index);
}
inline ::DC::Packet::SItem* SS2C_INVENTORY_ALL_UPDATE_RES::add_inventoryitems() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::DC::Packet::SItem* _add = _internal_mutable_inventoryitems()->Add();
  // @@protoc_insertion_point(field_add:DC.Packet.SS2C_INVENTORY_ALL_UPDATE_RES.inventoryItems)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>& SS2C_INVENTORY_ALL_UPDATE_RES::inventoryitems() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:DC.Packet.SS2C_INVENTORY_ALL_UPDATE_RES.inventoryItems)
  return _internal_inventoryitems();
}
inline const ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>&
SS2C_INVENTORY_ALL_UPDATE_RES::_internal_inventoryitems() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.inventoryitems_;
}
inline ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>*
SS2C_INVENTORY_ALL_UPDATE_RES::_internal_mutable_inventoryitems() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.inventoryitems_;
}

// -------------------------------------------------------------------

// SINVENTORY_ITEM_REQ_INFO

// uint64 uniqueId = 1;
inline void SINVENTORY_ITEM_REQ_INFO::clear_uniqueid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uniqueid_ = ::uint64_t{0u};
}
inline ::uint64_t SINVENTORY_ITEM_REQ_INFO::uniqueid() const {
  // @@protoc_insertion_point(field_get:DC.Packet.SINVENTORY_ITEM_REQ_INFO.uniqueId)
  return _internal_uniqueid();
}
inline void SINVENTORY_ITEM_REQ_INFO::set_uniqueid(::uint64_t value) {
  _internal_set_uniqueid(value);
  // @@protoc_insertion_point(field_set:DC.Packet.SINVENTORY_ITEM_REQ_INFO.uniqueId)
}
inline ::uint64_t SINVENTORY_ITEM_REQ_INFO::_internal_uniqueid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.uniqueid_;
}
inline void SINVENTORY_ITEM_REQ_INFO::_internal_set_uniqueid(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uniqueid_ = value;
}

// uint32 inventoryId = 2;
inline void SINVENTORY_ITEM_REQ_INFO::clear_inventoryid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inventoryid_ = 0u;
}
inline ::uint32_t SINVENTORY_ITEM_REQ_INFO::inventoryid() const {
  // @@protoc_insertion_point(field_get:DC.Packet.SINVENTORY_ITEM_REQ_INFO.inventoryId)
  return _internal_inventoryid();
}
inline void SINVENTORY_ITEM_REQ_INFO::set_inventoryid(::uint32_t value) {
  _internal_set_inventoryid(value);
  // @@protoc_insertion_point(field_set:DC.Packet.SINVENTORY_ITEM_REQ_INFO.inventoryId)
}
inline ::uint32_t SINVENTORY_ITEM_REQ_INFO::_internal_inventoryid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.inventoryid_;
}
inline void SINVENTORY_ITEM_REQ_INFO::_internal_set_inventoryid(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inventoryid_ = value;
}

// uint32 slotId = 3;
inline void SINVENTORY_ITEM_REQ_INFO::clear_slotid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.slotid_ = 0u;
}
inline ::uint32_t SINVENTORY_ITEM_REQ_INFO::slotid() const {
  // @@protoc_insertion_point(field_get:DC.Packet.SINVENTORY_ITEM_REQ_INFO.slotId)
  return _internal_slotid();
}
inline void SINVENTORY_ITEM_REQ_INFO::set_slotid(::uint32_t value) {
  _internal_set_slotid(value);
  // @@protoc_insertion_point(field_set:DC.Packet.SINVENTORY_ITEM_REQ_INFO.slotId)
}
inline ::uint32_t SINVENTORY_ITEM_REQ_INFO::_internal_slotid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.slotid_;
}
inline void SINVENTORY_ITEM_REQ_INFO::_internal_set_slotid(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.slotid_ = value;
}

// -------------------------------------------------------------------

// SC2S_INVENTORY_MOVE_REQ

// .DC.Packet.SINVENTORY_ITEM_REQ_INFO srcInfo = 1;
inline bool SC2S_INVENTORY_MOVE_REQ::has_srcinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.srcinfo_ != nullptr);
  return value;
}
inline void SC2S_INVENTORY_MOVE_REQ::clear_srcinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.srcinfo_ != nullptr) _impl_.srcinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& SC2S_INVENTORY_MOVE_REQ::_internal_srcinfo() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* p = _impl_.srcinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO&>(::DC::Packet::_SINVENTORY_ITEM_REQ_INFO_default_instance_);
}
inline const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& SC2S_INVENTORY_MOVE_REQ::srcinfo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DC.Packet.SC2S_INVENTORY_MOVE_REQ.srcInfo)
  return _internal_srcinfo();
}
inline void SC2S_INVENTORY_MOVE_REQ::unsafe_arena_set_allocated_srcinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.srcinfo_);
  }
  _impl_.srcinfo_ = reinterpret_cast<::DC::Packet::SINVENTORY_ITEM_REQ_INFO*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DC.Packet.SC2S_INVENTORY_MOVE_REQ.srcInfo)
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* SC2S_INVENTORY_MOVE_REQ::release_srcinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* released = _impl_.srcinfo_;
  _impl_.srcinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* SC2S_INVENTORY_MOVE_REQ::unsafe_arena_release_srcinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:DC.Packet.SC2S_INVENTORY_MOVE_REQ.srcInfo)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* temp = _impl_.srcinfo_;
  _impl_.srcinfo_ = nullptr;
  return temp;
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* SC2S_INVENTORY_MOVE_REQ::_internal_mutable_srcinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.srcinfo_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::DC::Packet::SINVENTORY_ITEM_REQ_INFO>(GetArena());
    _impl_.srcinfo_ = reinterpret_cast<::DC::Packet::SINVENTORY_ITEM_REQ_INFO*>(p);
  }
  return _impl_.srcinfo_;
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* SC2S_INVENTORY_MOVE_REQ::mutable_srcinfo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* _msg = _internal_mutable_srcinfo();
  // @@protoc_insertion_point(field_mutable:DC.Packet.SC2S_INVENTORY_MOVE_REQ.srcInfo)
  return _msg;
}
inline void SC2S_INVENTORY_MOVE_REQ::set_allocated_srcinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.srcinfo_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.srcinfo_ = reinterpret_cast<::DC::Packet::SINVENTORY_ITEM_REQ_INFO*>(value);
  // @@protoc_insertion_point(field_set_allocated:DC.Packet.SC2S_INVENTORY_MOVE_REQ.srcInfo)
}

// uint32 dstInventoryId = 2;
inline void SC2S_INVENTORY_MOVE_REQ::clear_dstinventoryid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dstinventoryid_ = 0u;
}
inline ::uint32_t SC2S_INVENTORY_MOVE_REQ::dstinventoryid() const {
  // @@protoc_insertion_point(field_get:DC.Packet.SC2S_INVENTORY_MOVE_REQ.dstInventoryId)
  return _internal_dstinventoryid();
}
inline void SC2S_INVENTORY_MOVE_REQ::set_dstinventoryid(::uint32_t value) {
  _internal_set_dstinventoryid(value);
  // @@protoc_insertion_point(field_set:DC.Packet.SC2S_INVENTORY_MOVE_REQ.dstInventoryId)
}
inline ::uint32_t SC2S_INVENTORY_MOVE_REQ::_internal_dstinventoryid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dstinventoryid_;
}
inline void SC2S_INVENTORY_MOVE_REQ::_internal_set_dstinventoryid(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dstinventoryid_ = value;
}

// uint32 dstSlotId = 3;
inline void SC2S_INVENTORY_MOVE_REQ::clear_dstslotid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dstslotid_ = 0u;
}
inline ::uint32_t SC2S_INVENTORY_MOVE_REQ::dstslotid() const {
  // @@protoc_insertion_point(field_get:DC.Packet.SC2S_INVENTORY_MOVE_REQ.dstSlotId)
  return _internal_dstslotid();
}
inline void SC2S_INVENTORY_MOVE_REQ::set_dstslotid(::uint32_t value) {
  _internal_set_dstslotid(value);
  // @@protoc_insertion_point(field_set:DC.Packet.SC2S_INVENTORY_MOVE_REQ.dstSlotId)
}
inline ::uint32_t SC2S_INVENTORY_MOVE_REQ::_internal_dstslotid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dstslotid_;
}
inline void SC2S_INVENTORY_MOVE_REQ::_internal_set_dstslotid(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dstslotid_ = value;
}

// -------------------------------------------------------------------

// SS2C_INVENTORY_MOVE_RES

// -------------------------------------------------------------------

// SC2S_INVENTORY_MERGE_REQ

// .DC.Packet.SINVENTORY_ITEM_REQ_INFO srcInfo = 1;
inline bool SC2S_INVENTORY_MERGE_REQ::has_srcinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.srcinfo_ != nullptr);
  return value;
}
inline void SC2S_INVENTORY_MERGE_REQ::clear_srcinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.srcinfo_ != nullptr) _impl_.srcinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& SC2S_INVENTORY_MERGE_REQ::_internal_srcinfo() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* p = _impl_.srcinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO&>(::DC::Packet::_SINVENTORY_ITEM_REQ_INFO_default_instance_);
}
inline const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& SC2S_INVENTORY_MERGE_REQ::srcinfo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DC.Packet.SC2S_INVENTORY_MERGE_REQ.srcInfo)
  return _internal_srcinfo();
}
inline void SC2S_INVENTORY_MERGE_REQ::unsafe_arena_set_allocated_srcinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.srcinfo_);
  }
  _impl_.srcinfo_ = reinterpret_cast<::DC::Packet::SINVENTORY_ITEM_REQ_INFO*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DC.Packet.SC2S_INVENTORY_MERGE_REQ.srcInfo)
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* SC2S_INVENTORY_MERGE_REQ::release_srcinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* released = _impl_.srcinfo_;
  _impl_.srcinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* SC2S_INVENTORY_MERGE_REQ::unsafe_arena_release_srcinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:DC.Packet.SC2S_INVENTORY_MERGE_REQ.srcInfo)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* temp = _impl_.srcinfo_;
  _impl_.srcinfo_ = nullptr;
  return temp;
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* SC2S_INVENTORY_MERGE_REQ::_internal_mutable_srcinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.srcinfo_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::DC::Packet::SINVENTORY_ITEM_REQ_INFO>(GetArena());
    _impl_.srcinfo_ = reinterpret_cast<::DC::Packet::SINVENTORY_ITEM_REQ_INFO*>(p);
  }
  return _impl_.srcinfo_;
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* SC2S_INVENTORY_MERGE_REQ::mutable_srcinfo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* _msg = _internal_mutable_srcinfo();
  // @@protoc_insertion_point(field_mutable:DC.Packet.SC2S_INVENTORY_MERGE_REQ.srcInfo)
  return _msg;
}
inline void SC2S_INVENTORY_MERGE_REQ::set_allocated_srcinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.srcinfo_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.srcinfo_ = reinterpret_cast<::DC::Packet::SINVENTORY_ITEM_REQ_INFO*>(value);
  // @@protoc_insertion_point(field_set_allocated:DC.Packet.SC2S_INVENTORY_MERGE_REQ.srcInfo)
}

// .DC.Packet.SINVENTORY_ITEM_REQ_INFO dstInfo = 2;
inline bool SC2S_INVENTORY_MERGE_REQ::has_dstinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dstinfo_ != nullptr);
  return value;
}
inline void SC2S_INVENTORY_MERGE_REQ::clear_dstinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dstinfo_ != nullptr) _impl_.dstinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& SC2S_INVENTORY_MERGE_REQ::_internal_dstinfo() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* p = _impl_.dstinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO&>(::DC::Packet::_SINVENTORY_ITEM_REQ_INFO_default_instance_);
}
inline const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& SC2S_INVENTORY_MERGE_REQ::dstinfo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DC.Packet.SC2S_INVENTORY_MERGE_REQ.dstInfo)
  return _internal_dstinfo();
}
inline void SC2S_INVENTORY_MERGE_REQ::unsafe_arena_set_allocated_dstinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dstinfo_);
  }
  _impl_.dstinfo_ = reinterpret_cast<::DC::Packet::SINVENTORY_ITEM_REQ_INFO*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DC.Packet.SC2S_INVENTORY_MERGE_REQ.dstInfo)
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* SC2S_INVENTORY_MERGE_REQ::release_dstinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* released = _impl_.dstinfo_;
  _impl_.dstinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* SC2S_INVENTORY_MERGE_REQ::unsafe_arena_release_dstinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:DC.Packet.SC2S_INVENTORY_MERGE_REQ.dstInfo)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* temp = _impl_.dstinfo_;
  _impl_.dstinfo_ = nullptr;
  return temp;
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* SC2S_INVENTORY_MERGE_REQ::_internal_mutable_dstinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dstinfo_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::DC::Packet::SINVENTORY_ITEM_REQ_INFO>(GetArena());
    _impl_.dstinfo_ = reinterpret_cast<::DC::Packet::SINVENTORY_ITEM_REQ_INFO*>(p);
  }
  return _impl_.dstinfo_;
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* SC2S_INVENTORY_MERGE_REQ::mutable_dstinfo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* _msg = _internal_mutable_dstinfo();
  // @@protoc_insertion_point(field_mutable:DC.Packet.SC2S_INVENTORY_MERGE_REQ.dstInfo)
  return _msg;
}
inline void SC2S_INVENTORY_MERGE_REQ::set_allocated_dstinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.dstinfo_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.dstinfo_ = reinterpret_cast<::DC::Packet::SINVENTORY_ITEM_REQ_INFO*>(value);
  // @@protoc_insertion_point(field_set_allocated:DC.Packet.SC2S_INVENTORY_MERGE_REQ.dstInfo)
}

// -------------------------------------------------------------------

// SS2C_INVENTORY_MERGE_RES

// -------------------------------------------------------------------

// INVENTORY_SWAP_DST_INFO

// .DC.Packet.SINVENTORY_ITEM_REQ_INFO dstInfo = 1;
inline bool INVENTORY_SWAP_DST_INFO::has_dstinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dstinfo_ != nullptr);
  return value;
}
inline void INVENTORY_SWAP_DST_INFO::clear_dstinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dstinfo_ != nullptr) _impl_.dstinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& INVENTORY_SWAP_DST_INFO::_internal_dstinfo() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* p = _impl_.dstinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO&>(::DC::Packet::_SINVENTORY_ITEM_REQ_INFO_default_instance_);
}
inline const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& INVENTORY_SWAP_DST_INFO::dstinfo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DC.Packet.INVENTORY_SWAP_DST_INFO.dstInfo)
  return _internal_dstinfo();
}
inline void INVENTORY_SWAP_DST_INFO::unsafe_arena_set_allocated_dstinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dstinfo_);
  }
  _impl_.dstinfo_ = reinterpret_cast<::DC::Packet::SINVENTORY_ITEM_REQ_INFO*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DC.Packet.INVENTORY_SWAP_DST_INFO.dstInfo)
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* INVENTORY_SWAP_DST_INFO::release_dstinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* released = _impl_.dstinfo_;
  _impl_.dstinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* INVENTORY_SWAP_DST_INFO::unsafe_arena_release_dstinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:DC.Packet.INVENTORY_SWAP_DST_INFO.dstInfo)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* temp = _impl_.dstinfo_;
  _impl_.dstinfo_ = nullptr;
  return temp;
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* INVENTORY_SWAP_DST_INFO::_internal_mutable_dstinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dstinfo_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::DC::Packet::SINVENTORY_ITEM_REQ_INFO>(GetArena());
    _impl_.dstinfo_ = reinterpret_cast<::DC::Packet::SINVENTORY_ITEM_REQ_INFO*>(p);
  }
  return _impl_.dstinfo_;
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* INVENTORY_SWAP_DST_INFO::mutable_dstinfo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* _msg = _internal_mutable_dstinfo();
  // @@protoc_insertion_point(field_mutable:DC.Packet.INVENTORY_SWAP_DST_INFO.dstInfo)
  return _msg;
}
inline void INVENTORY_SWAP_DST_INFO::set_allocated_dstinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.dstinfo_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.dstinfo_ = reinterpret_cast<::DC::Packet::SINVENTORY_ITEM_REQ_INFO*>(value);
  // @@protoc_insertion_point(field_set_allocated:DC.Packet.INVENTORY_SWAP_DST_INFO.dstInfo)
}

// uint32 newSlotId = 2;
inline void INVENTORY_SWAP_DST_INFO::clear_newslotid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.newslotid_ = 0u;
}
inline ::uint32_t INVENTORY_SWAP_DST_INFO::newslotid() const {
  // @@protoc_insertion_point(field_get:DC.Packet.INVENTORY_SWAP_DST_INFO.newSlotId)
  return _internal_newslotid();
}
inline void INVENTORY_SWAP_DST_INFO::set_newslotid(::uint32_t value) {
  _internal_set_newslotid(value);
  // @@protoc_insertion_point(field_set:DC.Packet.INVENTORY_SWAP_DST_INFO.newSlotId)
}
inline ::uint32_t INVENTORY_SWAP_DST_INFO::_internal_newslotid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.newslotid_;
}
inline void INVENTORY_SWAP_DST_INFO::_internal_set_newslotid(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.newslotid_ = value;
}

// uint32 newInventoryId = 3;
inline void INVENTORY_SWAP_DST_INFO::clear_newinventoryid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.newinventoryid_ = 0u;
}
inline ::uint32_t INVENTORY_SWAP_DST_INFO::newinventoryid() const {
  // @@protoc_insertion_point(field_get:DC.Packet.INVENTORY_SWAP_DST_INFO.newInventoryId)
  return _internal_newinventoryid();
}
inline void INVENTORY_SWAP_DST_INFO::set_newinventoryid(::uint32_t value) {
  _internal_set_newinventoryid(value);
  // @@protoc_insertion_point(field_set:DC.Packet.INVENTORY_SWAP_DST_INFO.newInventoryId)
}
inline ::uint32_t INVENTORY_SWAP_DST_INFO::_internal_newinventoryid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.newinventoryid_;
}
inline void INVENTORY_SWAP_DST_INFO::_internal_set_newinventoryid(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.newinventoryid_ = value;
}

// -------------------------------------------------------------------

// SC2S_INVENTORY_SWAP_REQ

// .DC.Packet.SINVENTORY_ITEM_REQ_INFO srcInfo = 1;
inline bool SC2S_INVENTORY_SWAP_REQ::has_srcinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.srcinfo_ != nullptr);
  return value;
}
inline void SC2S_INVENTORY_SWAP_REQ::clear_srcinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.srcinfo_ != nullptr) _impl_.srcinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& SC2S_INVENTORY_SWAP_REQ::_internal_srcinfo() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* p = _impl_.srcinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO&>(::DC::Packet::_SINVENTORY_ITEM_REQ_INFO_default_instance_);
}
inline const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& SC2S_INVENTORY_SWAP_REQ::srcinfo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DC.Packet.SC2S_INVENTORY_SWAP_REQ.srcInfo)
  return _internal_srcinfo();
}
inline void SC2S_INVENTORY_SWAP_REQ::unsafe_arena_set_allocated_srcinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.srcinfo_);
  }
  _impl_.srcinfo_ = reinterpret_cast<::DC::Packet::SINVENTORY_ITEM_REQ_INFO*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DC.Packet.SC2S_INVENTORY_SWAP_REQ.srcInfo)
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* SC2S_INVENTORY_SWAP_REQ::release_srcinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* released = _impl_.srcinfo_;
  _impl_.srcinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* SC2S_INVENTORY_SWAP_REQ::unsafe_arena_release_srcinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:DC.Packet.SC2S_INVENTORY_SWAP_REQ.srcInfo)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* temp = _impl_.srcinfo_;
  _impl_.srcinfo_ = nullptr;
  return temp;
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* SC2S_INVENTORY_SWAP_REQ::_internal_mutable_srcinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.srcinfo_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::DC::Packet::SINVENTORY_ITEM_REQ_INFO>(GetArena());
    _impl_.srcinfo_ = reinterpret_cast<::DC::Packet::SINVENTORY_ITEM_REQ_INFO*>(p);
  }
  return _impl_.srcinfo_;
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* SC2S_INVENTORY_SWAP_REQ::mutable_srcinfo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* _msg = _internal_mutable_srcinfo();
  // @@protoc_insertion_point(field_mutable:DC.Packet.SC2S_INVENTORY_SWAP_REQ.srcInfo)
  return _msg;
}
inline void SC2S_INVENTORY_SWAP_REQ::set_allocated_srcinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.srcinfo_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.srcinfo_ = reinterpret_cast<::DC::Packet::SINVENTORY_ITEM_REQ_INFO*>(value);
  // @@protoc_insertion_point(field_set_allocated:DC.Packet.SC2S_INVENTORY_SWAP_REQ.srcInfo)
}

// .DC.Packet.SINVENTORY_ITEM_REQ_INFO dstInfo = 2;
inline bool SC2S_INVENTORY_SWAP_REQ::has_dstinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dstinfo_ != nullptr);
  return value;
}
inline void SC2S_INVENTORY_SWAP_REQ::clear_dstinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dstinfo_ != nullptr) _impl_.dstinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& SC2S_INVENTORY_SWAP_REQ::_internal_dstinfo() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* p = _impl_.dstinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO&>(::DC::Packet::_SINVENTORY_ITEM_REQ_INFO_default_instance_);
}
inline const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& SC2S_INVENTORY_SWAP_REQ::dstinfo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DC.Packet.SC2S_INVENTORY_SWAP_REQ.dstInfo)
  return _internal_dstinfo();
}
inline void SC2S_INVENTORY_SWAP_REQ::unsafe_arena_set_allocated_dstinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dstinfo_);
  }
  _impl_.dstinfo_ = reinterpret_cast<::DC::Packet::SINVENTORY_ITEM_REQ_INFO*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DC.Packet.SC2S_INVENTORY_SWAP_REQ.dstInfo)
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* SC2S_INVENTORY_SWAP_REQ::release_dstinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* released = _impl_.dstinfo_;
  _impl_.dstinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* SC2S_INVENTORY_SWAP_REQ::unsafe_arena_release_dstinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:DC.Packet.SC2S_INVENTORY_SWAP_REQ.dstInfo)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* temp = _impl_.dstinfo_;
  _impl_.dstinfo_ = nullptr;
  return temp;
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* SC2S_INVENTORY_SWAP_REQ::_internal_mutable_dstinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dstinfo_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::DC::Packet::SINVENTORY_ITEM_REQ_INFO>(GetArena());
    _impl_.dstinfo_ = reinterpret_cast<::DC::Packet::SINVENTORY_ITEM_REQ_INFO*>(p);
  }
  return _impl_.dstinfo_;
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* SC2S_INVENTORY_SWAP_REQ::mutable_dstinfo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* _msg = _internal_mutable_dstinfo();
  // @@protoc_insertion_point(field_mutable:DC.Packet.SC2S_INVENTORY_SWAP_REQ.dstInfo)
  return _msg;
}
inline void SC2S_INVENTORY_SWAP_REQ::set_allocated_dstinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.dstinfo_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.dstinfo_ = reinterpret_cast<::DC::Packet::SINVENTORY_ITEM_REQ_INFO*>(value);
  // @@protoc_insertion_point(field_set_allocated:DC.Packet.SC2S_INVENTORY_SWAP_REQ.dstInfo)
}

// repeated .DC.Packet.INVENTORY_SWAP_DST_INFO swapInfos = 3;
inline int SC2S_INVENTORY_SWAP_REQ::_internal_swapinfos_size() const {
  return _internal_swapinfos().size();
}
inline int SC2S_INVENTORY_SWAP_REQ::swapinfos_size() const {
  return _internal_swapinfos_size();
}
inline void SC2S_INVENTORY_SWAP_REQ::clear_swapinfos() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.swapinfos_.Clear();
}
inline ::DC::Packet::INVENTORY_SWAP_DST_INFO* SC2S_INVENTORY_SWAP_REQ::mutable_swapinfos(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:DC.Packet.SC2S_INVENTORY_SWAP_REQ.swapInfos)
  return _internal_mutable_swapinfos()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::DC::Packet::INVENTORY_SWAP_DST_INFO>* SC2S_INVENTORY_SWAP_REQ::mutable_swapinfos()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:DC.Packet.SC2S_INVENTORY_SWAP_REQ.swapInfos)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_swapinfos();
}
inline const ::DC::Packet::INVENTORY_SWAP_DST_INFO& SC2S_INVENTORY_SWAP_REQ::swapinfos(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DC.Packet.SC2S_INVENTORY_SWAP_REQ.swapInfos)
  return _internal_swapinfos().Get(index);
}
inline ::DC::Packet::INVENTORY_SWAP_DST_INFO* SC2S_INVENTORY_SWAP_REQ::add_swapinfos() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::DC::Packet::INVENTORY_SWAP_DST_INFO* _add = _internal_mutable_swapinfos()->Add();
  // @@protoc_insertion_point(field_add:DC.Packet.SC2S_INVENTORY_SWAP_REQ.swapInfos)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::DC::Packet::INVENTORY_SWAP_DST_INFO>& SC2S_INVENTORY_SWAP_REQ::swapinfos() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:DC.Packet.SC2S_INVENTORY_SWAP_REQ.swapInfos)
  return _internal_swapinfos();
}
inline const ::google::protobuf::RepeatedPtrField<::DC::Packet::INVENTORY_SWAP_DST_INFO>&
SC2S_INVENTORY_SWAP_REQ::_internal_swapinfos() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.swapinfos_;
}
inline ::google::protobuf::RepeatedPtrField<::DC::Packet::INVENTORY_SWAP_DST_INFO>*
SC2S_INVENTORY_SWAP_REQ::_internal_mutable_swapinfos() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.swapinfos_;
}

// -------------------------------------------------------------------

// SS2C_INVENTORY_SWAP_RES

// -------------------------------------------------------------------

// SC2S_INVENTORY_SPLIT_MOVE_REQ

// .DC.Packet.SINVENTORY_ITEM_REQ_INFO srcInfo = 1;
inline bool SC2S_INVENTORY_SPLIT_MOVE_REQ::has_srcinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.srcinfo_ != nullptr);
  return value;
}
inline void SC2S_INVENTORY_SPLIT_MOVE_REQ::clear_srcinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.srcinfo_ != nullptr) _impl_.srcinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& SC2S_INVENTORY_SPLIT_MOVE_REQ::_internal_srcinfo() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* p = _impl_.srcinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO&>(::DC::Packet::_SINVENTORY_ITEM_REQ_INFO_default_instance_);
}
inline const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& SC2S_INVENTORY_SPLIT_MOVE_REQ::srcinfo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DC.Packet.SC2S_INVENTORY_SPLIT_MOVE_REQ.srcInfo)
  return _internal_srcinfo();
}
inline void SC2S_INVENTORY_SPLIT_MOVE_REQ::unsafe_arena_set_allocated_srcinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.srcinfo_);
  }
  _impl_.srcinfo_ = reinterpret_cast<::DC::Packet::SINVENTORY_ITEM_REQ_INFO*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DC.Packet.SC2S_INVENTORY_SPLIT_MOVE_REQ.srcInfo)
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* SC2S_INVENTORY_SPLIT_MOVE_REQ::release_srcinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* released = _impl_.srcinfo_;
  _impl_.srcinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* SC2S_INVENTORY_SPLIT_MOVE_REQ::unsafe_arena_release_srcinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:DC.Packet.SC2S_INVENTORY_SPLIT_MOVE_REQ.srcInfo)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* temp = _impl_.srcinfo_;
  _impl_.srcinfo_ = nullptr;
  return temp;
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* SC2S_INVENTORY_SPLIT_MOVE_REQ::_internal_mutable_srcinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.srcinfo_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::DC::Packet::SINVENTORY_ITEM_REQ_INFO>(GetArena());
    _impl_.srcinfo_ = reinterpret_cast<::DC::Packet::SINVENTORY_ITEM_REQ_INFO*>(p);
  }
  return _impl_.srcinfo_;
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* SC2S_INVENTORY_SPLIT_MOVE_REQ::mutable_srcinfo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* _msg = _internal_mutable_srcinfo();
  // @@protoc_insertion_point(field_mutable:DC.Packet.SC2S_INVENTORY_SPLIT_MOVE_REQ.srcInfo)
  return _msg;
}
inline void SC2S_INVENTORY_SPLIT_MOVE_REQ::set_allocated_srcinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.srcinfo_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.srcinfo_ = reinterpret_cast<::DC::Packet::SINVENTORY_ITEM_REQ_INFO*>(value);
  // @@protoc_insertion_point(field_set_allocated:DC.Packet.SC2S_INVENTORY_SPLIT_MOVE_REQ.srcInfo)
}

// uint32 count = 2;
inline void SC2S_INVENTORY_SPLIT_MOVE_REQ::clear_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.count_ = 0u;
}
inline ::uint32_t SC2S_INVENTORY_SPLIT_MOVE_REQ::count() const {
  // @@protoc_insertion_point(field_get:DC.Packet.SC2S_INVENTORY_SPLIT_MOVE_REQ.count)
  return _internal_count();
}
inline void SC2S_INVENTORY_SPLIT_MOVE_REQ::set_count(::uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:DC.Packet.SC2S_INVENTORY_SPLIT_MOVE_REQ.count)
}
inline ::uint32_t SC2S_INVENTORY_SPLIT_MOVE_REQ::_internal_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.count_;
}
inline void SC2S_INVENTORY_SPLIT_MOVE_REQ::_internal_set_count(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.count_ = value;
}

// uint32 dstInventoryId = 3;
inline void SC2S_INVENTORY_SPLIT_MOVE_REQ::clear_dstinventoryid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dstinventoryid_ = 0u;
}
inline ::uint32_t SC2S_INVENTORY_SPLIT_MOVE_REQ::dstinventoryid() const {
  // @@protoc_insertion_point(field_get:DC.Packet.SC2S_INVENTORY_SPLIT_MOVE_REQ.dstInventoryId)
  return _internal_dstinventoryid();
}
inline void SC2S_INVENTORY_SPLIT_MOVE_REQ::set_dstinventoryid(::uint32_t value) {
  _internal_set_dstinventoryid(value);
  // @@protoc_insertion_point(field_set:DC.Packet.SC2S_INVENTORY_SPLIT_MOVE_REQ.dstInventoryId)
}
inline ::uint32_t SC2S_INVENTORY_SPLIT_MOVE_REQ::_internal_dstinventoryid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dstinventoryid_;
}
inline void SC2S_INVENTORY_SPLIT_MOVE_REQ::_internal_set_dstinventoryid(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dstinventoryid_ = value;
}

// uint32 dstSlotId = 4;
inline void SC2S_INVENTORY_SPLIT_MOVE_REQ::clear_dstslotid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dstslotid_ = 0u;
}
inline ::uint32_t SC2S_INVENTORY_SPLIT_MOVE_REQ::dstslotid() const {
  // @@protoc_insertion_point(field_get:DC.Packet.SC2S_INVENTORY_SPLIT_MOVE_REQ.dstSlotId)
  return _internal_dstslotid();
}
inline void SC2S_INVENTORY_SPLIT_MOVE_REQ::set_dstslotid(::uint32_t value) {
  _internal_set_dstslotid(value);
  // @@protoc_insertion_point(field_set:DC.Packet.SC2S_INVENTORY_SPLIT_MOVE_REQ.dstSlotId)
}
inline ::uint32_t SC2S_INVENTORY_SPLIT_MOVE_REQ::_internal_dstslotid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dstslotid_;
}
inline void SC2S_INVENTORY_SPLIT_MOVE_REQ::_internal_set_dstslotid(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dstslotid_ = value;
}

// -------------------------------------------------------------------

// SS2C_INVENTORY_SPLIT_MOVE_RES

// uint64 newUniqueId = 1;
inline void SS2C_INVENTORY_SPLIT_MOVE_RES::clear_newuniqueid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.newuniqueid_ = ::uint64_t{0u};
}
inline ::uint64_t SS2C_INVENTORY_SPLIT_MOVE_RES::newuniqueid() const {
  // @@protoc_insertion_point(field_get:DC.Packet.SS2C_INVENTORY_SPLIT_MOVE_RES.newUniqueId)
  return _internal_newuniqueid();
}
inline void SS2C_INVENTORY_SPLIT_MOVE_RES::set_newuniqueid(::uint64_t value) {
  _internal_set_newuniqueid(value);
  // @@protoc_insertion_point(field_set:DC.Packet.SS2C_INVENTORY_SPLIT_MOVE_RES.newUniqueId)
}
inline ::uint64_t SS2C_INVENTORY_SPLIT_MOVE_RES::_internal_newuniqueid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.newuniqueid_;
}
inline void SS2C_INVENTORY_SPLIT_MOVE_RES::_internal_set_newuniqueid(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.newuniqueid_ = value;
}

// uint32 newInventoryId = 2;
inline void SS2C_INVENTORY_SPLIT_MOVE_RES::clear_newinventoryid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.newinventoryid_ = 0u;
}
inline ::uint32_t SS2C_INVENTORY_SPLIT_MOVE_RES::newinventoryid() const {
  // @@protoc_insertion_point(field_get:DC.Packet.SS2C_INVENTORY_SPLIT_MOVE_RES.newInventoryId)
  return _internal_newinventoryid();
}
inline void SS2C_INVENTORY_SPLIT_MOVE_RES::set_newinventoryid(::uint32_t value) {
  _internal_set_newinventoryid(value);
  // @@protoc_insertion_point(field_set:DC.Packet.SS2C_INVENTORY_SPLIT_MOVE_RES.newInventoryId)
}
inline ::uint32_t SS2C_INVENTORY_SPLIT_MOVE_RES::_internal_newinventoryid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.newinventoryid_;
}
inline void SS2C_INVENTORY_SPLIT_MOVE_RES::_internal_set_newinventoryid(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.newinventoryid_ = value;
}

// uint32 newSlotId = 3;
inline void SS2C_INVENTORY_SPLIT_MOVE_RES::clear_newslotid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.newslotid_ = 0u;
}
inline ::uint32_t SS2C_INVENTORY_SPLIT_MOVE_RES::newslotid() const {
  // @@protoc_insertion_point(field_get:DC.Packet.SS2C_INVENTORY_SPLIT_MOVE_RES.newSlotId)
  return _internal_newslotid();
}
inline void SS2C_INVENTORY_SPLIT_MOVE_RES::set_newslotid(::uint32_t value) {
  _internal_set_newslotid(value);
  // @@protoc_insertion_point(field_set:DC.Packet.SS2C_INVENTORY_SPLIT_MOVE_RES.newSlotId)
}
inline ::uint32_t SS2C_INVENTORY_SPLIT_MOVE_RES::_internal_newslotid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.newslotid_;
}
inline void SS2C_INVENTORY_SPLIT_MOVE_RES::_internal_set_newslotid(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.newslotid_ = value;
}

// -------------------------------------------------------------------

// SC2S_INVENTORY_SPLIT_MERGE_REQ

// .DC.Packet.SINVENTORY_ITEM_REQ_INFO srcInfo = 1;
inline bool SC2S_INVENTORY_SPLIT_MERGE_REQ::has_srcinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.srcinfo_ != nullptr);
  return value;
}
inline void SC2S_INVENTORY_SPLIT_MERGE_REQ::clear_srcinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.srcinfo_ != nullptr) _impl_.srcinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& SC2S_INVENTORY_SPLIT_MERGE_REQ::_internal_srcinfo() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* p = _impl_.srcinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO&>(::DC::Packet::_SINVENTORY_ITEM_REQ_INFO_default_instance_);
}
inline const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& SC2S_INVENTORY_SPLIT_MERGE_REQ::srcinfo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DC.Packet.SC2S_INVENTORY_SPLIT_MERGE_REQ.srcInfo)
  return _internal_srcinfo();
}
inline void SC2S_INVENTORY_SPLIT_MERGE_REQ::unsafe_arena_set_allocated_srcinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.srcinfo_);
  }
  _impl_.srcinfo_ = reinterpret_cast<::DC::Packet::SINVENTORY_ITEM_REQ_INFO*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DC.Packet.SC2S_INVENTORY_SPLIT_MERGE_REQ.srcInfo)
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* SC2S_INVENTORY_SPLIT_MERGE_REQ::release_srcinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* released = _impl_.srcinfo_;
  _impl_.srcinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* SC2S_INVENTORY_SPLIT_MERGE_REQ::unsafe_arena_release_srcinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:DC.Packet.SC2S_INVENTORY_SPLIT_MERGE_REQ.srcInfo)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* temp = _impl_.srcinfo_;
  _impl_.srcinfo_ = nullptr;
  return temp;
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* SC2S_INVENTORY_SPLIT_MERGE_REQ::_internal_mutable_srcinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.srcinfo_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::DC::Packet::SINVENTORY_ITEM_REQ_INFO>(GetArena());
    _impl_.srcinfo_ = reinterpret_cast<::DC::Packet::SINVENTORY_ITEM_REQ_INFO*>(p);
  }
  return _impl_.srcinfo_;
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* SC2S_INVENTORY_SPLIT_MERGE_REQ::mutable_srcinfo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* _msg = _internal_mutable_srcinfo();
  // @@protoc_insertion_point(field_mutable:DC.Packet.SC2S_INVENTORY_SPLIT_MERGE_REQ.srcInfo)
  return _msg;
}
inline void SC2S_INVENTORY_SPLIT_MERGE_REQ::set_allocated_srcinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.srcinfo_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.srcinfo_ = reinterpret_cast<::DC::Packet::SINVENTORY_ITEM_REQ_INFO*>(value);
  // @@protoc_insertion_point(field_set_allocated:DC.Packet.SC2S_INVENTORY_SPLIT_MERGE_REQ.srcInfo)
}

// .DC.Packet.SINVENTORY_ITEM_REQ_INFO dstInfo = 2;
inline bool SC2S_INVENTORY_SPLIT_MERGE_REQ::has_dstinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dstinfo_ != nullptr);
  return value;
}
inline void SC2S_INVENTORY_SPLIT_MERGE_REQ::clear_dstinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dstinfo_ != nullptr) _impl_.dstinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& SC2S_INVENTORY_SPLIT_MERGE_REQ::_internal_dstinfo() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* p = _impl_.dstinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO&>(::DC::Packet::_SINVENTORY_ITEM_REQ_INFO_default_instance_);
}
inline const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& SC2S_INVENTORY_SPLIT_MERGE_REQ::dstinfo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DC.Packet.SC2S_INVENTORY_SPLIT_MERGE_REQ.dstInfo)
  return _internal_dstinfo();
}
inline void SC2S_INVENTORY_SPLIT_MERGE_REQ::unsafe_arena_set_allocated_dstinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dstinfo_);
  }
  _impl_.dstinfo_ = reinterpret_cast<::DC::Packet::SINVENTORY_ITEM_REQ_INFO*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DC.Packet.SC2S_INVENTORY_SPLIT_MERGE_REQ.dstInfo)
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* SC2S_INVENTORY_SPLIT_MERGE_REQ::release_dstinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* released = _impl_.dstinfo_;
  _impl_.dstinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* SC2S_INVENTORY_SPLIT_MERGE_REQ::unsafe_arena_release_dstinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:DC.Packet.SC2S_INVENTORY_SPLIT_MERGE_REQ.dstInfo)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* temp = _impl_.dstinfo_;
  _impl_.dstinfo_ = nullptr;
  return temp;
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* SC2S_INVENTORY_SPLIT_MERGE_REQ::_internal_mutable_dstinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dstinfo_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::DC::Packet::SINVENTORY_ITEM_REQ_INFO>(GetArena());
    _impl_.dstinfo_ = reinterpret_cast<::DC::Packet::SINVENTORY_ITEM_REQ_INFO*>(p);
  }
  return _impl_.dstinfo_;
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* SC2S_INVENTORY_SPLIT_MERGE_REQ::mutable_dstinfo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* _msg = _internal_mutable_dstinfo();
  // @@protoc_insertion_point(field_mutable:DC.Packet.SC2S_INVENTORY_SPLIT_MERGE_REQ.dstInfo)
  return _msg;
}
inline void SC2S_INVENTORY_SPLIT_MERGE_REQ::set_allocated_dstinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.dstinfo_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.dstinfo_ = reinterpret_cast<::DC::Packet::SINVENTORY_ITEM_REQ_INFO*>(value);
  // @@protoc_insertion_point(field_set_allocated:DC.Packet.SC2S_INVENTORY_SPLIT_MERGE_REQ.dstInfo)
}

// uint32 count = 3;
inline void SC2S_INVENTORY_SPLIT_MERGE_REQ::clear_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.count_ = 0u;
}
inline ::uint32_t SC2S_INVENTORY_SPLIT_MERGE_REQ::count() const {
  // @@protoc_insertion_point(field_get:DC.Packet.SC2S_INVENTORY_SPLIT_MERGE_REQ.count)
  return _internal_count();
}
inline void SC2S_INVENTORY_SPLIT_MERGE_REQ::set_count(::uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:DC.Packet.SC2S_INVENTORY_SPLIT_MERGE_REQ.count)
}
inline ::uint32_t SC2S_INVENTORY_SPLIT_MERGE_REQ::_internal_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.count_;
}
inline void SC2S_INVENTORY_SPLIT_MERGE_REQ::_internal_set_count(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.count_ = value;
}

// -------------------------------------------------------------------

// SS2C_INVENTORY_SPLIT_MERGE_RES

// -------------------------------------------------------------------

// SC2S_INVENTORY_SPLIT_SWAP_REQ

// .DC.Packet.SINVENTORY_ITEM_REQ_INFO srcInfo = 1;
inline bool SC2S_INVENTORY_SPLIT_SWAP_REQ::has_srcinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.srcinfo_ != nullptr);
  return value;
}
inline void SC2S_INVENTORY_SPLIT_SWAP_REQ::clear_srcinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.srcinfo_ != nullptr) _impl_.srcinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& SC2S_INVENTORY_SPLIT_SWAP_REQ::_internal_srcinfo() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* p = _impl_.srcinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO&>(::DC::Packet::_SINVENTORY_ITEM_REQ_INFO_default_instance_);
}
inline const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& SC2S_INVENTORY_SPLIT_SWAP_REQ::srcinfo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DC.Packet.SC2S_INVENTORY_SPLIT_SWAP_REQ.srcInfo)
  return _internal_srcinfo();
}
inline void SC2S_INVENTORY_SPLIT_SWAP_REQ::unsafe_arena_set_allocated_srcinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.srcinfo_);
  }
  _impl_.srcinfo_ = reinterpret_cast<::DC::Packet::SINVENTORY_ITEM_REQ_INFO*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DC.Packet.SC2S_INVENTORY_SPLIT_SWAP_REQ.srcInfo)
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* SC2S_INVENTORY_SPLIT_SWAP_REQ::release_srcinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* released = _impl_.srcinfo_;
  _impl_.srcinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* SC2S_INVENTORY_SPLIT_SWAP_REQ::unsafe_arena_release_srcinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:DC.Packet.SC2S_INVENTORY_SPLIT_SWAP_REQ.srcInfo)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* temp = _impl_.srcinfo_;
  _impl_.srcinfo_ = nullptr;
  return temp;
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* SC2S_INVENTORY_SPLIT_SWAP_REQ::_internal_mutable_srcinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.srcinfo_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::DC::Packet::SINVENTORY_ITEM_REQ_INFO>(GetArena());
    _impl_.srcinfo_ = reinterpret_cast<::DC::Packet::SINVENTORY_ITEM_REQ_INFO*>(p);
  }
  return _impl_.srcinfo_;
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* SC2S_INVENTORY_SPLIT_SWAP_REQ::mutable_srcinfo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* _msg = _internal_mutable_srcinfo();
  // @@protoc_insertion_point(field_mutable:DC.Packet.SC2S_INVENTORY_SPLIT_SWAP_REQ.srcInfo)
  return _msg;
}
inline void SC2S_INVENTORY_SPLIT_SWAP_REQ::set_allocated_srcinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.srcinfo_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.srcinfo_ = reinterpret_cast<::DC::Packet::SINVENTORY_ITEM_REQ_INFO*>(value);
  // @@protoc_insertion_point(field_set_allocated:DC.Packet.SC2S_INVENTORY_SPLIT_SWAP_REQ.srcInfo)
}

// .DC.Packet.SINVENTORY_ITEM_REQ_INFO dstInfo = 2;
inline bool SC2S_INVENTORY_SPLIT_SWAP_REQ::has_dstinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dstinfo_ != nullptr);
  return value;
}
inline void SC2S_INVENTORY_SPLIT_SWAP_REQ::clear_dstinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dstinfo_ != nullptr) _impl_.dstinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& SC2S_INVENTORY_SPLIT_SWAP_REQ::_internal_dstinfo() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* p = _impl_.dstinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO&>(::DC::Packet::_SINVENTORY_ITEM_REQ_INFO_default_instance_);
}
inline const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& SC2S_INVENTORY_SPLIT_SWAP_REQ::dstinfo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DC.Packet.SC2S_INVENTORY_SPLIT_SWAP_REQ.dstInfo)
  return _internal_dstinfo();
}
inline void SC2S_INVENTORY_SPLIT_SWAP_REQ::unsafe_arena_set_allocated_dstinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dstinfo_);
  }
  _impl_.dstinfo_ = reinterpret_cast<::DC::Packet::SINVENTORY_ITEM_REQ_INFO*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DC.Packet.SC2S_INVENTORY_SPLIT_SWAP_REQ.dstInfo)
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* SC2S_INVENTORY_SPLIT_SWAP_REQ::release_dstinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* released = _impl_.dstinfo_;
  _impl_.dstinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* SC2S_INVENTORY_SPLIT_SWAP_REQ::unsafe_arena_release_dstinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:DC.Packet.SC2S_INVENTORY_SPLIT_SWAP_REQ.dstInfo)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* temp = _impl_.dstinfo_;
  _impl_.dstinfo_ = nullptr;
  return temp;
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* SC2S_INVENTORY_SPLIT_SWAP_REQ::_internal_mutable_dstinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dstinfo_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::DC::Packet::SINVENTORY_ITEM_REQ_INFO>(GetArena());
    _impl_.dstinfo_ = reinterpret_cast<::DC::Packet::SINVENTORY_ITEM_REQ_INFO*>(p);
  }
  return _impl_.dstinfo_;
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* SC2S_INVENTORY_SPLIT_SWAP_REQ::mutable_dstinfo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* _msg = _internal_mutable_dstinfo();
  // @@protoc_insertion_point(field_mutable:DC.Packet.SC2S_INVENTORY_SPLIT_SWAP_REQ.dstInfo)
  return _msg;
}
inline void SC2S_INVENTORY_SPLIT_SWAP_REQ::set_allocated_dstinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.dstinfo_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.dstinfo_ = reinterpret_cast<::DC::Packet::SINVENTORY_ITEM_REQ_INFO*>(value);
  // @@protoc_insertion_point(field_set_allocated:DC.Packet.SC2S_INVENTORY_SPLIT_SWAP_REQ.dstInfo)
}

// uint32 count = 3;
inline void SC2S_INVENTORY_SPLIT_SWAP_REQ::clear_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.count_ = 0u;
}
inline ::uint32_t SC2S_INVENTORY_SPLIT_SWAP_REQ::count() const {
  // @@protoc_insertion_point(field_get:DC.Packet.SC2S_INVENTORY_SPLIT_SWAP_REQ.count)
  return _internal_count();
}
inline void SC2S_INVENTORY_SPLIT_SWAP_REQ::set_count(::uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:DC.Packet.SC2S_INVENTORY_SPLIT_SWAP_REQ.count)
}
inline ::uint32_t SC2S_INVENTORY_SPLIT_SWAP_REQ::_internal_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.count_;
}
inline void SC2S_INVENTORY_SPLIT_SWAP_REQ::_internal_set_count(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.count_ = value;
}

// uint32 newSlotId = 4;
inline void SC2S_INVENTORY_SPLIT_SWAP_REQ::clear_newslotid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.newslotid_ = 0u;
}
inline ::uint32_t SC2S_INVENTORY_SPLIT_SWAP_REQ::newslotid() const {
  // @@protoc_insertion_point(field_get:DC.Packet.SC2S_INVENTORY_SPLIT_SWAP_REQ.newSlotId)
  return _internal_newslotid();
}
inline void SC2S_INVENTORY_SPLIT_SWAP_REQ::set_newslotid(::uint32_t value) {
  _internal_set_newslotid(value);
  // @@protoc_insertion_point(field_set:DC.Packet.SC2S_INVENTORY_SPLIT_SWAP_REQ.newSlotId)
}
inline ::uint32_t SC2S_INVENTORY_SPLIT_SWAP_REQ::_internal_newslotid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.newslotid_;
}
inline void SC2S_INVENTORY_SPLIT_SWAP_REQ::_internal_set_newslotid(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.newslotid_ = value;
}

// uint32 newInventoryId = 5;
inline void SC2S_INVENTORY_SPLIT_SWAP_REQ::clear_newinventoryid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.newinventoryid_ = 0u;
}
inline ::uint32_t SC2S_INVENTORY_SPLIT_SWAP_REQ::newinventoryid() const {
  // @@protoc_insertion_point(field_get:DC.Packet.SC2S_INVENTORY_SPLIT_SWAP_REQ.newInventoryId)
  return _internal_newinventoryid();
}
inline void SC2S_INVENTORY_SPLIT_SWAP_REQ::set_newinventoryid(::uint32_t value) {
  _internal_set_newinventoryid(value);
  // @@protoc_insertion_point(field_set:DC.Packet.SC2S_INVENTORY_SPLIT_SWAP_REQ.newInventoryId)
}
inline ::uint32_t SC2S_INVENTORY_SPLIT_SWAP_REQ::_internal_newinventoryid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.newinventoryid_;
}
inline void SC2S_INVENTORY_SPLIT_SWAP_REQ::_internal_set_newinventoryid(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.newinventoryid_ = value;
}

// -------------------------------------------------------------------

// SS2C_INVENTORY_SPLIT_SWAP_RES

// uint64 newUniqueId = 1;
inline void SS2C_INVENTORY_SPLIT_SWAP_RES::clear_newuniqueid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.newuniqueid_ = ::uint64_t{0u};
}
inline ::uint64_t SS2C_INVENTORY_SPLIT_SWAP_RES::newuniqueid() const {
  // @@protoc_insertion_point(field_get:DC.Packet.SS2C_INVENTORY_SPLIT_SWAP_RES.newUniqueId)
  return _internal_newuniqueid();
}
inline void SS2C_INVENTORY_SPLIT_SWAP_RES::set_newuniqueid(::uint64_t value) {
  _internal_set_newuniqueid(value);
  // @@protoc_insertion_point(field_set:DC.Packet.SS2C_INVENTORY_SPLIT_SWAP_RES.newUniqueId)
}
inline ::uint64_t SS2C_INVENTORY_SPLIT_SWAP_RES::_internal_newuniqueid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.newuniqueid_;
}
inline void SS2C_INVENTORY_SPLIT_SWAP_RES::_internal_set_newuniqueid(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.newuniqueid_ = value;
}

// uint32 newInventoryId = 2;
inline void SS2C_INVENTORY_SPLIT_SWAP_RES::clear_newinventoryid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.newinventoryid_ = 0u;
}
inline ::uint32_t SS2C_INVENTORY_SPLIT_SWAP_RES::newinventoryid() const {
  // @@protoc_insertion_point(field_get:DC.Packet.SS2C_INVENTORY_SPLIT_SWAP_RES.newInventoryId)
  return _internal_newinventoryid();
}
inline void SS2C_INVENTORY_SPLIT_SWAP_RES::set_newinventoryid(::uint32_t value) {
  _internal_set_newinventoryid(value);
  // @@protoc_insertion_point(field_set:DC.Packet.SS2C_INVENTORY_SPLIT_SWAP_RES.newInventoryId)
}
inline ::uint32_t SS2C_INVENTORY_SPLIT_SWAP_RES::_internal_newinventoryid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.newinventoryid_;
}
inline void SS2C_INVENTORY_SPLIT_SWAP_RES::_internal_set_newinventoryid(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.newinventoryid_ = value;
}

// uint32 newSlotId = 3;
inline void SS2C_INVENTORY_SPLIT_SWAP_RES::clear_newslotid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.newslotid_ = 0u;
}
inline ::uint32_t SS2C_INVENTORY_SPLIT_SWAP_RES::newslotid() const {
  // @@protoc_insertion_point(field_get:DC.Packet.SS2C_INVENTORY_SPLIT_SWAP_RES.newSlotId)
  return _internal_newslotid();
}
inline void SS2C_INVENTORY_SPLIT_SWAP_RES::set_newslotid(::uint32_t value) {
  _internal_set_newslotid(value);
  // @@protoc_insertion_point(field_set:DC.Packet.SS2C_INVENTORY_SPLIT_SWAP_RES.newSlotId)
}
inline ::uint32_t SS2C_INVENTORY_SPLIT_SWAP_RES::_internal_newslotid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.newslotid_;
}
inline void SS2C_INVENTORY_SPLIT_SWAP_RES::_internal_set_newslotid(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.newslotid_ = value;
}

// -------------------------------------------------------------------

// SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ

// .DC.Packet.SINVENTORY_ITEM_REQ_INFO srcInfo = 1;
inline bool SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ::has_srcinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.srcinfo_ != nullptr);
  return value;
}
inline void SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ::clear_srcinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.srcinfo_ != nullptr) _impl_.srcinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ::_internal_srcinfo() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* p = _impl_.srcinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO&>(::DC::Packet::_SINVENTORY_ITEM_REQ_INFO_default_instance_);
}
inline const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ::srcinfo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DC.Packet.SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ.srcInfo)
  return _internal_srcinfo();
}
inline void SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ::unsafe_arena_set_allocated_srcinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.srcinfo_);
  }
  _impl_.srcinfo_ = reinterpret_cast<::DC::Packet::SINVENTORY_ITEM_REQ_INFO*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DC.Packet.SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ.srcInfo)
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ::release_srcinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* released = _impl_.srcinfo_;
  _impl_.srcinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ::unsafe_arena_release_srcinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:DC.Packet.SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ.srcInfo)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* temp = _impl_.srcinfo_;
  _impl_.srcinfo_ = nullptr;
  return temp;
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ::_internal_mutable_srcinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.srcinfo_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::DC::Packet::SINVENTORY_ITEM_REQ_INFO>(GetArena());
    _impl_.srcinfo_ = reinterpret_cast<::DC::Packet::SINVENTORY_ITEM_REQ_INFO*>(p);
  }
  return _impl_.srcinfo_;
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ::mutable_srcinfo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* _msg = _internal_mutable_srcinfo();
  // @@protoc_insertion_point(field_mutable:DC.Packet.SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ.srcInfo)
  return _msg;
}
inline void SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ::set_allocated_srcinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.srcinfo_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.srcinfo_ = reinterpret_cast<::DC::Packet::SINVENTORY_ITEM_REQ_INFO*>(value);
  // @@protoc_insertion_point(field_set_allocated:DC.Packet.SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ.srcInfo)
}

// .DC.Packet.SINVENTORY_ITEM_REQ_INFO dstInfo = 2;
inline bool SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ::has_dstinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dstinfo_ != nullptr);
  return value;
}
inline void SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ::clear_dstinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dstinfo_ != nullptr) _impl_.dstinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ::_internal_dstinfo() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* p = _impl_.dstinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO&>(::DC::Packet::_SINVENTORY_ITEM_REQ_INFO_default_instance_);
}
inline const ::DC::Packet::SINVENTORY_ITEM_REQ_INFO& SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ::dstinfo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DC.Packet.SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ.dstInfo)
  return _internal_dstinfo();
}
inline void SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ::unsafe_arena_set_allocated_dstinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dstinfo_);
  }
  _impl_.dstinfo_ = reinterpret_cast<::DC::Packet::SINVENTORY_ITEM_REQ_INFO*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DC.Packet.SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ.dstInfo)
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ::release_dstinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* released = _impl_.dstinfo_;
  _impl_.dstinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ::unsafe_arena_release_dstinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:DC.Packet.SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ.dstInfo)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* temp = _impl_.dstinfo_;
  _impl_.dstinfo_ = nullptr;
  return temp;
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ::_internal_mutable_dstinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dstinfo_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::DC::Packet::SINVENTORY_ITEM_REQ_INFO>(GetArena());
    _impl_.dstinfo_ = reinterpret_cast<::DC::Packet::SINVENTORY_ITEM_REQ_INFO*>(p);
  }
  return _impl_.dstinfo_;
}
inline ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ::mutable_dstinfo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::DC::Packet::SINVENTORY_ITEM_REQ_INFO* _msg = _internal_mutable_dstinfo();
  // @@protoc_insertion_point(field_mutable:DC.Packet.SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ.dstInfo)
  return _msg;
}
inline void SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ::set_allocated_dstinfo(::DC::Packet::SINVENTORY_ITEM_REQ_INFO* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.dstinfo_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.dstinfo_ = reinterpret_cast<::DC::Packet::SINVENTORY_ITEM_REQ_INFO*>(value);
  // @@protoc_insertion_point(field_set_allocated:DC.Packet.SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ.dstInfo)
}

// uint32 newSlotId = 3;
inline void SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ::clear_newslotid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.newslotid_ = 0u;
}
inline ::uint32_t SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ::newslotid() const {
  // @@protoc_insertion_point(field_get:DC.Packet.SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ.newSlotId)
  return _internal_newslotid();
}
inline void SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ::set_newslotid(::uint32_t value) {
  _internal_set_newslotid(value);
  // @@protoc_insertion_point(field_set:DC.Packet.SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ.newSlotId)
}
inline ::uint32_t SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ::_internal_newslotid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.newslotid_;
}
inline void SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ::_internal_set_newslotid(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.newslotid_ = value;
}

// uint32 newInventoryId = 4;
inline void SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ::clear_newinventoryid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.newinventoryid_ = 0u;
}
inline ::uint32_t SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ::newinventoryid() const {
  // @@protoc_insertion_point(field_get:DC.Packet.SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ.newInventoryId)
  return _internal_newinventoryid();
}
inline void SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ::set_newinventoryid(::uint32_t value) {
  _internal_set_newinventoryid(value);
  // @@protoc_insertion_point(field_set:DC.Packet.SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ.newInventoryId)
}
inline ::uint32_t SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ::_internal_newinventoryid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.newinventoryid_;
}
inline void SC2S_INVENTORY_TWO_HANDED_WEAPON_SWAP_REQ::_internal_set_newinventoryid(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.newinventoryid_ = value;
}

// -------------------------------------------------------------------

// SS2C_INVENTORY_TWO_HANDED_WEAPON_SWAP_RES

// -------------------------------------------------------------------

// SC2S_INVENTORY_SINGLE_UPDATE_REQ

// uint32 singleUpdateFlag = 1;
inline void SC2S_INVENTORY_SINGLE_UPDATE_REQ::clear_singleupdateflag() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.singleupdateflag_ = 0u;
}
inline ::uint32_t SC2S_INVENTORY_SINGLE_UPDATE_REQ::singleupdateflag() const {
  // @@protoc_insertion_point(field_get:DC.Packet.SC2S_INVENTORY_SINGLE_UPDATE_REQ.singleUpdateFlag)
  return _internal_singleupdateflag();
}
inline void SC2S_INVENTORY_SINGLE_UPDATE_REQ::set_singleupdateflag(::uint32_t value) {
  _internal_set_singleupdateflag(value);
  // @@protoc_insertion_point(field_set:DC.Packet.SC2S_INVENTORY_SINGLE_UPDATE_REQ.singleUpdateFlag)
}
inline ::uint32_t SC2S_INVENTORY_SINGLE_UPDATE_REQ::_internal_singleupdateflag() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.singleupdateflag_;
}
inline void SC2S_INVENTORY_SINGLE_UPDATE_REQ::_internal_set_singleupdateflag(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.singleupdateflag_ = value;
}

// repeated .DC.Packet.SItem oldItem = 2;
inline int SC2S_INVENTORY_SINGLE_UPDATE_REQ::_internal_olditem_size() const {
  return _internal_olditem().size();
}
inline int SC2S_INVENTORY_SINGLE_UPDATE_REQ::olditem_size() const {
  return _internal_olditem_size();
}
inline ::DC::Packet::SItem* SC2S_INVENTORY_SINGLE_UPDATE_REQ::mutable_olditem(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:DC.Packet.SC2S_INVENTORY_SINGLE_UPDATE_REQ.oldItem)
  return _internal_mutable_olditem()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>* SC2S_INVENTORY_SINGLE_UPDATE_REQ::mutable_olditem()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:DC.Packet.SC2S_INVENTORY_SINGLE_UPDATE_REQ.oldItem)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_olditem();
}
inline const ::DC::Packet::SItem& SC2S_INVENTORY_SINGLE_UPDATE_REQ::olditem(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DC.Packet.SC2S_INVENTORY_SINGLE_UPDATE_REQ.oldItem)
  return _internal_olditem().Get(index);
}
inline ::DC::Packet::SItem* SC2S_INVENTORY_SINGLE_UPDATE_REQ::add_olditem() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::DC::Packet::SItem* _add = _internal_mutable_olditem()->Add();
  // @@protoc_insertion_point(field_add:DC.Packet.SC2S_INVENTORY_SINGLE_UPDATE_REQ.oldItem)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>& SC2S_INVENTORY_SINGLE_UPDATE_REQ::olditem() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:DC.Packet.SC2S_INVENTORY_SINGLE_UPDATE_REQ.oldItem)
  return _internal_olditem();
}
inline const ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>&
SC2S_INVENTORY_SINGLE_UPDATE_REQ::_internal_olditem() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.olditem_;
}
inline ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>*
SC2S_INVENTORY_SINGLE_UPDATE_REQ::_internal_mutable_olditem() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.olditem_;
}

// repeated .DC.Packet.SItem newItem = 3;
inline int SC2S_INVENTORY_SINGLE_UPDATE_REQ::_internal_newitem_size() const {
  return _internal_newitem().size();
}
inline int SC2S_INVENTORY_SINGLE_UPDATE_REQ::newitem_size() const {
  return _internal_newitem_size();
}
inline ::DC::Packet::SItem* SC2S_INVENTORY_SINGLE_UPDATE_REQ::mutable_newitem(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:DC.Packet.SC2S_INVENTORY_SINGLE_UPDATE_REQ.newItem)
  return _internal_mutable_newitem()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>* SC2S_INVENTORY_SINGLE_UPDATE_REQ::mutable_newitem()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:DC.Packet.SC2S_INVENTORY_SINGLE_UPDATE_REQ.newItem)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_newitem();
}
inline const ::DC::Packet::SItem& SC2S_INVENTORY_SINGLE_UPDATE_REQ::newitem(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DC.Packet.SC2S_INVENTORY_SINGLE_UPDATE_REQ.newItem)
  return _internal_newitem().Get(index);
}
inline ::DC::Packet::SItem* SC2S_INVENTORY_SINGLE_UPDATE_REQ::add_newitem() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::DC::Packet::SItem* _add = _internal_mutable_newitem()->Add();
  // @@protoc_insertion_point(field_add:DC.Packet.SC2S_INVENTORY_SINGLE_UPDATE_REQ.newItem)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>& SC2S_INVENTORY_SINGLE_UPDATE_REQ::newitem() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:DC.Packet.SC2S_INVENTORY_SINGLE_UPDATE_REQ.newItem)
  return _internal_newitem();
}
inline const ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>&
SC2S_INVENTORY_SINGLE_UPDATE_REQ::_internal_newitem() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.newitem_;
}
inline ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>*
SC2S_INVENTORY_SINGLE_UPDATE_REQ::_internal_mutable_newitem() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.newitem_;
}

// -------------------------------------------------------------------

// SS2C_INVENTORY_SINGLE_UPDATE_RES

// uint32 result = 1;
inline void SS2C_INVENTORY_SINGLE_UPDATE_RES::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = 0u;
}
inline ::uint32_t SS2C_INVENTORY_SINGLE_UPDATE_RES::result() const {
  // @@protoc_insertion_point(field_get:DC.Packet.SS2C_INVENTORY_SINGLE_UPDATE_RES.result)
  return _internal_result();
}
inline void SS2C_INVENTORY_SINGLE_UPDATE_RES::set_result(::uint32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:DC.Packet.SS2C_INVENTORY_SINGLE_UPDATE_RES.result)
}
inline ::uint32_t SS2C_INVENTORY_SINGLE_UPDATE_RES::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.result_;
}
inline void SS2C_INVENTORY_SINGLE_UPDATE_RES::_internal_set_result(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = value;
}

// repeated .DC.Packet.SItem oldItem = 2;
inline int SS2C_INVENTORY_SINGLE_UPDATE_RES::_internal_olditem_size() const {
  return _internal_olditem().size();
}
inline int SS2C_INVENTORY_SINGLE_UPDATE_RES::olditem_size() const {
  return _internal_olditem_size();
}
inline ::DC::Packet::SItem* SS2C_INVENTORY_SINGLE_UPDATE_RES::mutable_olditem(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:DC.Packet.SS2C_INVENTORY_SINGLE_UPDATE_RES.oldItem)
  return _internal_mutable_olditem()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>* SS2C_INVENTORY_SINGLE_UPDATE_RES::mutable_olditem()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:DC.Packet.SS2C_INVENTORY_SINGLE_UPDATE_RES.oldItem)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_olditem();
}
inline const ::DC::Packet::SItem& SS2C_INVENTORY_SINGLE_UPDATE_RES::olditem(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DC.Packet.SS2C_INVENTORY_SINGLE_UPDATE_RES.oldItem)
  return _internal_olditem().Get(index);
}
inline ::DC::Packet::SItem* SS2C_INVENTORY_SINGLE_UPDATE_RES::add_olditem() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::DC::Packet::SItem* _add = _internal_mutable_olditem()->Add();
  // @@protoc_insertion_point(field_add:DC.Packet.SS2C_INVENTORY_SINGLE_UPDATE_RES.oldItem)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>& SS2C_INVENTORY_SINGLE_UPDATE_RES::olditem() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:DC.Packet.SS2C_INVENTORY_SINGLE_UPDATE_RES.oldItem)
  return _internal_olditem();
}
inline const ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>&
SS2C_INVENTORY_SINGLE_UPDATE_RES::_internal_olditem() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.olditem_;
}
inline ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>*
SS2C_INVENTORY_SINGLE_UPDATE_RES::_internal_mutable_olditem() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.olditem_;
}

// repeated .DC.Packet.SItem newItem = 3;
inline int SS2C_INVENTORY_SINGLE_UPDATE_RES::_internal_newitem_size() const {
  return _internal_newitem().size();
}
inline int SS2C_INVENTORY_SINGLE_UPDATE_RES::newitem_size() const {
  return _internal_newitem_size();
}
inline ::DC::Packet::SItem* SS2C_INVENTORY_SINGLE_UPDATE_RES::mutable_newitem(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:DC.Packet.SS2C_INVENTORY_SINGLE_UPDATE_RES.newItem)
  return _internal_mutable_newitem()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>* SS2C_INVENTORY_SINGLE_UPDATE_RES::mutable_newitem()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:DC.Packet.SS2C_INVENTORY_SINGLE_UPDATE_RES.newItem)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_newitem();
}
inline const ::DC::Packet::SItem& SS2C_INVENTORY_SINGLE_UPDATE_RES::newitem(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DC.Packet.SS2C_INVENTORY_SINGLE_UPDATE_RES.newItem)
  return _internal_newitem().Get(index);
}
inline ::DC::Packet::SItem* SS2C_INVENTORY_SINGLE_UPDATE_RES::add_newitem() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::DC::Packet::SItem* _add = _internal_mutable_newitem()->Add();
  // @@protoc_insertion_point(field_add:DC.Packet.SS2C_INVENTORY_SINGLE_UPDATE_RES.newItem)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>& SS2C_INVENTORY_SINGLE_UPDATE_RES::newitem() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:DC.Packet.SS2C_INVENTORY_SINGLE_UPDATE_RES.newItem)
  return _internal_newitem();
}
inline const ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>&
SS2C_INVENTORY_SINGLE_UPDATE_RES::_internal_newitem() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.newitem_;
}
inline ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>*
SS2C_INVENTORY_SINGLE_UPDATE_RES::_internal_mutable_newitem() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.newitem_;
}

// -------------------------------------------------------------------

// SC2S_STORAGE_INFO_REQ

// uint32 isRefresh = 1;
inline void SC2S_STORAGE_INFO_REQ::clear_isrefresh() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.isrefresh_ = 0u;
}
inline ::uint32_t SC2S_STORAGE_INFO_REQ::isrefresh() const {
  // @@protoc_insertion_point(field_get:DC.Packet.SC2S_STORAGE_INFO_REQ.isRefresh)
  return _internal_isrefresh();
}
inline void SC2S_STORAGE_INFO_REQ::set_isrefresh(::uint32_t value) {
  _internal_set_isrefresh(value);
  // @@protoc_insertion_point(field_set:DC.Packet.SC2S_STORAGE_INFO_REQ.isRefresh)
}
inline ::uint32_t SC2S_STORAGE_INFO_REQ::_internal_isrefresh() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.isrefresh_;
}
inline void SC2S_STORAGE_INFO_REQ::_internal_set_isrefresh(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.isrefresh_ = value;
}

// -------------------------------------------------------------------

// SS2C_STORAGE_INFO_RES

// uint32 result = 1;
inline void SS2C_STORAGE_INFO_RES::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = 0u;
}
inline ::uint32_t SS2C_STORAGE_INFO_RES::result() const {
  // @@protoc_insertion_point(field_get:DC.Packet.SS2C_STORAGE_INFO_RES.result)
  return _internal_result();
}
inline void SS2C_STORAGE_INFO_RES::set_result(::uint32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:DC.Packet.SS2C_STORAGE_INFO_RES.result)
}
inline ::uint32_t SS2C_STORAGE_INFO_RES::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.result_;
}
inline void SS2C_STORAGE_INFO_RES::_internal_set_result(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = value;
}

// repeated .DC.Packet.SItem storageItems = 2;
inline int SS2C_STORAGE_INFO_RES::_internal_storageitems_size() const {
  return _internal_storageitems().size();
}
inline int SS2C_STORAGE_INFO_RES::storageitems_size() const {
  return _internal_storageitems_size();
}
inline ::DC::Packet::SItem* SS2C_STORAGE_INFO_RES::mutable_storageitems(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:DC.Packet.SS2C_STORAGE_INFO_RES.storageItems)
  return _internal_mutable_storageitems()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>* SS2C_STORAGE_INFO_RES::mutable_storageitems()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:DC.Packet.SS2C_STORAGE_INFO_RES.storageItems)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_storageitems();
}
inline const ::DC::Packet::SItem& SS2C_STORAGE_INFO_RES::storageitems(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DC.Packet.SS2C_STORAGE_INFO_RES.storageItems)
  return _internal_storageitems().Get(index);
}
inline ::DC::Packet::SItem* SS2C_STORAGE_INFO_RES::add_storageitems() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::DC::Packet::SItem* _add = _internal_mutable_storageitems()->Add();
  // @@protoc_insertion_point(field_add:DC.Packet.SS2C_STORAGE_INFO_RES.storageItems)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>& SS2C_STORAGE_INFO_RES::storageitems() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:DC.Packet.SS2C_STORAGE_INFO_RES.storageItems)
  return _internal_storageitems();
}
inline const ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>&
SS2C_STORAGE_INFO_RES::_internal_storageitems() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.storageitems_;
}
inline ::google::protobuf::RepeatedPtrField<::DC::Packet::SItem>*
SS2C_STORAGE_INFO_RES::_internal_mutable_storageitems() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.storageitems_;
}

// -------------------------------------------------------------------

// SC2S_INVENTORY_EXPAND_STORAGE_REQ

// int32 buyInventoryId = 1;
inline void SC2S_INVENTORY_EXPAND_STORAGE_REQ::clear_buyinventoryid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.buyinventoryid_ = 0;
}
inline ::int32_t SC2S_INVENTORY_EXPAND_STORAGE_REQ::buyinventoryid() const {
  // @@protoc_insertion_point(field_get:DC.Packet.SC2S_INVENTORY_EXPAND_STORAGE_REQ.buyInventoryId)
  return _internal_buyinventoryid();
}
inline void SC2S_INVENTORY_EXPAND_STORAGE_REQ::set_buyinventoryid(::int32_t value) {
  _internal_set_buyinventoryid(value);
  // @@protoc_insertion_point(field_set:DC.Packet.SC2S_INVENTORY_EXPAND_STORAGE_REQ.buyInventoryId)
}
inline ::int32_t SC2S_INVENTORY_EXPAND_STORAGE_REQ::_internal_buyinventoryid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.buyinventoryid_;
}
inline void SC2S_INVENTORY_EXPAND_STORAGE_REQ::_internal_set_buyinventoryid(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.buyinventoryid_ = value;
}

// -------------------------------------------------------------------

// SS2C_INVENTORY_EXPAND_STORAGE_RES

// uint32 result = 1;
inline void SS2C_INVENTORY_EXPAND_STORAGE_RES::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = 0u;
}
inline ::uint32_t SS2C_INVENTORY_EXPAND_STORAGE_RES::result() const {
  // @@protoc_insertion_point(field_get:DC.Packet.SS2C_INVENTORY_EXPAND_STORAGE_RES.result)
  return _internal_result();
}
inline void SS2C_INVENTORY_EXPAND_STORAGE_RES::set_result(::uint32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:DC.Packet.SS2C_INVENTORY_EXPAND_STORAGE_RES.result)
}
inline ::uint32_t SS2C_INVENTORY_EXPAND_STORAGE_RES::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.result_;
}
inline void SS2C_INVENTORY_EXPAND_STORAGE_RES::_internal_set_result(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace Packet
}  // namespace DC


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::DC::Packet::SS2C_INVENTORY_INFO_RES_RESULT_INVENTORY_INFO_INFO> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::DC::Packet::SS2C_INVENTORY_INFO_RES_RESULT_INVENTORY_INFO_INFO>() {
  return ::DC::Packet::SS2C_INVENTORY_INFO_RES_RESULT_INVENTORY_INFO_INFO_descriptor();
}
template <>
struct is_proto_enum<::DC::Packet::SS2C_INVENTORY_ALL_UPDATE_RES_RESULT_INVENTORY_UPDATE> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::DC::Packet::SS2C_INVENTORY_ALL_UPDATE_RES_RESULT_INVENTORY_UPDATE>() {
  return ::DC::Packet::SS2C_INVENTORY_ALL_UPDATE_RES_RESULT_INVENTORY_UPDATE_descriptor();
}
template <>
struct is_proto_enum<::DC::Packet::SS2C_INVENTORY_SINGLE_UPDATE_RES_RESULT_INVENTORY_SINGLE_UPDATE> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::DC::Packet::SS2C_INVENTORY_SINGLE_UPDATE_RES_RESULT_INVENTORY_SINGLE_UPDATE>() {
  return ::DC::Packet::SS2C_INVENTORY_SINGLE_UPDATE_RES_RESULT_INVENTORY_SINGLE_UPDATE_descriptor();
}
template <>
struct is_proto_enum<::DC::Packet::SS2C_STORAGE_INFO_RES_RESULT_STORAGE_INFO> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::DC::Packet::SS2C_STORAGE_INFO_RES_RESULT_STORAGE_INFO>() {
  return ::DC::Packet::SS2C_STORAGE_INFO_RES_RESULT_STORAGE_INFO_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_Inventory_2eproto_2epb_2eh
