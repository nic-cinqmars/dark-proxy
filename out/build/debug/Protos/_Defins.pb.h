// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: _Defins.proto
// Protobuf C++ Version: 5.29.0-dev

#ifndef GOOGLE_PROTOBUF_INCLUDED__5fDefins_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED__5fDefins_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029000
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT__5fDefins_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct__5fDefins_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table__5fDefins_2eproto;
namespace DC {
namespace Packet {
namespace Defines {
class Define_Account;
struct Define_AccountDefaultTypeInternal;
extern Define_AccountDefaultTypeInternal _Define_Account_default_instance_;
class Define_Character;
struct Define_CharacterDefaultTypeInternal;
extern Define_CharacterDefaultTypeInternal _Define_Character_default_instance_;
class Define_Chat;
struct Define_ChatDefaultTypeInternal;
extern Define_ChatDefaultTypeInternal _Define_Chat_default_instance_;
class Define_Class;
struct Define_ClassDefaultTypeInternal;
extern Define_ClassDefaultTypeInternal _Define_Class_default_instance_;
class Define_Common;
struct Define_CommonDefaultTypeInternal;
extern Define_CommonDefaultTypeInternal _Define_Common_default_instance_;
class Define_Coupon;
struct Define_CouponDefaultTypeInternal;
extern Define_CouponDefaultTypeInternal _Define_Coupon_default_instance_;
class Define_Equipment;
struct Define_EquipmentDefaultTypeInternal;
extern Define_EquipmentDefaultTypeInternal _Define_Equipment_default_instance_;
class Define_Game;
struct Define_GameDefaultTypeInternal;
extern Define_GameDefaultTypeInternal _Define_Game_default_instance_;
class Define_Hack;
struct Define_HackDefaultTypeInternal;
extern Define_HackDefaultTypeInternal _Define_Hack_default_instance_;
class Define_Item;
struct Define_ItemDefaultTypeInternal;
extern Define_ItemDefaultTypeInternal _Define_Item_default_instance_;
class Define_Karma;
struct Define_KarmaDefaultTypeInternal;
extern Define_KarmaDefaultTypeInternal _Define_Karma_default_instance_;
class Define_Log;
struct Define_LogDefaultTypeInternal;
extern Define_LogDefaultTypeInternal _Define_Log_default_instance_;
class Define_Match;
struct Define_MatchDefaultTypeInternal;
extern Define_MatchDefaultTypeInternal _Define_Match_default_instance_;
class Define_Message;
struct Define_MessageDefaultTypeInternal;
extern Define_MessageDefaultTypeInternal _Define_Message_default_instance_;
class Define_Party;
struct Define_PartyDefaultTypeInternal;
extern Define_PartyDefaultTypeInternal _Define_Party_default_instance_;
class Define_Report;
struct Define_ReportDefaultTypeInternal;
extern Define_ReportDefaultTypeInternal _Define_Report_default_instance_;
class Define_Reward;
struct Define_RewardDefaultTypeInternal;
extern Define_RewardDefaultTypeInternal _Define_Reward_default_instance_;
class Define_Shop;
struct Define_ShopDefaultTypeInternal;
extern Define_ShopDefaultTypeInternal _Define_Shop_default_instance_;
class Define_Stat;
struct Define_StatDefaultTypeInternal;
extern Define_StatDefaultTypeInternal _Define_Stat_default_instance_;
class Define_Trade;
struct Define_TradeDefaultTypeInternal;
extern Define_TradeDefaultTypeInternal _Define_Trade_default_instance_;
class Operate;
struct OperateDefaultTypeInternal;
extern OperateDefaultTypeInternal _Operate_default_instance_;
}  // namespace Defines
}  // namespace Packet
}  // namespace DC
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace DC {
namespace Packet {
namespace Defines {
enum Define_Account_LengthText : int {
  Define_Account_LengthText_NONE = 0,
  Define_Account_LengthText_MIN = 2,
  Define_Account_LengthText_MAX = 20,
  Define_Account_LengthText_Define_Account_LengthText_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Define_Account_LengthText_Define_Account_LengthText_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Define_Account_LengthText_IsValid(int value);
extern const uint32_t Define_Account_LengthText_internal_data_[];
constexpr Define_Account_LengthText Define_Account_LengthText_LengthText_MIN = static_cast<Define_Account_LengthText>(0);
constexpr Define_Account_LengthText Define_Account_LengthText_LengthText_MAX = static_cast<Define_Account_LengthText>(20);
constexpr int Define_Account_LengthText_LengthText_ARRAYSIZE = 20 + 1;
const ::google::protobuf::EnumDescriptor*
Define_Account_LengthText_descriptor();
template <typename T>
const std::string& Define_Account_LengthText_Name(T value) {
  static_assert(std::is_same<T, Define_Account_LengthText>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to LengthText_Name().");
  return ::google::protobuf::internal::NameOfEnum(Define_Account_LengthText_descriptor(), value);
}
inline bool Define_Account_LengthText_Parse(absl::string_view name, Define_Account_LengthText* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Define_Account_LengthText>(
      Define_Account_LengthText_descriptor(), name, value);
}
enum Define_Account_CurrencyType : int {
  Define_Account_CurrencyType_CURRENCY_NONE = 0,
  Define_Account_CurrencyType_BLUE_STONE_SHARD = 1,
  Define_Account_CurrencyType_RED_STONE_SHARD = 2,
  Define_Account_CurrencyType_Define_Account_CurrencyType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Define_Account_CurrencyType_Define_Account_CurrencyType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Define_Account_CurrencyType_IsValid(int value);
extern const uint32_t Define_Account_CurrencyType_internal_data_[];
constexpr Define_Account_CurrencyType Define_Account_CurrencyType_CurrencyType_MIN = static_cast<Define_Account_CurrencyType>(0);
constexpr Define_Account_CurrencyType Define_Account_CurrencyType_CurrencyType_MAX = static_cast<Define_Account_CurrencyType>(2);
constexpr int Define_Account_CurrencyType_CurrencyType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
Define_Account_CurrencyType_descriptor();
template <typename T>
const std::string& Define_Account_CurrencyType_Name(T value) {
  static_assert(std::is_same<T, Define_Account_CurrencyType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CurrencyType_Name().");
  return Define_Account_CurrencyType_Name(static_cast<Define_Account_CurrencyType>(value));
}
template <>
inline const std::string& Define_Account_CurrencyType_Name(Define_Account_CurrencyType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Define_Account_CurrencyType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool Define_Account_CurrencyType_Parse(absl::string_view name, Define_Account_CurrencyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Define_Account_CurrencyType>(
      Define_Account_CurrencyType_descriptor(), name, value);
}
enum Define_Account_LoginType : int {
  Define_Account_LoginType_LOGIN_TYPE_NONE = 0,
  Define_Account_LoginType_STEAM = 1,
  Define_Account_LoginType_EPIC = 2,
  Define_Account_LoginType_IRONMACE = 3,
  Define_Account_LoginType_CHAF = 4,
  Define_Account_LoginType_MICROSOFT = 5,
  Define_Account_LoginType_Define_Account_LoginType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Define_Account_LoginType_Define_Account_LoginType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Define_Account_LoginType_IsValid(int value);
extern const uint32_t Define_Account_LoginType_internal_data_[];
constexpr Define_Account_LoginType Define_Account_LoginType_LoginType_MIN = static_cast<Define_Account_LoginType>(0);
constexpr Define_Account_LoginType Define_Account_LoginType_LoginType_MAX = static_cast<Define_Account_LoginType>(5);
constexpr int Define_Account_LoginType_LoginType_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
Define_Account_LoginType_descriptor();
template <typename T>
const std::string& Define_Account_LoginType_Name(T value) {
  static_assert(std::is_same<T, Define_Account_LoginType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to LoginType_Name().");
  return Define_Account_LoginType_Name(static_cast<Define_Account_LoginType>(value));
}
template <>
inline const std::string& Define_Account_LoginType_Name(Define_Account_LoginType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Define_Account_LoginType_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool Define_Account_LoginType_Parse(absl::string_view name, Define_Account_LoginType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Define_Account_LoginType>(
      Define_Account_LoginType_descriptor(), name, value);
}
enum Define_Account_AccountStatus : int {
  Define_Account_AccountStatus_ACCOUNT_STATUS_NONE = 0,
  Define_Account_AccountStatus_ACCOUNT_STATUS_SQUIRE = 1,
  Define_Account_AccountStatus_ACCOUNT_STATUS_LEGEND = 2,
  Define_Account_AccountStatus_Define_Account_AccountStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Define_Account_AccountStatus_Define_Account_AccountStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Define_Account_AccountStatus_IsValid(int value);
extern const uint32_t Define_Account_AccountStatus_internal_data_[];
constexpr Define_Account_AccountStatus Define_Account_AccountStatus_AccountStatus_MIN = static_cast<Define_Account_AccountStatus>(0);
constexpr Define_Account_AccountStatus Define_Account_AccountStatus_AccountStatus_MAX = static_cast<Define_Account_AccountStatus>(2);
constexpr int Define_Account_AccountStatus_AccountStatus_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
Define_Account_AccountStatus_descriptor();
template <typename T>
const std::string& Define_Account_AccountStatus_Name(T value) {
  static_assert(std::is_same<T, Define_Account_AccountStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AccountStatus_Name().");
  return Define_Account_AccountStatus_Name(static_cast<Define_Account_AccountStatus>(value));
}
template <>
inline const std::string& Define_Account_AccountStatus_Name(Define_Account_AccountStatus value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Define_Account_AccountStatus_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool Define_Account_AccountStatus_Parse(absl::string_view name, Define_Account_AccountStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Define_Account_AccountStatus>(
      Define_Account_AccountStatus_descriptor(), name, value);
}
enum Define_Character_LengthNickName : int {
  Define_Character_LengthNickName_NONE = 0,
  Define_Character_LengthNickName_MIN = 2,
  Define_Character_LengthNickName_MAX = 20,
  Define_Character_LengthNickName_Define_Character_LengthNickName_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Define_Character_LengthNickName_Define_Character_LengthNickName_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Define_Character_LengthNickName_IsValid(int value);
extern const uint32_t Define_Character_LengthNickName_internal_data_[];
constexpr Define_Character_LengthNickName Define_Character_LengthNickName_LengthNickName_MIN = static_cast<Define_Character_LengthNickName>(0);
constexpr Define_Character_LengthNickName Define_Character_LengthNickName_LengthNickName_MAX = static_cast<Define_Character_LengthNickName>(20);
constexpr int Define_Character_LengthNickName_LengthNickName_ARRAYSIZE = 20 + 1;
const ::google::protobuf::EnumDescriptor*
Define_Character_LengthNickName_descriptor();
template <typename T>
const std::string& Define_Character_LengthNickName_Name(T value) {
  static_assert(std::is_same<T, Define_Character_LengthNickName>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to LengthNickName_Name().");
  return ::google::protobuf::internal::NameOfEnum(Define_Character_LengthNickName_descriptor(), value);
}
inline bool Define_Character_LengthNickName_Parse(absl::string_view name, Define_Character_LengthNickName* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Define_Character_LengthNickName>(
      Define_Character_LengthNickName_descriptor(), name, value);
}
enum Define_Character_Limit : int {
  Define_Character_Limit_NONE_Limit = 0,
  Define_Character_Limit_MAX_COUNT = 8,
  Define_Character_Limit_Define_Character_Limit_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Define_Character_Limit_Define_Character_Limit_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Define_Character_Limit_IsValid(int value);
extern const uint32_t Define_Character_Limit_internal_data_[];
constexpr Define_Character_Limit Define_Character_Limit_Limit_MIN = static_cast<Define_Character_Limit>(0);
constexpr Define_Character_Limit Define_Character_Limit_Limit_MAX = static_cast<Define_Character_Limit>(8);
constexpr int Define_Character_Limit_Limit_ARRAYSIZE = 8 + 1;
const ::google::protobuf::EnumDescriptor*
Define_Character_Limit_descriptor();
template <typename T>
const std::string& Define_Character_Limit_Name(T value) {
  static_assert(std::is_same<T, Define_Character_Limit>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Limit_Name().");
  return Define_Character_Limit_Name(static_cast<Define_Character_Limit>(value));
}
template <>
inline const std::string& Define_Character_Limit_Name(Define_Character_Limit value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Define_Character_Limit_descriptor,
                                                 0, 8>(
      static_cast<int>(value));
}
inline bool Define_Character_Limit_Parse(absl::string_view name, Define_Character_Limit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Define_Character_Limit>(
      Define_Character_Limit_descriptor(), name, value);
}
enum Define_Party_MemberCountLimit : int {
  Define_Party_MemberCountLimit_NONE = 0,
  Define_Party_MemberCountLimit_MAX = 3,
  Define_Party_MemberCountLimit_MIN = 1,
  Define_Party_MemberCountLimit_Define_Party_MemberCountLimit_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Define_Party_MemberCountLimit_Define_Party_MemberCountLimit_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Define_Party_MemberCountLimit_IsValid(int value);
extern const uint32_t Define_Party_MemberCountLimit_internal_data_[];
constexpr Define_Party_MemberCountLimit Define_Party_MemberCountLimit_MemberCountLimit_MIN = static_cast<Define_Party_MemberCountLimit>(0);
constexpr Define_Party_MemberCountLimit Define_Party_MemberCountLimit_MemberCountLimit_MAX = static_cast<Define_Party_MemberCountLimit>(3);
constexpr int Define_Party_MemberCountLimit_MemberCountLimit_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
Define_Party_MemberCountLimit_descriptor();
template <typename T>
const std::string& Define_Party_MemberCountLimit_Name(T value) {
  static_assert(std::is_same<T, Define_Party_MemberCountLimit>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MemberCountLimit_Name().");
  return Define_Party_MemberCountLimit_Name(static_cast<Define_Party_MemberCountLimit>(value));
}
template <>
inline const std::string& Define_Party_MemberCountLimit_Name(Define_Party_MemberCountLimit value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Define_Party_MemberCountLimit_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool Define_Party_MemberCountLimit_Parse(absl::string_view name, Define_Party_MemberCountLimit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Define_Party_MemberCountLimit>(
      Define_Party_MemberCountLimit_descriptor(), name, value);
}
enum Define_Item_InventoryId : int {
  Define_Item_InventoryId_NONE = 0,
  Define_Item_InventoryId_CHEST = 1,
  Define_Item_InventoryId_BAG = 2,
  Define_Item_InventoryId_EQUIPMENT = 3,
  Define_Item_InventoryId_STORAGE = 4,
  Define_Item_InventoryId_PURCHASED_STORAGE_0 = 5,
  Define_Item_InventoryId_PURCHASED_STORAGE_1 = 6,
  Define_Item_InventoryId_PURCHASED_STORAGE_2 = 7,
  Define_Item_InventoryId_PURCHASED_STORAGE_3 = 8,
  Define_Item_InventoryId_PURCHASED_STORAGE_4 = 9,
  Define_Item_InventoryId_SHARED_STASH_0 = 20,
  Define_Item_InventoryId_MAX = 30,
  Define_Item_InventoryId_Define_Item_InventoryId_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Define_Item_InventoryId_Define_Item_InventoryId_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Define_Item_InventoryId_IsValid(int value);
extern const uint32_t Define_Item_InventoryId_internal_data_[];
constexpr Define_Item_InventoryId Define_Item_InventoryId_InventoryId_MIN = static_cast<Define_Item_InventoryId>(0);
constexpr Define_Item_InventoryId Define_Item_InventoryId_InventoryId_MAX = static_cast<Define_Item_InventoryId>(30);
constexpr int Define_Item_InventoryId_InventoryId_ARRAYSIZE = 30 + 1;
const ::google::protobuf::EnumDescriptor*
Define_Item_InventoryId_descriptor();
template <typename T>
const std::string& Define_Item_InventoryId_Name(T value) {
  static_assert(std::is_same<T, Define_Item_InventoryId>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to InventoryId_Name().");
  return ::google::protobuf::internal::NameOfEnum(Define_Item_InventoryId_descriptor(), value);
}
inline bool Define_Item_InventoryId_Parse(absl::string_view name, Define_Item_InventoryId* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Define_Item_InventoryId>(
      Define_Item_InventoryId_descriptor(), name, value);
}
enum Define_Item_rarityType : int {
  Define_Item_rarityType_NONE_RARITY_TYPE = 0,
  Define_Item_rarityType_POOR = 1,
  Define_Item_rarityType_COMMON = 2,
  Define_Item_rarityType_UNCOMMON = 3,
  Define_Item_rarityType_RARE = 4,
  Define_Item_rarityType_EPIC = 5,
  Define_Item_rarityType_LEGEND = 6,
  Define_Item_rarityType_UNIQUE = 7,
  Define_Item_rarityType_Define_Item_rarityType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Define_Item_rarityType_Define_Item_rarityType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Define_Item_rarityType_IsValid(int value);
extern const uint32_t Define_Item_rarityType_internal_data_[];
constexpr Define_Item_rarityType Define_Item_rarityType_rarityType_MIN = static_cast<Define_Item_rarityType>(0);
constexpr Define_Item_rarityType Define_Item_rarityType_rarityType_MAX = static_cast<Define_Item_rarityType>(7);
constexpr int Define_Item_rarityType_rarityType_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor*
Define_Item_rarityType_descriptor();
template <typename T>
const std::string& Define_Item_rarityType_Name(T value) {
  static_assert(std::is_same<T, Define_Item_rarityType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to rarityType_Name().");
  return Define_Item_rarityType_Name(static_cast<Define_Item_rarityType>(value));
}
template <>
inline const std::string& Define_Item_rarityType_Name(Define_Item_rarityType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Define_Item_rarityType_descriptor,
                                                 0, 7>(
      static_cast<int>(value));
}
inline bool Define_Item_rarityType_Parse(absl::string_view name, Define_Item_rarityType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Define_Item_rarityType>(
      Define_Item_rarityType_descriptor(), name, value);
}
enum Define_Item_LootState : int {
  Define_Item_LootState_NONE_SOURCE = 0,
  Define_Item_LootState_SUPPLIED = 1,
  Define_Item_LootState_LOOTED = 2,
  Define_Item_LootState_HANDLED = 3,
  Define_Item_LootState_CRAFT = 4,
  Define_Item_LootState_ALLY = 5,
  Define_Item_LootState_Define_Item_LootState_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Define_Item_LootState_Define_Item_LootState_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Define_Item_LootState_IsValid(int value);
extern const uint32_t Define_Item_LootState_internal_data_[];
constexpr Define_Item_LootState Define_Item_LootState_LootState_MIN = static_cast<Define_Item_LootState>(0);
constexpr Define_Item_LootState Define_Item_LootState_LootState_MAX = static_cast<Define_Item_LootState>(5);
constexpr int Define_Item_LootState_LootState_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
Define_Item_LootState_descriptor();
template <typename T>
const std::string& Define_Item_LootState_Name(T value) {
  static_assert(std::is_same<T, Define_Item_LootState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to LootState_Name().");
  return Define_Item_LootState_Name(static_cast<Define_Item_LootState>(value));
}
template <>
inline const std::string& Define_Item_LootState_Name(Define_Item_LootState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Define_Item_LootState_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool Define_Item_LootState_Parse(absl::string_view name, Define_Item_LootState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Define_Item_LootState>(
      Define_Item_LootState_descriptor(), name, value);
}
enum Define_Equipment_SlotId : int {
  Define_Equipment_SlotId_NONE = 0,
  Define_Equipment_SlotId_HEAD = 1,
  Define_Equipment_SlotId_CHEST = 2,
  Define_Equipment_SlotId_HANDS = 3,
  Define_Equipment_SlotId_LEGS = 4,
  Define_Equipment_SlotId_FOOT = 5,
  Define_Equipment_SlotId_BELT_A = 6,
  Define_Equipment_SlotId_BELT_B = 7,
  Define_Equipment_SlotId_UTILITY_A_1 = 8,
  Define_Equipment_SlotId_UTILITY_B_1 = 9,
  Define_Equipment_SlotId_PRIMARY_A = 10,
  Define_Equipment_SlotId_SECONDARY_A = 11,
  Define_Equipment_SlotId_PRIMARY_B = 12,
  Define_Equipment_SlotId_SECONDARY_B = 13,
  Define_Equipment_SlotId_UTILITY_A_2 = 14,
  Define_Equipment_SlotId_UTILITY_A_3 = 15,
  Define_Equipment_SlotId_UTILITY_B_2 = 16,
  Define_Equipment_SlotId_UTILITY_B_3 = 17,
  Define_Equipment_SlotId_SOULHEART = 18,
  Define_Equipment_SlotId_NECKLACE = 19,
  Define_Equipment_SlotId_RING_A = 20,
  Define_Equipment_SlotId_RING_B = 21,
  Define_Equipment_SlotId_BACK = 22,
  Define_Equipment_SlotId_Define_Equipment_SlotId_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Define_Equipment_SlotId_Define_Equipment_SlotId_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Define_Equipment_SlotId_IsValid(int value);
extern const uint32_t Define_Equipment_SlotId_internal_data_[];
constexpr Define_Equipment_SlotId Define_Equipment_SlotId_SlotId_MIN = static_cast<Define_Equipment_SlotId>(0);
constexpr Define_Equipment_SlotId Define_Equipment_SlotId_SlotId_MAX = static_cast<Define_Equipment_SlotId>(22);
constexpr int Define_Equipment_SlotId_SlotId_ARRAYSIZE = 22 + 1;
const ::google::protobuf::EnumDescriptor*
Define_Equipment_SlotId_descriptor();
template <typename T>
const std::string& Define_Equipment_SlotId_Name(T value) {
  static_assert(std::is_same<T, Define_Equipment_SlotId>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SlotId_Name().");
  return Define_Equipment_SlotId_Name(static_cast<Define_Equipment_SlotId>(value));
}
template <>
inline const std::string& Define_Equipment_SlotId_Name(Define_Equipment_SlotId value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Define_Equipment_SlotId_descriptor,
                                                 0, 22>(
      static_cast<int>(value));
}
inline bool Define_Equipment_SlotId_Parse(absl::string_view name, Define_Equipment_SlotId* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Define_Equipment_SlotId>(
      Define_Equipment_SlotId_descriptor(), name, value);
}
enum Define_Message_LoopFlag : int {
  Define_Message_LoopFlag_NONE = 0,
  Define_Message_LoopFlag_BEGIN = 1,
  Define_Message_LoopFlag_PROGRESS = 2,
  Define_Message_LoopFlag_END = 3,
  Define_Message_LoopFlag_Define_Message_LoopFlag_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Define_Message_LoopFlag_Define_Message_LoopFlag_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Define_Message_LoopFlag_IsValid(int value);
extern const uint32_t Define_Message_LoopFlag_internal_data_[];
constexpr Define_Message_LoopFlag Define_Message_LoopFlag_LoopFlag_MIN = static_cast<Define_Message_LoopFlag>(0);
constexpr Define_Message_LoopFlag Define_Message_LoopFlag_LoopFlag_MAX = static_cast<Define_Message_LoopFlag>(3);
constexpr int Define_Message_LoopFlag_LoopFlag_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
Define_Message_LoopFlag_descriptor();
template <typename T>
const std::string& Define_Message_LoopFlag_Name(T value) {
  static_assert(std::is_same<T, Define_Message_LoopFlag>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to LoopFlag_Name().");
  return Define_Message_LoopFlag_Name(static_cast<Define_Message_LoopFlag>(value));
}
template <>
inline const std::string& Define_Message_LoopFlag_Name(Define_Message_LoopFlag value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Define_Message_LoopFlag_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool Define_Message_LoopFlag_Parse(absl::string_view name, Define_Message_LoopFlag* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Define_Message_LoopFlag>(
      Define_Message_LoopFlag_descriptor(), name, value);
}
enum Define_Message_UpdateFlag : int {
  Define_Message_UpdateFlag_NONE_UPDATE_FLAG = 0,
  Define_Message_UpdateFlag_INSERT = 1,
  Define_Message_UpdateFlag_UPDATE = 2,
  Define_Message_UpdateFlag_DELETE = 3,
  Define_Message_UpdateFlag_Define_Message_UpdateFlag_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Define_Message_UpdateFlag_Define_Message_UpdateFlag_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Define_Message_UpdateFlag_IsValid(int value);
extern const uint32_t Define_Message_UpdateFlag_internal_data_[];
constexpr Define_Message_UpdateFlag Define_Message_UpdateFlag_UpdateFlag_MIN = static_cast<Define_Message_UpdateFlag>(0);
constexpr Define_Message_UpdateFlag Define_Message_UpdateFlag_UpdateFlag_MAX = static_cast<Define_Message_UpdateFlag>(3);
constexpr int Define_Message_UpdateFlag_UpdateFlag_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
Define_Message_UpdateFlag_descriptor();
template <typename T>
const std::string& Define_Message_UpdateFlag_Name(T value) {
  static_assert(std::is_same<T, Define_Message_UpdateFlag>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to UpdateFlag_Name().");
  return Define_Message_UpdateFlag_Name(static_cast<Define_Message_UpdateFlag>(value));
}
template <>
inline const std::string& Define_Message_UpdateFlag_Name(Define_Message_UpdateFlag value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Define_Message_UpdateFlag_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool Define_Message_UpdateFlag_Parse(absl::string_view name, Define_Message_UpdateFlag* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Define_Message_UpdateFlag>(
      Define_Message_UpdateFlag_descriptor(), name, value);
}
enum Define_Message_SelectFlag : int {
  Define_Message_SelectFlag_NONE_SELECT_FLAG = 0,
  Define_Message_SelectFlag_OK = 1,
  Define_Message_SelectFlag_CANCEL = 2,
  Define_Message_SelectFlag_Define_Message_SelectFlag_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Define_Message_SelectFlag_Define_Message_SelectFlag_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Define_Message_SelectFlag_IsValid(int value);
extern const uint32_t Define_Message_SelectFlag_internal_data_[];
constexpr Define_Message_SelectFlag Define_Message_SelectFlag_SelectFlag_MIN = static_cast<Define_Message_SelectFlag>(0);
constexpr Define_Message_SelectFlag Define_Message_SelectFlag_SelectFlag_MAX = static_cast<Define_Message_SelectFlag>(2);
constexpr int Define_Message_SelectFlag_SelectFlag_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
Define_Message_SelectFlag_descriptor();
template <typename T>
const std::string& Define_Message_SelectFlag_Name(T value) {
  static_assert(std::is_same<T, Define_Message_SelectFlag>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SelectFlag_Name().");
  return Define_Message_SelectFlag_Name(static_cast<Define_Message_SelectFlag>(value));
}
template <>
inline const std::string& Define_Message_SelectFlag_Name(Define_Message_SelectFlag value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Define_Message_SelectFlag_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool Define_Message_SelectFlag_Parse(absl::string_view name, Define_Message_SelectFlag* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Define_Message_SelectFlag>(
      Define_Message_SelectFlag_descriptor(), name, value);
}
enum Define_Match_Match_Region : int {
  Define_Match_Match_Region_NONE = 0,
  Define_Match_Match_Region_US_WEST = 1,
  Define_Match_Match_Region_US_EAST = 2,
  Define_Match_Match_Region_EU_CENTRAL = 3,
  Define_Match_Match_Region_KR = 4,
  Define_Match_Match_Region_SINGAPORE = 5,
  Define_Match_Match_Region_SYDNEY = 6,
  Define_Match_Match_Region_SAOPAULO = 7,
  Define_Match_Match_Region_TOKYO = 8,
  Define_Match_Match_Region_Define_Match_Match_Region_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Define_Match_Match_Region_Define_Match_Match_Region_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Define_Match_Match_Region_IsValid(int value);
extern const uint32_t Define_Match_Match_Region_internal_data_[];
constexpr Define_Match_Match_Region Define_Match_Match_Region_Match_Region_MIN = static_cast<Define_Match_Match_Region>(0);
constexpr Define_Match_Match_Region Define_Match_Match_Region_Match_Region_MAX = static_cast<Define_Match_Match_Region>(8);
constexpr int Define_Match_Match_Region_Match_Region_ARRAYSIZE = 8 + 1;
const ::google::protobuf::EnumDescriptor*
Define_Match_Match_Region_descriptor();
template <typename T>
const std::string& Define_Match_Match_Region_Name(T value) {
  static_assert(std::is_same<T, Define_Match_Match_Region>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Match_Region_Name().");
  return Define_Match_Match_Region_Name(static_cast<Define_Match_Match_Region>(value));
}
template <>
inline const std::string& Define_Match_Match_Region_Name(Define_Match_Match_Region value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Define_Match_Match_Region_descriptor,
                                                 0, 8>(
      static_cast<int>(value));
}
inline bool Define_Match_Match_Region_Parse(absl::string_view name, Define_Match_Match_Region* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Define_Match_Match_Region>(
      Define_Match_Match_Region_descriptor(), name, value);
}
enum Define_Stat_StatType : int {
  Define_Stat_StatType_NONE_STAT = 0,
  Define_Stat_StatType_GAMES_PLAYED = 1,
  Define_Stat_StatType_EXTRACTIONS = 2,
  Define_Stat_StatType_DOWN_PORTALS_TAKEN = 3,
  Define_Stat_StatType_KILLS = 4,
  Define_Stat_StatType_DEATHS = 5,
  Define_Stat_StatType_TREASURE_VALUE_EXTRACTED = 6,
  Define_Stat_StatType_MONSTERS_KILLED = 7,
  Define_Stat_StatType_SUBBOSSES_KILLED = 8,
  Define_Stat_StatType_BOSSES_KILLED = 9,
  Define_Stat_StatType_ORNATE_CHESTS_OPENED = 10,
  Define_Stat_StatType_ROYAL_COFFINS_OPENED = 11,
  Define_Stat_StatType_LIONS_HEAD_CHESTS_OPENED = 12,
  Define_Stat_StatType_GOLDEN_CHESTS_OPENED = 13,
  Define_Stat_StatType_MARVELOUS_CHESTS_OPENED = 14,
  Define_Stat_StatType_ALLIES_REVIVED = 15,
  Define_Stat_StatType_PLAYER_KILL_ASSIST = 16,
  Define_Stat_StatType_MONSTER_KILL_ASSIST = 17,
  Define_Stat_StatType_SUBBOSS_KILL_ASSIST = 18,
  Define_Stat_StatType_BOSS_KILL_ASSIST = 19,
  Define_Stat_StatType_Define_Stat_StatType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Define_Stat_StatType_Define_Stat_StatType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Define_Stat_StatType_IsValid(int value);
extern const uint32_t Define_Stat_StatType_internal_data_[];
constexpr Define_Stat_StatType Define_Stat_StatType_StatType_MIN = static_cast<Define_Stat_StatType>(0);
constexpr Define_Stat_StatType Define_Stat_StatType_StatType_MAX = static_cast<Define_Stat_StatType>(19);
constexpr int Define_Stat_StatType_StatType_ARRAYSIZE = 19 + 1;
const ::google::protobuf::EnumDescriptor*
Define_Stat_StatType_descriptor();
template <typename T>
const std::string& Define_Stat_StatType_Name(T value) {
  static_assert(std::is_same<T, Define_Stat_StatType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to StatType_Name().");
  return Define_Stat_StatType_Name(static_cast<Define_Stat_StatType>(value));
}
template <>
inline const std::string& Define_Stat_StatType_Name(Define_Stat_StatType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Define_Stat_StatType_descriptor,
                                                 0, 19>(
      static_cast<int>(value));
}
inline bool Define_Stat_StatType_Parse(absl::string_view name, Define_Stat_StatType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Define_Stat_StatType>(
      Define_Stat_StatType_descriptor(), name, value);
}
enum Define_Game_AdvPointType : int {
  Define_Game_AdvPointType_NONE = 0,
  Define_Game_AdvPointType_PlayerKill = 1,
  Define_Game_AdvPointType_DungeonDown = 2,
  Define_Game_AdvPointType_MonsterKill = 3,
  Define_Game_AdvPointType_PropsInteraction = 4,
  Define_Game_AdvPointType_ItemAchieve = 5,
  Define_Game_AdvPointType_PlayerDead = 6,
  Define_Game_AdvPointType_PlayerLocation = 7,
  Define_Game_AdvPointType_PlayerLootNewItem = 8,
  Define_Game_AdvPointType_SubBossKill = 9,
  Define_Game_AdvPointType_BossKill = 10,
  Define_Game_AdvPointType_HighEndPropsInteraction = 11,
  Define_Game_AdvPointType_Treasure = 12,
  Define_Game_AdvPointType_EntranceFee = 13,
  Define_Game_AdvPointType_PlayerKillAssist = 14,
  Define_Game_AdvPointType_MonsterKillAssist = 15,
  Define_Game_AdvPointType_SubBossKillAssist = 16,
  Define_Game_AdvPointType_BossKillAssist = 17,
  Define_Game_AdvPointType_Define_Game_AdvPointType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Define_Game_AdvPointType_Define_Game_AdvPointType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Define_Game_AdvPointType_IsValid(int value);
extern const uint32_t Define_Game_AdvPointType_internal_data_[];
constexpr Define_Game_AdvPointType Define_Game_AdvPointType_AdvPointType_MIN = static_cast<Define_Game_AdvPointType>(0);
constexpr Define_Game_AdvPointType Define_Game_AdvPointType_AdvPointType_MAX = static_cast<Define_Game_AdvPointType>(17);
constexpr int Define_Game_AdvPointType_AdvPointType_ARRAYSIZE = 17 + 1;
const ::google::protobuf::EnumDescriptor*
Define_Game_AdvPointType_descriptor();
template <typename T>
const std::string& Define_Game_AdvPointType_Name(T value) {
  static_assert(std::is_same<T, Define_Game_AdvPointType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AdvPointType_Name().");
  return Define_Game_AdvPointType_Name(static_cast<Define_Game_AdvPointType>(value));
}
template <>
inline const std::string& Define_Game_AdvPointType_Name(Define_Game_AdvPointType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Define_Game_AdvPointType_descriptor,
                                                 0, 17>(
      static_cast<int>(value));
}
inline bool Define_Game_AdvPointType_Parse(absl::string_view name, Define_Game_AdvPointType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Define_Game_AdvPointType>(
      Define_Game_AdvPointType_descriptor(), name, value);
}
enum Define_Game_GameType : int {
  Define_Game_GameType_NONE_MODE = 0,
  Define_Game_GameType_DUNGEON_TRIO_NORMAL = 1,
  Define_Game_GameType_DUNGEON_TRIO_HIGH_ROLLER = 2,
  Define_Game_GameType_DUNGEON_SOLO_NORMAL = 3,
  Define_Game_GameType_DUNGEON_DUO_NORMAL = 4,
  Define_Game_GameType_DUNGEON_SOLO_HIGH_ROLLER = 5,
  Define_Game_GameType_DUNGEON_DUO_HIGH_ROLLER = 6,
  Define_Game_GameType_ARENA_DUO = 7,
  Define_Game_GameType_ARENA_TRIO = 8,
  Define_Game_GameType_Define_Game_GameType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Define_Game_GameType_Define_Game_GameType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Define_Game_GameType_IsValid(int value);
extern const uint32_t Define_Game_GameType_internal_data_[];
constexpr Define_Game_GameType Define_Game_GameType_GameType_MIN = static_cast<Define_Game_GameType>(0);
constexpr Define_Game_GameType Define_Game_GameType_GameType_MAX = static_cast<Define_Game_GameType>(8);
constexpr int Define_Game_GameType_GameType_ARRAYSIZE = 8 + 1;
const ::google::protobuf::EnumDescriptor*
Define_Game_GameType_descriptor();
template <typename T>
const std::string& Define_Game_GameType_Name(T value) {
  static_assert(std::is_same<T, Define_Game_GameType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to GameType_Name().");
  return Define_Game_GameType_Name(static_cast<Define_Game_GameType>(value));
}
template <>
inline const std::string& Define_Game_GameType_Name(Define_Game_GameType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Define_Game_GameType_descriptor,
                                                 0, 8>(
      static_cast<int>(value));
}
inline bool Define_Game_GameType_Parse(absl::string_view name, Define_Game_GameType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Define_Game_GameType>(
      Define_Game_GameType_descriptor(), name, value);
}
enum Define_Game_Floor : int {
  Define_Game_Floor_NONE_FLOOR = 0,
  Define_Game_Floor_FLOOR_1F = 1,
  Define_Game_Floor_FLOOR_2F = 2,
  Define_Game_Floor_FLOOR_3F = 3,
  Define_Game_Floor_Define_Game_Floor_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Define_Game_Floor_Define_Game_Floor_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Define_Game_Floor_IsValid(int value);
extern const uint32_t Define_Game_Floor_internal_data_[];
constexpr Define_Game_Floor Define_Game_Floor_Floor_MIN = static_cast<Define_Game_Floor>(0);
constexpr Define_Game_Floor Define_Game_Floor_Floor_MAX = static_cast<Define_Game_Floor>(3);
constexpr int Define_Game_Floor_Floor_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
Define_Game_Floor_descriptor();
template <typename T>
const std::string& Define_Game_Floor_Name(T value) {
  static_assert(std::is_same<T, Define_Game_Floor>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Floor_Name().");
  return Define_Game_Floor_Name(static_cast<Define_Game_Floor>(value));
}
template <>
inline const std::string& Define_Game_Floor_Name(Define_Game_Floor value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Define_Game_Floor_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool Define_Game_Floor_Parse(absl::string_view name, Define_Game_Floor* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Define_Game_Floor>(
      Define_Game_Floor_descriptor(), name, value);
}
enum Define_Common_MetaLocation : int {
  Define_Common_MetaLocation_NONE = 0,
  Define_Common_MetaLocation_INGAME = 1,
  Define_Common_MetaLocation_PLAY = 2,
  Define_Common_MetaLocation_LEADERBOARD = 3,
  Define_Common_MetaLocation_LOADOUT = 4,
  Define_Common_MetaLocation_MERCHANT = 5,
  Define_Common_MetaLocation_TRADE = 6,
  Define_Common_MetaLocation_CLASS = 7,
  Define_Common_MetaLocation_CHARACTER_SELECT = 8,
  Define_Common_MetaLocation_OFFLINE = 9,
  Define_Common_MetaLocation_CUSTOMIZE = 10,
  Define_Common_MetaLocation_SHOP = 11,
  Define_Common_MetaLocation_RECRUIT = 12,
  Define_Common_MetaLocation_Define_Common_MetaLocation_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Define_Common_MetaLocation_Define_Common_MetaLocation_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Define_Common_MetaLocation_IsValid(int value);
extern const uint32_t Define_Common_MetaLocation_internal_data_[];
constexpr Define_Common_MetaLocation Define_Common_MetaLocation_MetaLocation_MIN = static_cast<Define_Common_MetaLocation>(0);
constexpr Define_Common_MetaLocation Define_Common_MetaLocation_MetaLocation_MAX = static_cast<Define_Common_MetaLocation>(12);
constexpr int Define_Common_MetaLocation_MetaLocation_ARRAYSIZE = 12 + 1;
const ::google::protobuf::EnumDescriptor*
Define_Common_MetaLocation_descriptor();
template <typename T>
const std::string& Define_Common_MetaLocation_Name(T value) {
  static_assert(std::is_same<T, Define_Common_MetaLocation>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MetaLocation_Name().");
  return Define_Common_MetaLocation_Name(static_cast<Define_Common_MetaLocation>(value));
}
template <>
inline const std::string& Define_Common_MetaLocation_Name(Define_Common_MetaLocation value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Define_Common_MetaLocation_descriptor,
                                                 0, 12>(
      static_cast<int>(value));
}
inline bool Define_Common_MetaLocation_Parse(absl::string_view name, Define_Common_MetaLocation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Define_Common_MetaLocation>(
      Define_Common_MetaLocation_descriptor(), name, value);
}
enum Define_Common_ServerLocation : int {
  Define_Common_ServerLocation_NONE_LOCATION = 0,
  Define_Common_ServerLocation_LOCAL = 1,
  Define_Common_ServerLocation_QA = 2,
  Define_Common_ServerLocation_PLAY_TEST = 3,
  Define_Common_ServerLocation_NA = 4,
  Define_Common_ServerLocation_Define_Common_ServerLocation_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Define_Common_ServerLocation_Define_Common_ServerLocation_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Define_Common_ServerLocation_IsValid(int value);
extern const uint32_t Define_Common_ServerLocation_internal_data_[];
constexpr Define_Common_ServerLocation Define_Common_ServerLocation_ServerLocation_MIN = static_cast<Define_Common_ServerLocation>(0);
constexpr Define_Common_ServerLocation Define_Common_ServerLocation_ServerLocation_MAX = static_cast<Define_Common_ServerLocation>(4);
constexpr int Define_Common_ServerLocation_ServerLocation_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
Define_Common_ServerLocation_descriptor();
template <typename T>
const std::string& Define_Common_ServerLocation_Name(T value) {
  static_assert(std::is_same<T, Define_Common_ServerLocation>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ServerLocation_Name().");
  return Define_Common_ServerLocation_Name(static_cast<Define_Common_ServerLocation>(value));
}
template <>
inline const std::string& Define_Common_ServerLocation_Name(Define_Common_ServerLocation value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Define_Common_ServerLocation_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool Define_Common_ServerLocation_Parse(absl::string_view name, Define_Common_ServerLocation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Define_Common_ServerLocation>(
      Define_Common_ServerLocation_descriptor(), name, value);
}
enum Define_Class_Type : int {
  Define_Class_Type_NONE_TYPE = 0,
  Define_Class_Type_PERK = 1,
  Define_Class_Type_SKILL = 2,
  Define_Class_Type_SPELL = 3,
  Define_Class_Type_MUSIC = 4,
  Define_Class_Type_SHAPE_SHIFT = 5,
  Define_Class_Type_Define_Class_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Define_Class_Type_Define_Class_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Define_Class_Type_IsValid(int value);
extern const uint32_t Define_Class_Type_internal_data_[];
constexpr Define_Class_Type Define_Class_Type_Type_MIN = static_cast<Define_Class_Type>(0);
constexpr Define_Class_Type Define_Class_Type_Type_MAX = static_cast<Define_Class_Type>(5);
constexpr int Define_Class_Type_Type_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
Define_Class_Type_descriptor();
template <typename T>
const std::string& Define_Class_Type_Name(T value) {
  static_assert(std::is_same<T, Define_Class_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return Define_Class_Type_Name(static_cast<Define_Class_Type>(value));
}
template <>
inline const std::string& Define_Class_Type_Name(Define_Class_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Define_Class_Type_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool Define_Class_Type_Parse(absl::string_view name, Define_Class_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Define_Class_Type>(
      Define_Class_Type_descriptor(), name, value);
}
enum Define_Class_Move : int {
  Define_Class_Move_NONE_MOVE = 0,
  Define_Class_Move_EQUIP = 1,
  Define_Class_Move_UN_EQUIP = 2,
  Define_Class_Move_Define_Class_Move_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Define_Class_Move_Define_Class_Move_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Define_Class_Move_IsValid(int value);
extern const uint32_t Define_Class_Move_internal_data_[];
constexpr Define_Class_Move Define_Class_Move_Move_MIN = static_cast<Define_Class_Move>(0);
constexpr Define_Class_Move Define_Class_Move_Move_MAX = static_cast<Define_Class_Move>(2);
constexpr int Define_Class_Move_Move_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
Define_Class_Move_descriptor();
template <typename T>
const std::string& Define_Class_Move_Name(T value) {
  static_assert(std::is_same<T, Define_Class_Move>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Move_Name().");
  return Define_Class_Move_Name(static_cast<Define_Class_Move>(value));
}
template <>
inline const std::string& Define_Class_Move_Name(Define_Class_Move value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Define_Class_Move_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool Define_Class_Move_Parse(absl::string_view name, Define_Class_Move* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Define_Class_Move>(
      Define_Class_Move_descriptor(), name, value);
}
enum Define_Chat_Type : int {
  Define_Chat_Type_NONE_TYPE = 0,
  Define_Chat_Type_NORMAL = 1,
  Define_Chat_Type_WHISPER = 2,
  Define_Chat_Type_Define_Chat_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Define_Chat_Type_Define_Chat_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Define_Chat_Type_IsValid(int value);
extern const uint32_t Define_Chat_Type_internal_data_[];
constexpr Define_Chat_Type Define_Chat_Type_Type_MIN = static_cast<Define_Chat_Type>(0);
constexpr Define_Chat_Type Define_Chat_Type_Type_MAX = static_cast<Define_Chat_Type>(2);
constexpr int Define_Chat_Type_Type_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
Define_Chat_Type_descriptor();
template <typename T>
const std::string& Define_Chat_Type_Name(T value) {
  static_assert(std::is_same<T, Define_Chat_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return Define_Chat_Type_Name(static_cast<Define_Chat_Type>(value));
}
template <>
inline const std::string& Define_Chat_Type_Name(Define_Chat_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Define_Chat_Type_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool Define_Chat_Type_Parse(absl::string_view name, Define_Chat_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Define_Chat_Type>(
      Define_Chat_Type_descriptor(), name, value);
}
enum Define_Chat_RoomType : int {
  Define_Chat_RoomType_ROOM_TYPE_WEAPON = 0,
  Define_Chat_RoomType_ROOM_TYPE_ARMOR = 1,
  Define_Chat_RoomType_ROOM_TYPE_UTILITY = 2,
  Define_Chat_RoomType_ROOM_TYPE_ETC = 3,
  Define_Chat_RoomType_Define_Chat_RoomType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Define_Chat_RoomType_Define_Chat_RoomType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Define_Chat_RoomType_IsValid(int value);
extern const uint32_t Define_Chat_RoomType_internal_data_[];
constexpr Define_Chat_RoomType Define_Chat_RoomType_RoomType_MIN = static_cast<Define_Chat_RoomType>(0);
constexpr Define_Chat_RoomType Define_Chat_RoomType_RoomType_MAX = static_cast<Define_Chat_RoomType>(3);
constexpr int Define_Chat_RoomType_RoomType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
Define_Chat_RoomType_descriptor();
template <typename T>
const std::string& Define_Chat_RoomType_Name(T value) {
  static_assert(std::is_same<T, Define_Chat_RoomType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RoomType_Name().");
  return Define_Chat_RoomType_Name(static_cast<Define_Chat_RoomType>(value));
}
template <>
inline const std::string& Define_Chat_RoomType_Name(Define_Chat_RoomType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Define_Chat_RoomType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool Define_Chat_RoomType_Parse(absl::string_view name, Define_Chat_RoomType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Define_Chat_RoomType>(
      Define_Chat_RoomType_descriptor(), name, value);
}
enum Define_Trade_Requirement_Type : int {
  Define_Trade_Requirement_Type_NONE_REQUIREMENT_TYPE = 0,
  Define_Trade_Requirement_Type_MINIMUM_LEVEL = 1,
  Define_Trade_Requirement_Type_MINIMUM_REINCARNATION_LEVEL = 2,
  Define_Trade_Requirement_Type_INITIATION_FEE = 3,
  Define_Trade_Requirement_Type_MONTHLY_DUES = 4,
  Define_Trade_Requirement_Type_COST_PER_TRADE = 5,
  Define_Trade_Requirement_Type_Define_Trade_Requirement_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Define_Trade_Requirement_Type_Define_Trade_Requirement_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Define_Trade_Requirement_Type_IsValid(int value);
extern const uint32_t Define_Trade_Requirement_Type_internal_data_[];
constexpr Define_Trade_Requirement_Type Define_Trade_Requirement_Type_Requirement_Type_MIN = static_cast<Define_Trade_Requirement_Type>(0);
constexpr Define_Trade_Requirement_Type Define_Trade_Requirement_Type_Requirement_Type_MAX = static_cast<Define_Trade_Requirement_Type>(5);
constexpr int Define_Trade_Requirement_Type_Requirement_Type_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
Define_Trade_Requirement_Type_descriptor();
template <typename T>
const std::string& Define_Trade_Requirement_Type_Name(T value) {
  static_assert(std::is_same<T, Define_Trade_Requirement_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Requirement_Type_Name().");
  return Define_Trade_Requirement_Type_Name(static_cast<Define_Trade_Requirement_Type>(value));
}
template <>
inline const std::string& Define_Trade_Requirement_Type_Name(Define_Trade_Requirement_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Define_Trade_Requirement_Type_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool Define_Trade_Requirement_Type_Parse(absl::string_view name, Define_Trade_Requirement_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Define_Trade_Requirement_Type>(
      Define_Trade_Requirement_Type_descriptor(), name, value);
}
enum Operate_Policy : int {
  Operate_Policy_NONE_POLICY = 0,
  Operate_Policy_POLICY_CHAT_LENGTH_MAX = 1,
  Operate_Policy_POLICY_TRADE_CHANNEL_CHAT_RESEND_TIME_MS = 2,
  Operate_Policy_POLICY_TRADE_CHANNEL_CHAT_MAX_LINE = 3,
  Operate_Policy_POLICY_BLOCK_CHARACTER_MAX_LIMIT = 4,
  Operate_Policy_POLICY_CHAT_RESEND_MS = 5,
  Operate_Policy_POLICY_CHAT_MAX_LINE = 6,
  Operate_Policy_POLICY_HIGH_ROLLER_ENTRANCE_FEE = 7,
  Operate_Policy_POLICY_MATCH_CANCEL_TIME_MS = 8,
  Operate_Policy_POLICY_GATHERING_HALL_CHAT_RESEND_MS = 9,
  Operate_Policy_POLICY_GATHERING_HALL_CHAT_MAX_LINE = 10,
  Operate_Policy_POLICY_GATHERING_HALL_JOIN_MIN_LEVEL = 11,
  Operate_Policy_POLICY_HIGH_ROLLER_ENTRANCE_MIN_LEVEL = 12,
  Operate_Policy_POLICY_GOBLIN_HIGH_ROLLER_ENTRANCE_FEE = 13,
  Operate_Policy_POLICY_GOBLIN_HIGH_ROLLER_ENTRANCE_MIN_LEVEL = 14,
  Operate_Policy_POLICY_MAX_RANK_BATCH_GAME_COUNT = 15,
  Operate_Policy_POLICY_ITEM_RARITY_TYPE_NORMAL_VALUE = 16,
  Operate_Policy_POLICY_ITEM_RARITY_TYPE_HIGH_ROLLER_VALUE = 17,
  Operate_Policy_POLICY_ITEM_RARITY_TYPE_RUINS_VALUE = 18,
  Operate_Policy_POLICY_ITEM_RARITY_TYPE_GOBLIN_VALUE = 19,
  Operate_Policy_POLICY_ITEM_RARITY_TYPE_GOBLIN_HIGH_ROLLER_VALUE = 20,
  Operate_Policy_POLICY_LEADERBOARD_SCORE_FRACTIONAL_DIGITS = 21,
  Operate_Policy_POLICY_RUINS_HIGH_ROLLER_ENTRANCE_FEE = 22,
  Operate_Policy_POLICY_RUINS_HIGH_ROLLER_ENTRANCE_MIN_LEVEL = 23,
  Operate_Policy_POLICY_ITEM_RARITY_TYPE_RUINS_HIGH_ROLLER_VALUE = 24,
  Operate_Policy_POLICY_MARKETPLACE_FIXED_LISTING_FEE = 25,
  Operate_Policy_POLICY_MARKETPLACE_VARIABLE_LISTING_FEE_RATE = 26,
  Operate_Policy_POLICY_MARKETPLACE_LISTING_EXPIRED_TIME = 27,
  Operate_Policy_POLICY_MARKETPLACE_TRANSFER_EXPIRED_TIME = 28,
  Operate_Policy_POLICY_MARKETPLACE_LISTING_LIMIT_COUNT = 29,
  Operate_Policy_POLICY_MARKETPLACE_MAXIMUM_SALE_AMOUNT = 30,
  Operate_Policy_POLICY_MARKETPLACE_CLOSED = 31,
  Operate_Policy_POLICY_DEATH_CAM_ON_OFF = 32,
  Operate_Policy_POLICY_ENABLE_CLOTHPHYSICS = 33,
  Operate_Policy_POLICY_ENABLE_CLOTHPHYSICS_USE_TASKTHREAD = 34,
  Operate_Policy_POLICY_WAITFOR_PARALLEL_CLOTHTASK = 35,
  Operate_Policy_POLICY_MINDWIPE_PRICE = 36,
  Operate_Policy_POLICY_ENABLE_SHIPPING_CLIENT_LOG = 37,
  Operate_Policy_POLICY_SET_SHIPPING_CLIENT_LOG_LEVEL = 38,
  Operate_Policy_POLICY_OVERRIDE_ANTIALIASING = 39,
  Operate_Policy_POLICY_ONLY_LOOTED_TRADE_ON = 40,
  Operate_Policy_POLICY_ENABLE_UPDATE_ENGINE_VARIABLES = 41,
  Operate_Policy_POLICY_KNIGHT_PROGRAM_LINK_PLAY_TIME_LIMIT = 42,
  Operate_Policy_POLICY_ACCOUNT_STATUS_UPGRADE = 43,
  Operate_Policy_POLICY_UPGRADE_CREATION_HIGH_ROLLER_CHECK_SEC = 45,
  Operate_Policy_POLICY_UPGRADE_CREATION_TRADE_CHECK_SEC = 46,
  Operate_Policy_POLICY_UPGRADE_CREATION_LISTING_MARKETPLACE_SEC = 47,
  Operate_Policy_POLICY_REPORT_IN_GAME_ON_OFF = 48,
  Operate_Policy_POLICY_REPORT_BAN_APPEAL_TICKET_SEND_ON_OFF = 49,
  Operate_Policy_POLICY_TRADE_CHAT_BAN_MIN = 50,
  Operate_Policy_POLICY_PREVENT_CROWS_HR_MIN_GEAR_SCORE = 51,
  Operate_Policy_POLICY_PREVENT_CROWS_HR_PARTY_SIZE_LIMIT = 52,
  Operate_Policy_POLICY_RANDOM_MATCHMAKING_ON_OFF = 53,
  Operate_Policy_POLICY_ALLOW_EQUIPMENT_ITEMS_ON_OFF = 54,
  Operate_Policy_Operate_Policy_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Operate_Policy_Operate_Policy_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Operate_Policy_IsValid(int value);
extern const uint32_t Operate_Policy_internal_data_[];
constexpr Operate_Policy Operate_Policy_Policy_MIN = static_cast<Operate_Policy>(0);
constexpr Operate_Policy Operate_Policy_Policy_MAX = static_cast<Operate_Policy>(54);
constexpr int Operate_Policy_Policy_ARRAYSIZE = 54 + 1;
const ::google::protobuf::EnumDescriptor*
Operate_Policy_descriptor();
template <typename T>
const std::string& Operate_Policy_Name(T value) {
  static_assert(std::is_same<T, Operate_Policy>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Policy_Name().");
  return Operate_Policy_Name(static_cast<Operate_Policy>(value));
}
template <>
inline const std::string& Operate_Policy_Name(Operate_Policy value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Operate_Policy_descriptor,
                                                 0, 54>(
      static_cast<int>(value));
}
inline bool Operate_Policy_Parse(absl::string_view name, Operate_Policy* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Operate_Policy>(
      Operate_Policy_descriptor(), name, value);
}
enum Define_Hack_Policy : int {
  Define_Hack_Policy_NONE_GAME_HACK_POLICY = 0,
  Define_Hack_Policy_GAME_HACK_POLICY_KICK = 1,
  Define_Hack_Policy_GAME_HACK_POLICY_BLOCK = 2,
  Define_Hack_Policy_GAME_HACK_POLICY_KICK_AND_BLOCK = 3,
  Define_Hack_Policy_Define_Hack_Policy_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Define_Hack_Policy_Define_Hack_Policy_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Define_Hack_Policy_IsValid(int value);
extern const uint32_t Define_Hack_Policy_internal_data_[];
constexpr Define_Hack_Policy Define_Hack_Policy_Policy_MIN = static_cast<Define_Hack_Policy>(0);
constexpr Define_Hack_Policy Define_Hack_Policy_Policy_MAX = static_cast<Define_Hack_Policy>(3);
constexpr int Define_Hack_Policy_Policy_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
Define_Hack_Policy_descriptor();
template <typename T>
const std::string& Define_Hack_Policy_Name(T value) {
  static_assert(std::is_same<T, Define_Hack_Policy>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Policy_Name().");
  return Define_Hack_Policy_Name(static_cast<Define_Hack_Policy>(value));
}
template <>
inline const std::string& Define_Hack_Policy_Name(Define_Hack_Policy value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Define_Hack_Policy_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool Define_Hack_Policy_Parse(absl::string_view name, Define_Hack_Policy* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Define_Hack_Policy>(
      Define_Hack_Policy_descriptor(), name, value);
}
enum Define_Hack_banType : int {
  Define_Hack_banType_NONE_BAN_TYPE = 0,
  Define_Hack_banType_Cheater = 1,
  Define_Hack_banType_InappropriateName = 2,
  Define_Hack_banType_Etc = 3,
  Define_Hack_banType_RmtUser = 4,
  Define_Hack_banType_RmtSpam = 5,
  Define_Hack_banType_AbnormalDetection = 6,
  Define_Hack_banType_CheaterGroup = 7,
  Define_Hack_banType_ExploitAbuser = 8,
  Define_Hack_banType_AbnormalScreen = 9,
  Define_Hack_banType_Teaming = 10,
  Define_Hack_banType_StreamSniping = 11,
  Define_Hack_banType_InappropriateChat = 12,
  Define_Hack_banType_InappropriateVoip = 13,
  Define_Hack_banType_RacistName = 14,
  Define_Hack_banType_RacistChat = 15,
  Define_Hack_banType_RacistVoip = 16,
  Define_Hack_banType_Refund_Abuse = 17,
  Define_Hack_banType_AbnormalChat = 18,
  Define_Hack_banType_Investigation = 19,
  Define_Hack_banType_Define_Hack_banType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Define_Hack_banType_Define_Hack_banType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Define_Hack_banType_IsValid(int value);
extern const uint32_t Define_Hack_banType_internal_data_[];
constexpr Define_Hack_banType Define_Hack_banType_banType_MIN = static_cast<Define_Hack_banType>(0);
constexpr Define_Hack_banType Define_Hack_banType_banType_MAX = static_cast<Define_Hack_banType>(19);
constexpr int Define_Hack_banType_banType_ARRAYSIZE = 19 + 1;
const ::google::protobuf::EnumDescriptor*
Define_Hack_banType_descriptor();
template <typename T>
const std::string& Define_Hack_banType_Name(T value) {
  static_assert(std::is_same<T, Define_Hack_banType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to banType_Name().");
  return Define_Hack_banType_Name(static_cast<Define_Hack_banType>(value));
}
template <>
inline const std::string& Define_Hack_banType_Name(Define_Hack_banType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Define_Hack_banType_descriptor,
                                                 0, 19>(
      static_cast<int>(value));
}
inline bool Define_Hack_banType_Parse(absl::string_view name, Define_Hack_banType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Define_Hack_banType>(
      Define_Hack_banType_descriptor(), name, value);
}
enum Define_Report_Category : int {
  Define_Report_Category_NONE_CATEGORY = 0,
  Define_Report_Category_CHEATER = 1,
  Define_Report_Category_INAPPROPRIATE_CHARACTER_NAME = 2,
  Define_Report_Category_STREAM_SNIPING = 3,
  Define_Report_Category_DIRTY_CHATTING = 4,
  Define_Report_Category_Define_Report_Category_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Define_Report_Category_Define_Report_Category_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Define_Report_Category_IsValid(int value);
extern const uint32_t Define_Report_Category_internal_data_[];
constexpr Define_Report_Category Define_Report_Category_Category_MIN = static_cast<Define_Report_Category>(0);
constexpr Define_Report_Category Define_Report_Category_Category_MAX = static_cast<Define_Report_Category>(4);
constexpr int Define_Report_Category_Category_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
Define_Report_Category_descriptor();
template <typename T>
const std::string& Define_Report_Category_Name(T value) {
  static_assert(std::is_same<T, Define_Report_Category>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Category_Name().");
  return Define_Report_Category_Name(static_cast<Define_Report_Category>(value));
}
template <>
inline const std::string& Define_Report_Category_Name(Define_Report_Category value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Define_Report_Category_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool Define_Report_Category_Parse(absl::string_view name, Define_Report_Category* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Define_Report_Category>(
      Define_Report_Category_descriptor(), name, value);
}
enum Define_Log_Level : int {
  Define_Log_Level_NONE_LEVEL = 0,
  Define_Log_Level_FATAL = 1,
  Define_Log_Level_ERROR = 2,
  Define_Log_Level_WARNING = 3,
  Define_Log_Level_DISPLAY = 4,
  Define_Log_Level_LOG = 5,
  Define_Log_Level_VERBOSE = 6,
  Define_Log_Level_VERY_VERBOSE = 7,
  Define_Log_Level_Define_Log_Level_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Define_Log_Level_Define_Log_Level_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Define_Log_Level_IsValid(int value);
extern const uint32_t Define_Log_Level_internal_data_[];
constexpr Define_Log_Level Define_Log_Level_Level_MIN = static_cast<Define_Log_Level>(0);
constexpr Define_Log_Level Define_Log_Level_Level_MAX = static_cast<Define_Log_Level>(7);
constexpr int Define_Log_Level_Level_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor*
Define_Log_Level_descriptor();
template <typename T>
const std::string& Define_Log_Level_Name(T value) {
  static_assert(std::is_same<T, Define_Log_Level>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Level_Name().");
  return Define_Log_Level_Name(static_cast<Define_Log_Level>(value));
}
template <>
inline const std::string& Define_Log_Level_Name(Define_Log_Level value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Define_Log_Level_descriptor,
                                                 0, 7>(
      static_cast<int>(value));
}
inline bool Define_Log_Level_Parse(absl::string_view name, Define_Log_Level* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Define_Log_Level>(
      Define_Log_Level_descriptor(), name, value);
}
enum Define_Karma_Action : int {
  Define_Karma_Action_NONE_KARMA_ACTION = 0,
  Define_Karma_Action_PRAISE = 1,
  Define_Karma_Action_PUNISH = 2,
  Define_Karma_Action_FORGIVE = 3,
  Define_Karma_Action_PUNISH_TEAM_KILLER = 4,
  Define_Karma_Action_Define_Karma_Action_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Define_Karma_Action_Define_Karma_Action_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Define_Karma_Action_IsValid(int value);
extern const uint32_t Define_Karma_Action_internal_data_[];
constexpr Define_Karma_Action Define_Karma_Action_Action_MIN = static_cast<Define_Karma_Action>(0);
constexpr Define_Karma_Action Define_Karma_Action_Action_MAX = static_cast<Define_Karma_Action>(4);
constexpr int Define_Karma_Action_Action_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
Define_Karma_Action_descriptor();
template <typename T>
const std::string& Define_Karma_Action_Name(T value) {
  static_assert(std::is_same<T, Define_Karma_Action>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Action_Name().");
  return Define_Karma_Action_Name(static_cast<Define_Karma_Action>(value));
}
template <>
inline const std::string& Define_Karma_Action_Name(Define_Karma_Action value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Define_Karma_Action_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool Define_Karma_Action_Parse(absl::string_view name, Define_Karma_Action* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Define_Karma_Action>(
      Define_Karma_Action_descriptor(), name, value);
}
enum Define_Karma_Status : int {
  Define_Karma_Status_NONE_KARMA_STATUS = 0,
  Define_Karma_Status_NORMAL = 1,
  Define_Karma_Status_TEAM_KILLER = 2,
  Define_Karma_Status_Define_Karma_Status_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Define_Karma_Status_Define_Karma_Status_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Define_Karma_Status_IsValid(int value);
extern const uint32_t Define_Karma_Status_internal_data_[];
constexpr Define_Karma_Status Define_Karma_Status_Status_MIN = static_cast<Define_Karma_Status>(0);
constexpr Define_Karma_Status Define_Karma_Status_Status_MAX = static_cast<Define_Karma_Status>(2);
constexpr int Define_Karma_Status_Status_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
Define_Karma_Status_descriptor();
template <typename T>
const std::string& Define_Karma_Status_Name(T value) {
  static_assert(std::is_same<T, Define_Karma_Status>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Status_Name().");
  return Define_Karma_Status_Name(static_cast<Define_Karma_Status>(value));
}
template <>
inline const std::string& Define_Karma_Status_Name(Define_Karma_Status value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Define_Karma_Status_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool Define_Karma_Status_Parse(absl::string_view name, Define_Karma_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Define_Karma_Status>(
      Define_Karma_Status_descriptor(), name, value);
}
enum Define_Coupon_Type : int {
  Define_Coupon_Type_NONE_TYPE = 0,
  Define_Coupon_Type_MADRINAS = 1,
  Define_Coupon_Type_Define_Coupon_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Define_Coupon_Type_Define_Coupon_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Define_Coupon_Type_IsValid(int value);
extern const uint32_t Define_Coupon_Type_internal_data_[];
constexpr Define_Coupon_Type Define_Coupon_Type_Type_MIN = static_cast<Define_Coupon_Type>(0);
constexpr Define_Coupon_Type Define_Coupon_Type_Type_MAX = static_cast<Define_Coupon_Type>(1);
constexpr int Define_Coupon_Type_Type_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
Define_Coupon_Type_descriptor();
template <typename T>
const std::string& Define_Coupon_Type_Name(T value) {
  static_assert(std::is_same<T, Define_Coupon_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return Define_Coupon_Type_Name(static_cast<Define_Coupon_Type>(value));
}
template <>
inline const std::string& Define_Coupon_Type_Name(Define_Coupon_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Define_Coupon_Type_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool Define_Coupon_Type_Parse(absl::string_view name, Define_Coupon_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Define_Coupon_Type>(
      Define_Coupon_Type_descriptor(), name, value);
}
enum Define_Shop_Type : int {
  Define_Shop_Type_SHOP_TYPE_NONE = 0,
  Define_Shop_Type_CHARACTER_SKIN = 1,
  Define_Shop_Type_ITEM_SKIN = 2,
  Define_Shop_Type_EMOTE = 3,
  Define_Shop_Type_ACTION = 4,
  Define_Shop_Type_LOBBY_EMOTE = 5,
  Define_Shop_Type_CLASS_PACKAGE = 6,
  Define_Shop_Type_ARMOR_SKIN = 7,
  Define_Shop_Type_Define_Shop_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Define_Shop_Type_Define_Shop_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Define_Shop_Type_IsValid(int value);
extern const uint32_t Define_Shop_Type_internal_data_[];
constexpr Define_Shop_Type Define_Shop_Type_Type_MIN = static_cast<Define_Shop_Type>(0);
constexpr Define_Shop_Type Define_Shop_Type_Type_MAX = static_cast<Define_Shop_Type>(7);
constexpr int Define_Shop_Type_Type_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor*
Define_Shop_Type_descriptor();
template <typename T>
const std::string& Define_Shop_Type_Name(T value) {
  static_assert(std::is_same<T, Define_Shop_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return Define_Shop_Type_Name(static_cast<Define_Shop_Type>(value));
}
template <>
inline const std::string& Define_Shop_Type_Name(Define_Shop_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Define_Shop_Type_descriptor,
                                                 0, 7>(
      static_cast<int>(value));
}
inline bool Define_Shop_Type_Parse(absl::string_view name, Define_Shop_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Define_Shop_Type>(
      Define_Shop_Type_descriptor(), name, value);
}
enum Define_Shop_PaymentMethod : int {
  Define_Shop_PaymentMethod_PAYMENT_NONE = 0,
  Define_Shop_PaymentMethod_BLUE_STONE_SHARD = 1,
  Define_Shop_PaymentMethod_RED_STONE_SHARD = 2,
  Define_Shop_PaymentMethod_Define_Shop_PaymentMethod_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Define_Shop_PaymentMethod_Define_Shop_PaymentMethod_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Define_Shop_PaymentMethod_IsValid(int value);
extern const uint32_t Define_Shop_PaymentMethod_internal_data_[];
constexpr Define_Shop_PaymentMethod Define_Shop_PaymentMethod_PaymentMethod_MIN = static_cast<Define_Shop_PaymentMethod>(0);
constexpr Define_Shop_PaymentMethod Define_Shop_PaymentMethod_PaymentMethod_MAX = static_cast<Define_Shop_PaymentMethod>(2);
constexpr int Define_Shop_PaymentMethod_PaymentMethod_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
Define_Shop_PaymentMethod_descriptor();
template <typename T>
const std::string& Define_Shop_PaymentMethod_Name(T value) {
  static_assert(std::is_same<T, Define_Shop_PaymentMethod>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PaymentMethod_Name().");
  return Define_Shop_PaymentMethod_Name(static_cast<Define_Shop_PaymentMethod>(value));
}
template <>
inline const std::string& Define_Shop_PaymentMethod_Name(Define_Shop_PaymentMethod value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Define_Shop_PaymentMethod_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool Define_Shop_PaymentMethod_Parse(absl::string_view name, Define_Shop_PaymentMethod* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Define_Shop_PaymentMethod>(
      Define_Shop_PaymentMethod_descriptor(), name, value);
}
enum Define_Shop_SalesChannelType : int {
  Define_Shop_SalesChannelType_CHANNEL_NONE = 0,
  Define_Shop_SalesChannelType_CHANNEL_SHOP = 1,
  Define_Shop_SalesChannelType_CHANNEL_FOUNDERS_PACK = 2,
  Define_Shop_SalesChannelType_Define_Shop_SalesChannelType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Define_Shop_SalesChannelType_Define_Shop_SalesChannelType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Define_Shop_SalesChannelType_IsValid(int value);
extern const uint32_t Define_Shop_SalesChannelType_internal_data_[];
constexpr Define_Shop_SalesChannelType Define_Shop_SalesChannelType_SalesChannelType_MIN = static_cast<Define_Shop_SalesChannelType>(0);
constexpr Define_Shop_SalesChannelType Define_Shop_SalesChannelType_SalesChannelType_MAX = static_cast<Define_Shop_SalesChannelType>(2);
constexpr int Define_Shop_SalesChannelType_SalesChannelType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
Define_Shop_SalesChannelType_descriptor();
template <typename T>
const std::string& Define_Shop_SalesChannelType_Name(T value) {
  static_assert(std::is_same<T, Define_Shop_SalesChannelType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SalesChannelType_Name().");
  return Define_Shop_SalesChannelType_Name(static_cast<Define_Shop_SalesChannelType>(value));
}
template <>
inline const std::string& Define_Shop_SalesChannelType_Name(Define_Shop_SalesChannelType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Define_Shop_SalesChannelType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool Define_Shop_SalesChannelType_Parse(absl::string_view name, Define_Shop_SalesChannelType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Define_Shop_SalesChannelType>(
      Define_Shop_SalesChannelType_descriptor(), name, value);
}
enum Define_Shop_ChangeNickNameType : int {
  Define_Shop_ChangeNickNameType_ACCOUNT_NAME = 0,
  Define_Shop_ChangeNickNameType_Define_Shop_ChangeNickNameType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Define_Shop_ChangeNickNameType_Define_Shop_ChangeNickNameType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Define_Shop_ChangeNickNameType_IsValid(int value);
extern const uint32_t Define_Shop_ChangeNickNameType_internal_data_[];
constexpr Define_Shop_ChangeNickNameType Define_Shop_ChangeNickNameType_ChangeNickNameType_MIN = static_cast<Define_Shop_ChangeNickNameType>(0);
constexpr Define_Shop_ChangeNickNameType Define_Shop_ChangeNickNameType_ChangeNickNameType_MAX = static_cast<Define_Shop_ChangeNickNameType>(0);
constexpr int Define_Shop_ChangeNickNameType_ChangeNickNameType_ARRAYSIZE = 0 + 1;
const ::google::protobuf::EnumDescriptor*
Define_Shop_ChangeNickNameType_descriptor();
template <typename T>
const std::string& Define_Shop_ChangeNickNameType_Name(T value) {
  static_assert(std::is_same<T, Define_Shop_ChangeNickNameType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ChangeNickNameType_Name().");
  return Define_Shop_ChangeNickNameType_Name(static_cast<Define_Shop_ChangeNickNameType>(value));
}
template <>
inline const std::string& Define_Shop_ChangeNickNameType_Name(Define_Shop_ChangeNickNameType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Define_Shop_ChangeNickNameType_descriptor,
                                                 0, 0>(
      static_cast<int>(value));
}
inline bool Define_Shop_ChangeNickNameType_Parse(absl::string_view name, Define_Shop_ChangeNickNameType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Define_Shop_ChangeNickNameType>(
      Define_Shop_ChangeNickNameType_descriptor(), name, value);
}
enum Define_Reward_RewardType : int {
  Define_Reward_RewardType_NONE_TYPE = 0,
  Define_Reward_RewardType_CharacterSkin = 1,
  Define_Reward_RewardType_ItemSkin = 2,
  Define_Reward_RewardType_Emote = 3,
  Define_Reward_RewardType_Action = 4,
  Define_Reward_RewardType_LobbyEmote = 5,
  Define_Reward_RewardType_ClassPackage = 6,
  Define_Reward_RewardType_Item = 7,
  Define_Reward_RewardType_Exp = 8,
  Define_Reward_RewardType_Affinity = 9,
  Define_Reward_RewardType_Stash = 10,
  Define_Reward_RewardType_ArmorSkin = 11,
  Define_Reward_RewardType_Define_Reward_RewardType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Define_Reward_RewardType_Define_Reward_RewardType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Define_Reward_RewardType_IsValid(int value);
extern const uint32_t Define_Reward_RewardType_internal_data_[];
constexpr Define_Reward_RewardType Define_Reward_RewardType_RewardType_MIN = static_cast<Define_Reward_RewardType>(0);
constexpr Define_Reward_RewardType Define_Reward_RewardType_RewardType_MAX = static_cast<Define_Reward_RewardType>(11);
constexpr int Define_Reward_RewardType_RewardType_ARRAYSIZE = 11 + 1;
const ::google::protobuf::EnumDescriptor*
Define_Reward_RewardType_descriptor();
template <typename T>
const std::string& Define_Reward_RewardType_Name(T value) {
  static_assert(std::is_same<T, Define_Reward_RewardType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RewardType_Name().");
  return Define_Reward_RewardType_Name(static_cast<Define_Reward_RewardType>(value));
}
template <>
inline const std::string& Define_Reward_RewardType_Name(Define_Reward_RewardType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Define_Reward_RewardType_descriptor,
                                                 0, 11>(
      static_cast<int>(value));
}
inline bool Define_Reward_RewardType_Parse(absl::string_view name, Define_Reward_RewardType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Define_Reward_RewardType>(
      Define_Reward_RewardType_descriptor(), name, value);
}
enum CharacterGenderType : int {
  NONE = 0,
  MAN = 1,
  WOMAN = 2,
  UNISEX = 3,
  CharacterGenderType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  CharacterGenderType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool CharacterGenderType_IsValid(int value);
extern const uint32_t CharacterGenderType_internal_data_[];
constexpr CharacterGenderType CharacterGenderType_MIN = static_cast<CharacterGenderType>(0);
constexpr CharacterGenderType CharacterGenderType_MAX = static_cast<CharacterGenderType>(3);
constexpr int CharacterGenderType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
CharacterGenderType_descriptor();
template <typename T>
const std::string& CharacterGenderType_Name(T value) {
  static_assert(std::is_same<T, CharacterGenderType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CharacterGenderType_Name().");
  return CharacterGenderType_Name(static_cast<CharacterGenderType>(value));
}
template <>
inline const std::string& CharacterGenderType_Name(CharacterGenderType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CharacterGenderType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool CharacterGenderType_Parse(absl::string_view name, CharacterGenderType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CharacterGenderType>(
      CharacterGenderType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Operate final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:DC.Packet.Defines.Operate) */ {
 public:
  inline Operate() : Operate(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Operate(
      ::google::protobuf::internal::ConstantInitialized);

  inline Operate(const Operate& from) : Operate(nullptr, from) {}
  inline Operate(Operate&& from) noexcept
      : Operate(nullptr, std::move(from)) {}
  inline Operate& operator=(const Operate& from) {
    CopyFrom(from);
    return *this;
  }
  inline Operate& operator=(Operate&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Operate& default_instance() {
    return *internal_default_instance();
  }
  static inline const Operate* internal_default_instance() {
    return reinterpret_cast<const Operate*>(
        &_Operate_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(Operate& a, Operate& b) { a.Swap(&b); }
  inline void Swap(Operate* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Operate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Operate* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<Operate>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Operate& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Operate& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DC.Packet.Defines.Operate"; }

 protected:
  explicit Operate(::google::protobuf::Arena* arena);
  Operate(::google::protobuf::Arena* arena, const Operate& from);
  Operate(::google::protobuf::Arena* arena, Operate&& from) noexcept
      : Operate(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Policy = Operate_Policy;
  static constexpr Policy NONE_POLICY = Operate_Policy_NONE_POLICY;
  static constexpr Policy POLICY_CHAT_LENGTH_MAX = Operate_Policy_POLICY_CHAT_LENGTH_MAX;
  static constexpr Policy POLICY_TRADE_CHANNEL_CHAT_RESEND_TIME_MS = Operate_Policy_POLICY_TRADE_CHANNEL_CHAT_RESEND_TIME_MS;
  static constexpr Policy POLICY_TRADE_CHANNEL_CHAT_MAX_LINE = Operate_Policy_POLICY_TRADE_CHANNEL_CHAT_MAX_LINE;
  static constexpr Policy POLICY_BLOCK_CHARACTER_MAX_LIMIT = Operate_Policy_POLICY_BLOCK_CHARACTER_MAX_LIMIT;
  static constexpr Policy POLICY_CHAT_RESEND_MS = Operate_Policy_POLICY_CHAT_RESEND_MS;
  static constexpr Policy POLICY_CHAT_MAX_LINE = Operate_Policy_POLICY_CHAT_MAX_LINE;
  static constexpr Policy POLICY_HIGH_ROLLER_ENTRANCE_FEE = Operate_Policy_POLICY_HIGH_ROLLER_ENTRANCE_FEE;
  static constexpr Policy POLICY_MATCH_CANCEL_TIME_MS = Operate_Policy_POLICY_MATCH_CANCEL_TIME_MS;
  static constexpr Policy POLICY_GATHERING_HALL_CHAT_RESEND_MS = Operate_Policy_POLICY_GATHERING_HALL_CHAT_RESEND_MS;
  static constexpr Policy POLICY_GATHERING_HALL_CHAT_MAX_LINE = Operate_Policy_POLICY_GATHERING_HALL_CHAT_MAX_LINE;
  static constexpr Policy POLICY_GATHERING_HALL_JOIN_MIN_LEVEL = Operate_Policy_POLICY_GATHERING_HALL_JOIN_MIN_LEVEL;
  static constexpr Policy POLICY_HIGH_ROLLER_ENTRANCE_MIN_LEVEL = Operate_Policy_POLICY_HIGH_ROLLER_ENTRANCE_MIN_LEVEL;
  static constexpr Policy POLICY_GOBLIN_HIGH_ROLLER_ENTRANCE_FEE = Operate_Policy_POLICY_GOBLIN_HIGH_ROLLER_ENTRANCE_FEE;
  static constexpr Policy POLICY_GOBLIN_HIGH_ROLLER_ENTRANCE_MIN_LEVEL = Operate_Policy_POLICY_GOBLIN_HIGH_ROLLER_ENTRANCE_MIN_LEVEL;
  static constexpr Policy POLICY_MAX_RANK_BATCH_GAME_COUNT = Operate_Policy_POLICY_MAX_RANK_BATCH_GAME_COUNT;
  static constexpr Policy POLICY_ITEM_RARITY_TYPE_NORMAL_VALUE = Operate_Policy_POLICY_ITEM_RARITY_TYPE_NORMAL_VALUE;
  static constexpr Policy POLICY_ITEM_RARITY_TYPE_HIGH_ROLLER_VALUE = Operate_Policy_POLICY_ITEM_RARITY_TYPE_HIGH_ROLLER_VALUE;
  static constexpr Policy POLICY_ITEM_RARITY_TYPE_RUINS_VALUE = Operate_Policy_POLICY_ITEM_RARITY_TYPE_RUINS_VALUE;
  static constexpr Policy POLICY_ITEM_RARITY_TYPE_GOBLIN_VALUE = Operate_Policy_POLICY_ITEM_RARITY_TYPE_GOBLIN_VALUE;
  static constexpr Policy POLICY_ITEM_RARITY_TYPE_GOBLIN_HIGH_ROLLER_VALUE = Operate_Policy_POLICY_ITEM_RARITY_TYPE_GOBLIN_HIGH_ROLLER_VALUE;
  static constexpr Policy POLICY_LEADERBOARD_SCORE_FRACTIONAL_DIGITS = Operate_Policy_POLICY_LEADERBOARD_SCORE_FRACTIONAL_DIGITS;
  static constexpr Policy POLICY_RUINS_HIGH_ROLLER_ENTRANCE_FEE = Operate_Policy_POLICY_RUINS_HIGH_ROLLER_ENTRANCE_FEE;
  static constexpr Policy POLICY_RUINS_HIGH_ROLLER_ENTRANCE_MIN_LEVEL = Operate_Policy_POLICY_RUINS_HIGH_ROLLER_ENTRANCE_MIN_LEVEL;
  static constexpr Policy POLICY_ITEM_RARITY_TYPE_RUINS_HIGH_ROLLER_VALUE = Operate_Policy_POLICY_ITEM_RARITY_TYPE_RUINS_HIGH_ROLLER_VALUE;
  static constexpr Policy POLICY_MARKETPLACE_FIXED_LISTING_FEE = Operate_Policy_POLICY_MARKETPLACE_FIXED_LISTING_FEE;
  static constexpr Policy POLICY_MARKETPLACE_VARIABLE_LISTING_FEE_RATE = Operate_Policy_POLICY_MARKETPLACE_VARIABLE_LISTING_FEE_RATE;
  static constexpr Policy POLICY_MARKETPLACE_LISTING_EXPIRED_TIME = Operate_Policy_POLICY_MARKETPLACE_LISTING_EXPIRED_TIME;
  static constexpr Policy POLICY_MARKETPLACE_TRANSFER_EXPIRED_TIME = Operate_Policy_POLICY_MARKETPLACE_TRANSFER_EXPIRED_TIME;
  static constexpr Policy POLICY_MARKETPLACE_LISTING_LIMIT_COUNT = Operate_Policy_POLICY_MARKETPLACE_LISTING_LIMIT_COUNT;
  static constexpr Policy POLICY_MARKETPLACE_MAXIMUM_SALE_AMOUNT = Operate_Policy_POLICY_MARKETPLACE_MAXIMUM_SALE_AMOUNT;
  static constexpr Policy POLICY_MARKETPLACE_CLOSED = Operate_Policy_POLICY_MARKETPLACE_CLOSED;
  static constexpr Policy POLICY_DEATH_CAM_ON_OFF = Operate_Policy_POLICY_DEATH_CAM_ON_OFF;
  static constexpr Policy POLICY_ENABLE_CLOTHPHYSICS = Operate_Policy_POLICY_ENABLE_CLOTHPHYSICS;
  static constexpr Policy POLICY_ENABLE_CLOTHPHYSICS_USE_TASKTHREAD = Operate_Policy_POLICY_ENABLE_CLOTHPHYSICS_USE_TASKTHREAD;
  static constexpr Policy POLICY_WAITFOR_PARALLEL_CLOTHTASK = Operate_Policy_POLICY_WAITFOR_PARALLEL_CLOTHTASK;
  static constexpr Policy POLICY_MINDWIPE_PRICE = Operate_Policy_POLICY_MINDWIPE_PRICE;
  static constexpr Policy POLICY_ENABLE_SHIPPING_CLIENT_LOG = Operate_Policy_POLICY_ENABLE_SHIPPING_CLIENT_LOG;
  static constexpr Policy POLICY_SET_SHIPPING_CLIENT_LOG_LEVEL = Operate_Policy_POLICY_SET_SHIPPING_CLIENT_LOG_LEVEL;
  static constexpr Policy POLICY_OVERRIDE_ANTIALIASING = Operate_Policy_POLICY_OVERRIDE_ANTIALIASING;
  static constexpr Policy POLICY_ONLY_LOOTED_TRADE_ON = Operate_Policy_POLICY_ONLY_LOOTED_TRADE_ON;
  static constexpr Policy POLICY_ENABLE_UPDATE_ENGINE_VARIABLES = Operate_Policy_POLICY_ENABLE_UPDATE_ENGINE_VARIABLES;
  static constexpr Policy POLICY_KNIGHT_PROGRAM_LINK_PLAY_TIME_LIMIT = Operate_Policy_POLICY_KNIGHT_PROGRAM_LINK_PLAY_TIME_LIMIT;
  static constexpr Policy POLICY_ACCOUNT_STATUS_UPGRADE = Operate_Policy_POLICY_ACCOUNT_STATUS_UPGRADE;
  static constexpr Policy POLICY_UPGRADE_CREATION_HIGH_ROLLER_CHECK_SEC = Operate_Policy_POLICY_UPGRADE_CREATION_HIGH_ROLLER_CHECK_SEC;
  static constexpr Policy POLICY_UPGRADE_CREATION_TRADE_CHECK_SEC = Operate_Policy_POLICY_UPGRADE_CREATION_TRADE_CHECK_SEC;
  static constexpr Policy POLICY_UPGRADE_CREATION_LISTING_MARKETPLACE_SEC = Operate_Policy_POLICY_UPGRADE_CREATION_LISTING_MARKETPLACE_SEC;
  static constexpr Policy POLICY_REPORT_IN_GAME_ON_OFF = Operate_Policy_POLICY_REPORT_IN_GAME_ON_OFF;
  static constexpr Policy POLICY_REPORT_BAN_APPEAL_TICKET_SEND_ON_OFF = Operate_Policy_POLICY_REPORT_BAN_APPEAL_TICKET_SEND_ON_OFF;
  static constexpr Policy POLICY_TRADE_CHAT_BAN_MIN = Operate_Policy_POLICY_TRADE_CHAT_BAN_MIN;
  static constexpr Policy POLICY_PREVENT_CROWS_HR_MIN_GEAR_SCORE = Operate_Policy_POLICY_PREVENT_CROWS_HR_MIN_GEAR_SCORE;
  static constexpr Policy POLICY_PREVENT_CROWS_HR_PARTY_SIZE_LIMIT = Operate_Policy_POLICY_PREVENT_CROWS_HR_PARTY_SIZE_LIMIT;
  static constexpr Policy POLICY_RANDOM_MATCHMAKING_ON_OFF = Operate_Policy_POLICY_RANDOM_MATCHMAKING_ON_OFF;
  static constexpr Policy POLICY_ALLOW_EQUIPMENT_ITEMS_ON_OFF = Operate_Policy_POLICY_ALLOW_EQUIPMENT_ITEMS_ON_OFF;
  static inline bool Policy_IsValid(int value) {
    return Operate_Policy_IsValid(value);
  }
  static constexpr Policy Policy_MIN = Operate_Policy_Policy_MIN;
  static constexpr Policy Policy_MAX = Operate_Policy_Policy_MAX;
  static constexpr int Policy_ARRAYSIZE = Operate_Policy_Policy_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Policy_descriptor() {
    return Operate_Policy_descriptor();
  }
  template <typename T>
  static inline const std::string& Policy_Name(T value) {
    return Operate_Policy_Name(value);
  }
  static inline bool Policy_Parse(absl::string_view name, Policy* value) {
    return Operate_Policy_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:DC.Packet.Defines.Operate)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Operate_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Operate& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct__5fDefins_2eproto;
};
// -------------------------------------------------------------------

class Define_Trade final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:DC.Packet.Defines.Define_Trade) */ {
 public:
  inline Define_Trade() : Define_Trade(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Define_Trade(
      ::google::protobuf::internal::ConstantInitialized);

  inline Define_Trade(const Define_Trade& from) : Define_Trade(nullptr, from) {}
  inline Define_Trade(Define_Trade&& from) noexcept
      : Define_Trade(nullptr, std::move(from)) {}
  inline Define_Trade& operator=(const Define_Trade& from) {
    CopyFrom(from);
    return *this;
  }
  inline Define_Trade& operator=(Define_Trade&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Define_Trade& default_instance() {
    return *internal_default_instance();
  }
  static inline const Define_Trade* internal_default_instance() {
    return reinterpret_cast<const Define_Trade*>(
        &_Define_Trade_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(Define_Trade& a, Define_Trade& b) { a.Swap(&b); }
  inline void Swap(Define_Trade* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Define_Trade* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Define_Trade* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<Define_Trade>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Define_Trade& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Define_Trade& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DC.Packet.Defines.Define_Trade"; }

 protected:
  explicit Define_Trade(::google::protobuf::Arena* arena);
  Define_Trade(::google::protobuf::Arena* arena, const Define_Trade& from);
  Define_Trade(::google::protobuf::Arena* arena, Define_Trade&& from) noexcept
      : Define_Trade(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Requirement_Type = Define_Trade_Requirement_Type;
  static constexpr Requirement_Type NONE_REQUIREMENT_TYPE = Define_Trade_Requirement_Type_NONE_REQUIREMENT_TYPE;
  static constexpr Requirement_Type MINIMUM_LEVEL = Define_Trade_Requirement_Type_MINIMUM_LEVEL;
  static constexpr Requirement_Type MINIMUM_REINCARNATION_LEVEL = Define_Trade_Requirement_Type_MINIMUM_REINCARNATION_LEVEL;
  static constexpr Requirement_Type INITIATION_FEE = Define_Trade_Requirement_Type_INITIATION_FEE;
  static constexpr Requirement_Type MONTHLY_DUES = Define_Trade_Requirement_Type_MONTHLY_DUES;
  static constexpr Requirement_Type COST_PER_TRADE = Define_Trade_Requirement_Type_COST_PER_TRADE;
  static inline bool Requirement_Type_IsValid(int value) {
    return Define_Trade_Requirement_Type_IsValid(value);
  }
  static constexpr Requirement_Type Requirement_Type_MIN = Define_Trade_Requirement_Type_Requirement_Type_MIN;
  static constexpr Requirement_Type Requirement_Type_MAX = Define_Trade_Requirement_Type_Requirement_Type_MAX;
  static constexpr int Requirement_Type_ARRAYSIZE = Define_Trade_Requirement_Type_Requirement_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Requirement_Type_descriptor() {
    return Define_Trade_Requirement_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Requirement_Type_Name(T value) {
    return Define_Trade_Requirement_Type_Name(value);
  }
  static inline bool Requirement_Type_Parse(absl::string_view name, Requirement_Type* value) {
    return Define_Trade_Requirement_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:DC.Packet.Defines.Define_Trade)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Define_Trade_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Define_Trade& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct__5fDefins_2eproto;
};
// -------------------------------------------------------------------

class Define_Stat final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:DC.Packet.Defines.Define_Stat) */ {
 public:
  inline Define_Stat() : Define_Stat(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Define_Stat(
      ::google::protobuf::internal::ConstantInitialized);

  inline Define_Stat(const Define_Stat& from) : Define_Stat(nullptr, from) {}
  inline Define_Stat(Define_Stat&& from) noexcept
      : Define_Stat(nullptr, std::move(from)) {}
  inline Define_Stat& operator=(const Define_Stat& from) {
    CopyFrom(from);
    return *this;
  }
  inline Define_Stat& operator=(Define_Stat&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Define_Stat& default_instance() {
    return *internal_default_instance();
  }
  static inline const Define_Stat* internal_default_instance() {
    return reinterpret_cast<const Define_Stat*>(
        &_Define_Stat_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(Define_Stat& a, Define_Stat& b) { a.Swap(&b); }
  inline void Swap(Define_Stat* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Define_Stat* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Define_Stat* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<Define_Stat>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Define_Stat& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Define_Stat& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DC.Packet.Defines.Define_Stat"; }

 protected:
  explicit Define_Stat(::google::protobuf::Arena* arena);
  Define_Stat(::google::protobuf::Arena* arena, const Define_Stat& from);
  Define_Stat(::google::protobuf::Arena* arena, Define_Stat&& from) noexcept
      : Define_Stat(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using StatType = Define_Stat_StatType;
  static constexpr StatType NONE_STAT = Define_Stat_StatType_NONE_STAT;
  static constexpr StatType GAMES_PLAYED = Define_Stat_StatType_GAMES_PLAYED;
  static constexpr StatType EXTRACTIONS = Define_Stat_StatType_EXTRACTIONS;
  static constexpr StatType DOWN_PORTALS_TAKEN = Define_Stat_StatType_DOWN_PORTALS_TAKEN;
  static constexpr StatType KILLS = Define_Stat_StatType_KILLS;
  static constexpr StatType DEATHS = Define_Stat_StatType_DEATHS;
  static constexpr StatType TREASURE_VALUE_EXTRACTED = Define_Stat_StatType_TREASURE_VALUE_EXTRACTED;
  static constexpr StatType MONSTERS_KILLED = Define_Stat_StatType_MONSTERS_KILLED;
  static constexpr StatType SUBBOSSES_KILLED = Define_Stat_StatType_SUBBOSSES_KILLED;
  static constexpr StatType BOSSES_KILLED = Define_Stat_StatType_BOSSES_KILLED;
  static constexpr StatType ORNATE_CHESTS_OPENED = Define_Stat_StatType_ORNATE_CHESTS_OPENED;
  static constexpr StatType ROYAL_COFFINS_OPENED = Define_Stat_StatType_ROYAL_COFFINS_OPENED;
  static constexpr StatType LIONS_HEAD_CHESTS_OPENED = Define_Stat_StatType_LIONS_HEAD_CHESTS_OPENED;
  static constexpr StatType GOLDEN_CHESTS_OPENED = Define_Stat_StatType_GOLDEN_CHESTS_OPENED;
  static constexpr StatType MARVELOUS_CHESTS_OPENED = Define_Stat_StatType_MARVELOUS_CHESTS_OPENED;
  static constexpr StatType ALLIES_REVIVED = Define_Stat_StatType_ALLIES_REVIVED;
  static constexpr StatType PLAYER_KILL_ASSIST = Define_Stat_StatType_PLAYER_KILL_ASSIST;
  static constexpr StatType MONSTER_KILL_ASSIST = Define_Stat_StatType_MONSTER_KILL_ASSIST;
  static constexpr StatType SUBBOSS_KILL_ASSIST = Define_Stat_StatType_SUBBOSS_KILL_ASSIST;
  static constexpr StatType BOSS_KILL_ASSIST = Define_Stat_StatType_BOSS_KILL_ASSIST;
  static inline bool StatType_IsValid(int value) {
    return Define_Stat_StatType_IsValid(value);
  }
  static constexpr StatType StatType_MIN = Define_Stat_StatType_StatType_MIN;
  static constexpr StatType StatType_MAX = Define_Stat_StatType_StatType_MAX;
  static constexpr int StatType_ARRAYSIZE = Define_Stat_StatType_StatType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* StatType_descriptor() {
    return Define_Stat_StatType_descriptor();
  }
  template <typename T>
  static inline const std::string& StatType_Name(T value) {
    return Define_Stat_StatType_Name(value);
  }
  static inline bool StatType_Parse(absl::string_view name, StatType* value) {
    return Define_Stat_StatType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:DC.Packet.Defines.Define_Stat)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Define_Stat_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Define_Stat& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct__5fDefins_2eproto;
};
// -------------------------------------------------------------------

class Define_Shop final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:DC.Packet.Defines.Define_Shop) */ {
 public:
  inline Define_Shop() : Define_Shop(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Define_Shop(
      ::google::protobuf::internal::ConstantInitialized);

  inline Define_Shop(const Define_Shop& from) : Define_Shop(nullptr, from) {}
  inline Define_Shop(Define_Shop&& from) noexcept
      : Define_Shop(nullptr, std::move(from)) {}
  inline Define_Shop& operator=(const Define_Shop& from) {
    CopyFrom(from);
    return *this;
  }
  inline Define_Shop& operator=(Define_Shop&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Define_Shop& default_instance() {
    return *internal_default_instance();
  }
  static inline const Define_Shop* internal_default_instance() {
    return reinterpret_cast<const Define_Shop*>(
        &_Define_Shop_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(Define_Shop& a, Define_Shop& b) { a.Swap(&b); }
  inline void Swap(Define_Shop* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Define_Shop* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Define_Shop* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<Define_Shop>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Define_Shop& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Define_Shop& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DC.Packet.Defines.Define_Shop"; }

 protected:
  explicit Define_Shop(::google::protobuf::Arena* arena);
  Define_Shop(::google::protobuf::Arena* arena, const Define_Shop& from);
  Define_Shop(::google::protobuf::Arena* arena, Define_Shop&& from) noexcept
      : Define_Shop(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Type = Define_Shop_Type;
  static constexpr Type SHOP_TYPE_NONE = Define_Shop_Type_SHOP_TYPE_NONE;
  static constexpr Type CHARACTER_SKIN = Define_Shop_Type_CHARACTER_SKIN;
  static constexpr Type ITEM_SKIN = Define_Shop_Type_ITEM_SKIN;
  static constexpr Type EMOTE = Define_Shop_Type_EMOTE;
  static constexpr Type ACTION = Define_Shop_Type_ACTION;
  static constexpr Type LOBBY_EMOTE = Define_Shop_Type_LOBBY_EMOTE;
  static constexpr Type CLASS_PACKAGE = Define_Shop_Type_CLASS_PACKAGE;
  static constexpr Type ARMOR_SKIN = Define_Shop_Type_ARMOR_SKIN;
  static inline bool Type_IsValid(int value) {
    return Define_Shop_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = Define_Shop_Type_Type_MIN;
  static constexpr Type Type_MAX = Define_Shop_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = Define_Shop_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return Define_Shop_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return Define_Shop_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return Define_Shop_Type_Parse(name, value);
  }
  using PaymentMethod = Define_Shop_PaymentMethod;
  static constexpr PaymentMethod PAYMENT_NONE = Define_Shop_PaymentMethod_PAYMENT_NONE;
  static constexpr PaymentMethod BLUE_STONE_SHARD = Define_Shop_PaymentMethod_BLUE_STONE_SHARD;
  static constexpr PaymentMethod RED_STONE_SHARD = Define_Shop_PaymentMethod_RED_STONE_SHARD;
  static inline bool PaymentMethod_IsValid(int value) {
    return Define_Shop_PaymentMethod_IsValid(value);
  }
  static constexpr PaymentMethod PaymentMethod_MIN = Define_Shop_PaymentMethod_PaymentMethod_MIN;
  static constexpr PaymentMethod PaymentMethod_MAX = Define_Shop_PaymentMethod_PaymentMethod_MAX;
  static constexpr int PaymentMethod_ARRAYSIZE = Define_Shop_PaymentMethod_PaymentMethod_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PaymentMethod_descriptor() {
    return Define_Shop_PaymentMethod_descriptor();
  }
  template <typename T>
  static inline const std::string& PaymentMethod_Name(T value) {
    return Define_Shop_PaymentMethod_Name(value);
  }
  static inline bool PaymentMethod_Parse(absl::string_view name, PaymentMethod* value) {
    return Define_Shop_PaymentMethod_Parse(name, value);
  }
  using SalesChannelType = Define_Shop_SalesChannelType;
  static constexpr SalesChannelType CHANNEL_NONE = Define_Shop_SalesChannelType_CHANNEL_NONE;
  static constexpr SalesChannelType CHANNEL_SHOP = Define_Shop_SalesChannelType_CHANNEL_SHOP;
  static constexpr SalesChannelType CHANNEL_FOUNDERS_PACK = Define_Shop_SalesChannelType_CHANNEL_FOUNDERS_PACK;
  static inline bool SalesChannelType_IsValid(int value) {
    return Define_Shop_SalesChannelType_IsValid(value);
  }
  static constexpr SalesChannelType SalesChannelType_MIN = Define_Shop_SalesChannelType_SalesChannelType_MIN;
  static constexpr SalesChannelType SalesChannelType_MAX = Define_Shop_SalesChannelType_SalesChannelType_MAX;
  static constexpr int SalesChannelType_ARRAYSIZE = Define_Shop_SalesChannelType_SalesChannelType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* SalesChannelType_descriptor() {
    return Define_Shop_SalesChannelType_descriptor();
  }
  template <typename T>
  static inline const std::string& SalesChannelType_Name(T value) {
    return Define_Shop_SalesChannelType_Name(value);
  }
  static inline bool SalesChannelType_Parse(absl::string_view name, SalesChannelType* value) {
    return Define_Shop_SalesChannelType_Parse(name, value);
  }
  using ChangeNickNameType = Define_Shop_ChangeNickNameType;
  static constexpr ChangeNickNameType ACCOUNT_NAME = Define_Shop_ChangeNickNameType_ACCOUNT_NAME;
  static inline bool ChangeNickNameType_IsValid(int value) {
    return Define_Shop_ChangeNickNameType_IsValid(value);
  }
  static constexpr ChangeNickNameType ChangeNickNameType_MIN = Define_Shop_ChangeNickNameType_ChangeNickNameType_MIN;
  static constexpr ChangeNickNameType ChangeNickNameType_MAX = Define_Shop_ChangeNickNameType_ChangeNickNameType_MAX;
  static constexpr int ChangeNickNameType_ARRAYSIZE = Define_Shop_ChangeNickNameType_ChangeNickNameType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ChangeNickNameType_descriptor() {
    return Define_Shop_ChangeNickNameType_descriptor();
  }
  template <typename T>
  static inline const std::string& ChangeNickNameType_Name(T value) {
    return Define_Shop_ChangeNickNameType_Name(value);
  }
  static inline bool ChangeNickNameType_Parse(absl::string_view name, ChangeNickNameType* value) {
    return Define_Shop_ChangeNickNameType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:DC.Packet.Defines.Define_Shop)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Define_Shop_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Define_Shop& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct__5fDefins_2eproto;
};
// -------------------------------------------------------------------

class Define_Reward final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:DC.Packet.Defines.Define_Reward) */ {
 public:
  inline Define_Reward() : Define_Reward(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Define_Reward(
      ::google::protobuf::internal::ConstantInitialized);

  inline Define_Reward(const Define_Reward& from) : Define_Reward(nullptr, from) {}
  inline Define_Reward(Define_Reward&& from) noexcept
      : Define_Reward(nullptr, std::move(from)) {}
  inline Define_Reward& operator=(const Define_Reward& from) {
    CopyFrom(from);
    return *this;
  }
  inline Define_Reward& operator=(Define_Reward&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Define_Reward& default_instance() {
    return *internal_default_instance();
  }
  static inline const Define_Reward* internal_default_instance() {
    return reinterpret_cast<const Define_Reward*>(
        &_Define_Reward_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(Define_Reward& a, Define_Reward& b) { a.Swap(&b); }
  inline void Swap(Define_Reward* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Define_Reward* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Define_Reward* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<Define_Reward>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Define_Reward& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Define_Reward& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DC.Packet.Defines.Define_Reward"; }

 protected:
  explicit Define_Reward(::google::protobuf::Arena* arena);
  Define_Reward(::google::protobuf::Arena* arena, const Define_Reward& from);
  Define_Reward(::google::protobuf::Arena* arena, Define_Reward&& from) noexcept
      : Define_Reward(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using RewardType = Define_Reward_RewardType;
  static constexpr RewardType NONE_TYPE = Define_Reward_RewardType_NONE_TYPE;
  static constexpr RewardType CharacterSkin = Define_Reward_RewardType_CharacterSkin;
  static constexpr RewardType ItemSkin = Define_Reward_RewardType_ItemSkin;
  static constexpr RewardType Emote = Define_Reward_RewardType_Emote;
  static constexpr RewardType Action = Define_Reward_RewardType_Action;
  static constexpr RewardType LobbyEmote = Define_Reward_RewardType_LobbyEmote;
  static constexpr RewardType ClassPackage = Define_Reward_RewardType_ClassPackage;
  static constexpr RewardType Item = Define_Reward_RewardType_Item;
  static constexpr RewardType Exp = Define_Reward_RewardType_Exp;
  static constexpr RewardType Affinity = Define_Reward_RewardType_Affinity;
  static constexpr RewardType Stash = Define_Reward_RewardType_Stash;
  static constexpr RewardType ArmorSkin = Define_Reward_RewardType_ArmorSkin;
  static inline bool RewardType_IsValid(int value) {
    return Define_Reward_RewardType_IsValid(value);
  }
  static constexpr RewardType RewardType_MIN = Define_Reward_RewardType_RewardType_MIN;
  static constexpr RewardType RewardType_MAX = Define_Reward_RewardType_RewardType_MAX;
  static constexpr int RewardType_ARRAYSIZE = Define_Reward_RewardType_RewardType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* RewardType_descriptor() {
    return Define_Reward_RewardType_descriptor();
  }
  template <typename T>
  static inline const std::string& RewardType_Name(T value) {
    return Define_Reward_RewardType_Name(value);
  }
  static inline bool RewardType_Parse(absl::string_view name, RewardType* value) {
    return Define_Reward_RewardType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:DC.Packet.Defines.Define_Reward)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Define_Reward_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Define_Reward& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct__5fDefins_2eproto;
};
// -------------------------------------------------------------------

class Define_Report final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:DC.Packet.Defines.Define_Report) */ {
 public:
  inline Define_Report() : Define_Report(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Define_Report(
      ::google::protobuf::internal::ConstantInitialized);

  inline Define_Report(const Define_Report& from) : Define_Report(nullptr, from) {}
  inline Define_Report(Define_Report&& from) noexcept
      : Define_Report(nullptr, std::move(from)) {}
  inline Define_Report& operator=(const Define_Report& from) {
    CopyFrom(from);
    return *this;
  }
  inline Define_Report& operator=(Define_Report&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Define_Report& default_instance() {
    return *internal_default_instance();
  }
  static inline const Define_Report* internal_default_instance() {
    return reinterpret_cast<const Define_Report*>(
        &_Define_Report_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(Define_Report& a, Define_Report& b) { a.Swap(&b); }
  inline void Swap(Define_Report* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Define_Report* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Define_Report* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<Define_Report>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Define_Report& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Define_Report& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DC.Packet.Defines.Define_Report"; }

 protected:
  explicit Define_Report(::google::protobuf::Arena* arena);
  Define_Report(::google::protobuf::Arena* arena, const Define_Report& from);
  Define_Report(::google::protobuf::Arena* arena, Define_Report&& from) noexcept
      : Define_Report(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Category = Define_Report_Category;
  static constexpr Category NONE_CATEGORY = Define_Report_Category_NONE_CATEGORY;
  static constexpr Category CHEATER = Define_Report_Category_CHEATER;
  static constexpr Category INAPPROPRIATE_CHARACTER_NAME = Define_Report_Category_INAPPROPRIATE_CHARACTER_NAME;
  static constexpr Category STREAM_SNIPING = Define_Report_Category_STREAM_SNIPING;
  static constexpr Category DIRTY_CHATTING = Define_Report_Category_DIRTY_CHATTING;
  static inline bool Category_IsValid(int value) {
    return Define_Report_Category_IsValid(value);
  }
  static constexpr Category Category_MIN = Define_Report_Category_Category_MIN;
  static constexpr Category Category_MAX = Define_Report_Category_Category_MAX;
  static constexpr int Category_ARRAYSIZE = Define_Report_Category_Category_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Category_descriptor() {
    return Define_Report_Category_descriptor();
  }
  template <typename T>
  static inline const std::string& Category_Name(T value) {
    return Define_Report_Category_Name(value);
  }
  static inline bool Category_Parse(absl::string_view name, Category* value) {
    return Define_Report_Category_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:DC.Packet.Defines.Define_Report)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Define_Report_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Define_Report& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct__5fDefins_2eproto;
};
// -------------------------------------------------------------------

class Define_Party final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:DC.Packet.Defines.Define_Party) */ {
 public:
  inline Define_Party() : Define_Party(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Define_Party(
      ::google::protobuf::internal::ConstantInitialized);

  inline Define_Party(const Define_Party& from) : Define_Party(nullptr, from) {}
  inline Define_Party(Define_Party&& from) noexcept
      : Define_Party(nullptr, std::move(from)) {}
  inline Define_Party& operator=(const Define_Party& from) {
    CopyFrom(from);
    return *this;
  }
  inline Define_Party& operator=(Define_Party&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Define_Party& default_instance() {
    return *internal_default_instance();
  }
  static inline const Define_Party* internal_default_instance() {
    return reinterpret_cast<const Define_Party*>(
        &_Define_Party_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(Define_Party& a, Define_Party& b) { a.Swap(&b); }
  inline void Swap(Define_Party* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Define_Party* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Define_Party* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<Define_Party>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Define_Party& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Define_Party& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DC.Packet.Defines.Define_Party"; }

 protected:
  explicit Define_Party(::google::protobuf::Arena* arena);
  Define_Party(::google::protobuf::Arena* arena, const Define_Party& from);
  Define_Party(::google::protobuf::Arena* arena, Define_Party&& from) noexcept
      : Define_Party(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using MemberCountLimit = Define_Party_MemberCountLimit;
  static constexpr MemberCountLimit NONE = Define_Party_MemberCountLimit_NONE;
  static constexpr MemberCountLimit MAX = Define_Party_MemberCountLimit_MAX;
  static constexpr MemberCountLimit MIN = Define_Party_MemberCountLimit_MIN;
  static inline bool MemberCountLimit_IsValid(int value) {
    return Define_Party_MemberCountLimit_IsValid(value);
  }
  static constexpr MemberCountLimit MemberCountLimit_MIN = Define_Party_MemberCountLimit_MemberCountLimit_MIN;
  static constexpr MemberCountLimit MemberCountLimit_MAX = Define_Party_MemberCountLimit_MemberCountLimit_MAX;
  static constexpr int MemberCountLimit_ARRAYSIZE = Define_Party_MemberCountLimit_MemberCountLimit_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* MemberCountLimit_descriptor() {
    return Define_Party_MemberCountLimit_descriptor();
  }
  template <typename T>
  static inline const std::string& MemberCountLimit_Name(T value) {
    return Define_Party_MemberCountLimit_Name(value);
  }
  static inline bool MemberCountLimit_Parse(absl::string_view name, MemberCountLimit* value) {
    return Define_Party_MemberCountLimit_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:DC.Packet.Defines.Define_Party)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Define_Party_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Define_Party& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct__5fDefins_2eproto;
};
// -------------------------------------------------------------------

class Define_Message final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:DC.Packet.Defines.Define_Message) */ {
 public:
  inline Define_Message() : Define_Message(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Define_Message(
      ::google::protobuf::internal::ConstantInitialized);

  inline Define_Message(const Define_Message& from) : Define_Message(nullptr, from) {}
  inline Define_Message(Define_Message&& from) noexcept
      : Define_Message(nullptr, std::move(from)) {}
  inline Define_Message& operator=(const Define_Message& from) {
    CopyFrom(from);
    return *this;
  }
  inline Define_Message& operator=(Define_Message&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Define_Message& default_instance() {
    return *internal_default_instance();
  }
  static inline const Define_Message* internal_default_instance() {
    return reinterpret_cast<const Define_Message*>(
        &_Define_Message_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(Define_Message& a, Define_Message& b) { a.Swap(&b); }
  inline void Swap(Define_Message* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Define_Message* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Define_Message* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<Define_Message>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Define_Message& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Define_Message& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DC.Packet.Defines.Define_Message"; }

 protected:
  explicit Define_Message(::google::protobuf::Arena* arena);
  Define_Message(::google::protobuf::Arena* arena, const Define_Message& from);
  Define_Message(::google::protobuf::Arena* arena, Define_Message&& from) noexcept
      : Define_Message(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using LoopFlag = Define_Message_LoopFlag;
  static constexpr LoopFlag NONE = Define_Message_LoopFlag_NONE;
  static constexpr LoopFlag BEGIN = Define_Message_LoopFlag_BEGIN;
  static constexpr LoopFlag PROGRESS = Define_Message_LoopFlag_PROGRESS;
  static constexpr LoopFlag END = Define_Message_LoopFlag_END;
  static inline bool LoopFlag_IsValid(int value) {
    return Define_Message_LoopFlag_IsValid(value);
  }
  static constexpr LoopFlag LoopFlag_MIN = Define_Message_LoopFlag_LoopFlag_MIN;
  static constexpr LoopFlag LoopFlag_MAX = Define_Message_LoopFlag_LoopFlag_MAX;
  static constexpr int LoopFlag_ARRAYSIZE = Define_Message_LoopFlag_LoopFlag_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* LoopFlag_descriptor() {
    return Define_Message_LoopFlag_descriptor();
  }
  template <typename T>
  static inline const std::string& LoopFlag_Name(T value) {
    return Define_Message_LoopFlag_Name(value);
  }
  static inline bool LoopFlag_Parse(absl::string_view name, LoopFlag* value) {
    return Define_Message_LoopFlag_Parse(name, value);
  }
  using UpdateFlag = Define_Message_UpdateFlag;
  static constexpr UpdateFlag NONE_UPDATE_FLAG = Define_Message_UpdateFlag_NONE_UPDATE_FLAG;
  static constexpr UpdateFlag INSERT = Define_Message_UpdateFlag_INSERT;
  static constexpr UpdateFlag UPDATE = Define_Message_UpdateFlag_UPDATE;
  static constexpr UpdateFlag DELETE = Define_Message_UpdateFlag_DELETE;
  static inline bool UpdateFlag_IsValid(int value) {
    return Define_Message_UpdateFlag_IsValid(value);
  }
  static constexpr UpdateFlag UpdateFlag_MIN = Define_Message_UpdateFlag_UpdateFlag_MIN;
  static constexpr UpdateFlag UpdateFlag_MAX = Define_Message_UpdateFlag_UpdateFlag_MAX;
  static constexpr int UpdateFlag_ARRAYSIZE = Define_Message_UpdateFlag_UpdateFlag_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* UpdateFlag_descriptor() {
    return Define_Message_UpdateFlag_descriptor();
  }
  template <typename T>
  static inline const std::string& UpdateFlag_Name(T value) {
    return Define_Message_UpdateFlag_Name(value);
  }
  static inline bool UpdateFlag_Parse(absl::string_view name, UpdateFlag* value) {
    return Define_Message_UpdateFlag_Parse(name, value);
  }
  using SelectFlag = Define_Message_SelectFlag;
  static constexpr SelectFlag NONE_SELECT_FLAG = Define_Message_SelectFlag_NONE_SELECT_FLAG;
  static constexpr SelectFlag OK = Define_Message_SelectFlag_OK;
  static constexpr SelectFlag CANCEL = Define_Message_SelectFlag_CANCEL;
  static inline bool SelectFlag_IsValid(int value) {
    return Define_Message_SelectFlag_IsValid(value);
  }
  static constexpr SelectFlag SelectFlag_MIN = Define_Message_SelectFlag_SelectFlag_MIN;
  static constexpr SelectFlag SelectFlag_MAX = Define_Message_SelectFlag_SelectFlag_MAX;
  static constexpr int SelectFlag_ARRAYSIZE = Define_Message_SelectFlag_SelectFlag_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* SelectFlag_descriptor() {
    return Define_Message_SelectFlag_descriptor();
  }
  template <typename T>
  static inline const std::string& SelectFlag_Name(T value) {
    return Define_Message_SelectFlag_Name(value);
  }
  static inline bool SelectFlag_Parse(absl::string_view name, SelectFlag* value) {
    return Define_Message_SelectFlag_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:DC.Packet.Defines.Define_Message)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Define_Message_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Define_Message& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct__5fDefins_2eproto;
};
// -------------------------------------------------------------------

class Define_Match final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:DC.Packet.Defines.Define_Match) */ {
 public:
  inline Define_Match() : Define_Match(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Define_Match(
      ::google::protobuf::internal::ConstantInitialized);

  inline Define_Match(const Define_Match& from) : Define_Match(nullptr, from) {}
  inline Define_Match(Define_Match&& from) noexcept
      : Define_Match(nullptr, std::move(from)) {}
  inline Define_Match& operator=(const Define_Match& from) {
    CopyFrom(from);
    return *this;
  }
  inline Define_Match& operator=(Define_Match&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Define_Match& default_instance() {
    return *internal_default_instance();
  }
  static inline const Define_Match* internal_default_instance() {
    return reinterpret_cast<const Define_Match*>(
        &_Define_Match_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(Define_Match& a, Define_Match& b) { a.Swap(&b); }
  inline void Swap(Define_Match* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Define_Match* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Define_Match* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<Define_Match>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Define_Match& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Define_Match& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DC.Packet.Defines.Define_Match"; }

 protected:
  explicit Define_Match(::google::protobuf::Arena* arena);
  Define_Match(::google::protobuf::Arena* arena, const Define_Match& from);
  Define_Match(::google::protobuf::Arena* arena, Define_Match&& from) noexcept
      : Define_Match(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Match_Region = Define_Match_Match_Region;
  static constexpr Match_Region NONE = Define_Match_Match_Region_NONE;
  static constexpr Match_Region US_WEST = Define_Match_Match_Region_US_WEST;
  static constexpr Match_Region US_EAST = Define_Match_Match_Region_US_EAST;
  static constexpr Match_Region EU_CENTRAL = Define_Match_Match_Region_EU_CENTRAL;
  static constexpr Match_Region KR = Define_Match_Match_Region_KR;
  static constexpr Match_Region SINGAPORE = Define_Match_Match_Region_SINGAPORE;
  static constexpr Match_Region SYDNEY = Define_Match_Match_Region_SYDNEY;
  static constexpr Match_Region SAOPAULO = Define_Match_Match_Region_SAOPAULO;
  static constexpr Match_Region TOKYO = Define_Match_Match_Region_TOKYO;
  static inline bool Match_Region_IsValid(int value) {
    return Define_Match_Match_Region_IsValid(value);
  }
  static constexpr Match_Region Match_Region_MIN = Define_Match_Match_Region_Match_Region_MIN;
  static constexpr Match_Region Match_Region_MAX = Define_Match_Match_Region_Match_Region_MAX;
  static constexpr int Match_Region_ARRAYSIZE = Define_Match_Match_Region_Match_Region_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Match_Region_descriptor() {
    return Define_Match_Match_Region_descriptor();
  }
  template <typename T>
  static inline const std::string& Match_Region_Name(T value) {
    return Define_Match_Match_Region_Name(value);
  }
  static inline bool Match_Region_Parse(absl::string_view name, Match_Region* value) {
    return Define_Match_Match_Region_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:DC.Packet.Defines.Define_Match)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Define_Match_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Define_Match& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct__5fDefins_2eproto;
};
// -------------------------------------------------------------------

class Define_Log final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:DC.Packet.Defines.Define_Log) */ {
 public:
  inline Define_Log() : Define_Log(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Define_Log(
      ::google::protobuf::internal::ConstantInitialized);

  inline Define_Log(const Define_Log& from) : Define_Log(nullptr, from) {}
  inline Define_Log(Define_Log&& from) noexcept
      : Define_Log(nullptr, std::move(from)) {}
  inline Define_Log& operator=(const Define_Log& from) {
    CopyFrom(from);
    return *this;
  }
  inline Define_Log& operator=(Define_Log&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Define_Log& default_instance() {
    return *internal_default_instance();
  }
  static inline const Define_Log* internal_default_instance() {
    return reinterpret_cast<const Define_Log*>(
        &_Define_Log_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(Define_Log& a, Define_Log& b) { a.Swap(&b); }
  inline void Swap(Define_Log* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Define_Log* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Define_Log* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<Define_Log>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Define_Log& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Define_Log& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DC.Packet.Defines.Define_Log"; }

 protected:
  explicit Define_Log(::google::protobuf::Arena* arena);
  Define_Log(::google::protobuf::Arena* arena, const Define_Log& from);
  Define_Log(::google::protobuf::Arena* arena, Define_Log&& from) noexcept
      : Define_Log(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Level = Define_Log_Level;
  static constexpr Level NONE_LEVEL = Define_Log_Level_NONE_LEVEL;
  static constexpr Level FATAL = Define_Log_Level_FATAL;
  static constexpr Level ERROR = Define_Log_Level_ERROR;
  static constexpr Level WARNING = Define_Log_Level_WARNING;
  static constexpr Level DISPLAY = Define_Log_Level_DISPLAY;
  static constexpr Level LOG = Define_Log_Level_LOG;
  static constexpr Level VERBOSE = Define_Log_Level_VERBOSE;
  static constexpr Level VERY_VERBOSE = Define_Log_Level_VERY_VERBOSE;
  static inline bool Level_IsValid(int value) {
    return Define_Log_Level_IsValid(value);
  }
  static constexpr Level Level_MIN = Define_Log_Level_Level_MIN;
  static constexpr Level Level_MAX = Define_Log_Level_Level_MAX;
  static constexpr int Level_ARRAYSIZE = Define_Log_Level_Level_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Level_descriptor() {
    return Define_Log_Level_descriptor();
  }
  template <typename T>
  static inline const std::string& Level_Name(T value) {
    return Define_Log_Level_Name(value);
  }
  static inline bool Level_Parse(absl::string_view name, Level* value) {
    return Define_Log_Level_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:DC.Packet.Defines.Define_Log)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Define_Log_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Define_Log& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct__5fDefins_2eproto;
};
// -------------------------------------------------------------------

class Define_Karma final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:DC.Packet.Defines.Define_Karma) */ {
 public:
  inline Define_Karma() : Define_Karma(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Define_Karma(
      ::google::protobuf::internal::ConstantInitialized);

  inline Define_Karma(const Define_Karma& from) : Define_Karma(nullptr, from) {}
  inline Define_Karma(Define_Karma&& from) noexcept
      : Define_Karma(nullptr, std::move(from)) {}
  inline Define_Karma& operator=(const Define_Karma& from) {
    CopyFrom(from);
    return *this;
  }
  inline Define_Karma& operator=(Define_Karma&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Define_Karma& default_instance() {
    return *internal_default_instance();
  }
  static inline const Define_Karma* internal_default_instance() {
    return reinterpret_cast<const Define_Karma*>(
        &_Define_Karma_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(Define_Karma& a, Define_Karma& b) { a.Swap(&b); }
  inline void Swap(Define_Karma* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Define_Karma* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Define_Karma* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<Define_Karma>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Define_Karma& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Define_Karma& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DC.Packet.Defines.Define_Karma"; }

 protected:
  explicit Define_Karma(::google::protobuf::Arena* arena);
  Define_Karma(::google::protobuf::Arena* arena, const Define_Karma& from);
  Define_Karma(::google::protobuf::Arena* arena, Define_Karma&& from) noexcept
      : Define_Karma(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Action = Define_Karma_Action;
  static constexpr Action NONE_KARMA_ACTION = Define_Karma_Action_NONE_KARMA_ACTION;
  static constexpr Action PRAISE = Define_Karma_Action_PRAISE;
  static constexpr Action PUNISH = Define_Karma_Action_PUNISH;
  static constexpr Action FORGIVE = Define_Karma_Action_FORGIVE;
  static constexpr Action PUNISH_TEAM_KILLER = Define_Karma_Action_PUNISH_TEAM_KILLER;
  static inline bool Action_IsValid(int value) {
    return Define_Karma_Action_IsValid(value);
  }
  static constexpr Action Action_MIN = Define_Karma_Action_Action_MIN;
  static constexpr Action Action_MAX = Define_Karma_Action_Action_MAX;
  static constexpr int Action_ARRAYSIZE = Define_Karma_Action_Action_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Action_descriptor() {
    return Define_Karma_Action_descriptor();
  }
  template <typename T>
  static inline const std::string& Action_Name(T value) {
    return Define_Karma_Action_Name(value);
  }
  static inline bool Action_Parse(absl::string_view name, Action* value) {
    return Define_Karma_Action_Parse(name, value);
  }
  using Status = Define_Karma_Status;
  static constexpr Status NONE_KARMA_STATUS = Define_Karma_Status_NONE_KARMA_STATUS;
  static constexpr Status NORMAL = Define_Karma_Status_NORMAL;
  static constexpr Status TEAM_KILLER = Define_Karma_Status_TEAM_KILLER;
  static inline bool Status_IsValid(int value) {
    return Define_Karma_Status_IsValid(value);
  }
  static constexpr Status Status_MIN = Define_Karma_Status_Status_MIN;
  static constexpr Status Status_MAX = Define_Karma_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE = Define_Karma_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Status_descriptor() {
    return Define_Karma_Status_descriptor();
  }
  template <typename T>
  static inline const std::string& Status_Name(T value) {
    return Define_Karma_Status_Name(value);
  }
  static inline bool Status_Parse(absl::string_view name, Status* value) {
    return Define_Karma_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:DC.Packet.Defines.Define_Karma)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Define_Karma_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Define_Karma& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct__5fDefins_2eproto;
};
// -------------------------------------------------------------------

class Define_Item final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:DC.Packet.Defines.Define_Item) */ {
 public:
  inline Define_Item() : Define_Item(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Define_Item(
      ::google::protobuf::internal::ConstantInitialized);

  inline Define_Item(const Define_Item& from) : Define_Item(nullptr, from) {}
  inline Define_Item(Define_Item&& from) noexcept
      : Define_Item(nullptr, std::move(from)) {}
  inline Define_Item& operator=(const Define_Item& from) {
    CopyFrom(from);
    return *this;
  }
  inline Define_Item& operator=(Define_Item&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Define_Item& default_instance() {
    return *internal_default_instance();
  }
  static inline const Define_Item* internal_default_instance() {
    return reinterpret_cast<const Define_Item*>(
        &_Define_Item_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(Define_Item& a, Define_Item& b) { a.Swap(&b); }
  inline void Swap(Define_Item* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Define_Item* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Define_Item* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<Define_Item>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Define_Item& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Define_Item& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DC.Packet.Defines.Define_Item"; }

 protected:
  explicit Define_Item(::google::protobuf::Arena* arena);
  Define_Item(::google::protobuf::Arena* arena, const Define_Item& from);
  Define_Item(::google::protobuf::Arena* arena, Define_Item&& from) noexcept
      : Define_Item(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using InventoryId = Define_Item_InventoryId;
  static constexpr InventoryId NONE = Define_Item_InventoryId_NONE;
  static constexpr InventoryId CHEST = Define_Item_InventoryId_CHEST;
  static constexpr InventoryId BAG = Define_Item_InventoryId_BAG;
  static constexpr InventoryId EQUIPMENT = Define_Item_InventoryId_EQUIPMENT;
  static constexpr InventoryId STORAGE = Define_Item_InventoryId_STORAGE;
  static constexpr InventoryId PURCHASED_STORAGE_0 = Define_Item_InventoryId_PURCHASED_STORAGE_0;
  static constexpr InventoryId PURCHASED_STORAGE_1 = Define_Item_InventoryId_PURCHASED_STORAGE_1;
  static constexpr InventoryId PURCHASED_STORAGE_2 = Define_Item_InventoryId_PURCHASED_STORAGE_2;
  static constexpr InventoryId PURCHASED_STORAGE_3 = Define_Item_InventoryId_PURCHASED_STORAGE_3;
  static constexpr InventoryId PURCHASED_STORAGE_4 = Define_Item_InventoryId_PURCHASED_STORAGE_4;
  static constexpr InventoryId SHARED_STASH_0 = Define_Item_InventoryId_SHARED_STASH_0;
  static constexpr InventoryId MAX = Define_Item_InventoryId_MAX;
  static inline bool InventoryId_IsValid(int value) {
    return Define_Item_InventoryId_IsValid(value);
  }
  static constexpr InventoryId InventoryId_MIN = Define_Item_InventoryId_InventoryId_MIN;
  static constexpr InventoryId InventoryId_MAX = Define_Item_InventoryId_InventoryId_MAX;
  static constexpr int InventoryId_ARRAYSIZE = Define_Item_InventoryId_InventoryId_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* InventoryId_descriptor() {
    return Define_Item_InventoryId_descriptor();
  }
  template <typename T>
  static inline const std::string& InventoryId_Name(T value) {
    return Define_Item_InventoryId_Name(value);
  }
  static inline bool InventoryId_Parse(absl::string_view name, InventoryId* value) {
    return Define_Item_InventoryId_Parse(name, value);
  }
  using rarityType = Define_Item_rarityType;
  static constexpr rarityType NONE_RARITY_TYPE = Define_Item_rarityType_NONE_RARITY_TYPE;
  static constexpr rarityType POOR = Define_Item_rarityType_POOR;
  static constexpr rarityType COMMON = Define_Item_rarityType_COMMON;
  static constexpr rarityType UNCOMMON = Define_Item_rarityType_UNCOMMON;
  static constexpr rarityType RARE = Define_Item_rarityType_RARE;
  static constexpr rarityType EPIC = Define_Item_rarityType_EPIC;
  static constexpr rarityType LEGEND = Define_Item_rarityType_LEGEND;
  static constexpr rarityType UNIQUE = Define_Item_rarityType_UNIQUE;
  static inline bool rarityType_IsValid(int value) {
    return Define_Item_rarityType_IsValid(value);
  }
  static constexpr rarityType rarityType_MIN = Define_Item_rarityType_rarityType_MIN;
  static constexpr rarityType rarityType_MAX = Define_Item_rarityType_rarityType_MAX;
  static constexpr int rarityType_ARRAYSIZE = Define_Item_rarityType_rarityType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* rarityType_descriptor() {
    return Define_Item_rarityType_descriptor();
  }
  template <typename T>
  static inline const std::string& rarityType_Name(T value) {
    return Define_Item_rarityType_Name(value);
  }
  static inline bool rarityType_Parse(absl::string_view name, rarityType* value) {
    return Define_Item_rarityType_Parse(name, value);
  }
  using LootState = Define_Item_LootState;
  static constexpr LootState NONE_SOURCE = Define_Item_LootState_NONE_SOURCE;
  static constexpr LootState SUPPLIED = Define_Item_LootState_SUPPLIED;
  static constexpr LootState LOOTED = Define_Item_LootState_LOOTED;
  static constexpr LootState HANDLED = Define_Item_LootState_HANDLED;
  static constexpr LootState CRAFT = Define_Item_LootState_CRAFT;
  static constexpr LootState ALLY = Define_Item_LootState_ALLY;
  static inline bool LootState_IsValid(int value) {
    return Define_Item_LootState_IsValid(value);
  }
  static constexpr LootState LootState_MIN = Define_Item_LootState_LootState_MIN;
  static constexpr LootState LootState_MAX = Define_Item_LootState_LootState_MAX;
  static constexpr int LootState_ARRAYSIZE = Define_Item_LootState_LootState_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* LootState_descriptor() {
    return Define_Item_LootState_descriptor();
  }
  template <typename T>
  static inline const std::string& LootState_Name(T value) {
    return Define_Item_LootState_Name(value);
  }
  static inline bool LootState_Parse(absl::string_view name, LootState* value) {
    return Define_Item_LootState_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:DC.Packet.Defines.Define_Item)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Define_Item_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Define_Item& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct__5fDefins_2eproto;
};
// -------------------------------------------------------------------

class Define_Hack final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:DC.Packet.Defines.Define_Hack) */ {
 public:
  inline Define_Hack() : Define_Hack(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Define_Hack(
      ::google::protobuf::internal::ConstantInitialized);

  inline Define_Hack(const Define_Hack& from) : Define_Hack(nullptr, from) {}
  inline Define_Hack(Define_Hack&& from) noexcept
      : Define_Hack(nullptr, std::move(from)) {}
  inline Define_Hack& operator=(const Define_Hack& from) {
    CopyFrom(from);
    return *this;
  }
  inline Define_Hack& operator=(Define_Hack&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Define_Hack& default_instance() {
    return *internal_default_instance();
  }
  static inline const Define_Hack* internal_default_instance() {
    return reinterpret_cast<const Define_Hack*>(
        &_Define_Hack_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(Define_Hack& a, Define_Hack& b) { a.Swap(&b); }
  inline void Swap(Define_Hack* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Define_Hack* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Define_Hack* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<Define_Hack>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Define_Hack& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Define_Hack& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DC.Packet.Defines.Define_Hack"; }

 protected:
  explicit Define_Hack(::google::protobuf::Arena* arena);
  Define_Hack(::google::protobuf::Arena* arena, const Define_Hack& from);
  Define_Hack(::google::protobuf::Arena* arena, Define_Hack&& from) noexcept
      : Define_Hack(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Policy = Define_Hack_Policy;
  static constexpr Policy NONE_GAME_HACK_POLICY = Define_Hack_Policy_NONE_GAME_HACK_POLICY;
  static constexpr Policy GAME_HACK_POLICY_KICK = Define_Hack_Policy_GAME_HACK_POLICY_KICK;
  static constexpr Policy GAME_HACK_POLICY_BLOCK = Define_Hack_Policy_GAME_HACK_POLICY_BLOCK;
  static constexpr Policy GAME_HACK_POLICY_KICK_AND_BLOCK = Define_Hack_Policy_GAME_HACK_POLICY_KICK_AND_BLOCK;
  static inline bool Policy_IsValid(int value) {
    return Define_Hack_Policy_IsValid(value);
  }
  static constexpr Policy Policy_MIN = Define_Hack_Policy_Policy_MIN;
  static constexpr Policy Policy_MAX = Define_Hack_Policy_Policy_MAX;
  static constexpr int Policy_ARRAYSIZE = Define_Hack_Policy_Policy_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Policy_descriptor() {
    return Define_Hack_Policy_descriptor();
  }
  template <typename T>
  static inline const std::string& Policy_Name(T value) {
    return Define_Hack_Policy_Name(value);
  }
  static inline bool Policy_Parse(absl::string_view name, Policy* value) {
    return Define_Hack_Policy_Parse(name, value);
  }
  using banType = Define_Hack_banType;
  static constexpr banType NONE_BAN_TYPE = Define_Hack_banType_NONE_BAN_TYPE;
  static constexpr banType Cheater = Define_Hack_banType_Cheater;
  static constexpr banType InappropriateName = Define_Hack_banType_InappropriateName;
  static constexpr banType Etc = Define_Hack_banType_Etc;
  static constexpr banType RmtUser = Define_Hack_banType_RmtUser;
  static constexpr banType RmtSpam = Define_Hack_banType_RmtSpam;
  static constexpr banType AbnormalDetection = Define_Hack_banType_AbnormalDetection;
  static constexpr banType CheaterGroup = Define_Hack_banType_CheaterGroup;
  static constexpr banType ExploitAbuser = Define_Hack_banType_ExploitAbuser;
  static constexpr banType AbnormalScreen = Define_Hack_banType_AbnormalScreen;
  static constexpr banType Teaming = Define_Hack_banType_Teaming;
  static constexpr banType StreamSniping = Define_Hack_banType_StreamSniping;
  static constexpr banType InappropriateChat = Define_Hack_banType_InappropriateChat;
  static constexpr banType InappropriateVoip = Define_Hack_banType_InappropriateVoip;
  static constexpr banType RacistName = Define_Hack_banType_RacistName;
  static constexpr banType RacistChat = Define_Hack_banType_RacistChat;
  static constexpr banType RacistVoip = Define_Hack_banType_RacistVoip;
  static constexpr banType Refund_Abuse = Define_Hack_banType_Refund_Abuse;
  static constexpr banType AbnormalChat = Define_Hack_banType_AbnormalChat;
  static constexpr banType Investigation = Define_Hack_banType_Investigation;
  static inline bool banType_IsValid(int value) {
    return Define_Hack_banType_IsValid(value);
  }
  static constexpr banType banType_MIN = Define_Hack_banType_banType_MIN;
  static constexpr banType banType_MAX = Define_Hack_banType_banType_MAX;
  static constexpr int banType_ARRAYSIZE = Define_Hack_banType_banType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* banType_descriptor() {
    return Define_Hack_banType_descriptor();
  }
  template <typename T>
  static inline const std::string& banType_Name(T value) {
    return Define_Hack_banType_Name(value);
  }
  static inline bool banType_Parse(absl::string_view name, banType* value) {
    return Define_Hack_banType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:DC.Packet.Defines.Define_Hack)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Define_Hack_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Define_Hack& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct__5fDefins_2eproto;
};
// -------------------------------------------------------------------

class Define_Game final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:DC.Packet.Defines.Define_Game) */ {
 public:
  inline Define_Game() : Define_Game(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Define_Game(
      ::google::protobuf::internal::ConstantInitialized);

  inline Define_Game(const Define_Game& from) : Define_Game(nullptr, from) {}
  inline Define_Game(Define_Game&& from) noexcept
      : Define_Game(nullptr, std::move(from)) {}
  inline Define_Game& operator=(const Define_Game& from) {
    CopyFrom(from);
    return *this;
  }
  inline Define_Game& operator=(Define_Game&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Define_Game& default_instance() {
    return *internal_default_instance();
  }
  static inline const Define_Game* internal_default_instance() {
    return reinterpret_cast<const Define_Game*>(
        &_Define_Game_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(Define_Game& a, Define_Game& b) { a.Swap(&b); }
  inline void Swap(Define_Game* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Define_Game* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Define_Game* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<Define_Game>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Define_Game& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Define_Game& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DC.Packet.Defines.Define_Game"; }

 protected:
  explicit Define_Game(::google::protobuf::Arena* arena);
  Define_Game(::google::protobuf::Arena* arena, const Define_Game& from);
  Define_Game(::google::protobuf::Arena* arena, Define_Game&& from) noexcept
      : Define_Game(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using AdvPointType = Define_Game_AdvPointType;
  static constexpr AdvPointType NONE = Define_Game_AdvPointType_NONE;
  static constexpr AdvPointType PlayerKill = Define_Game_AdvPointType_PlayerKill;
  static constexpr AdvPointType DungeonDown = Define_Game_AdvPointType_DungeonDown;
  static constexpr AdvPointType MonsterKill = Define_Game_AdvPointType_MonsterKill;
  static constexpr AdvPointType PropsInteraction = Define_Game_AdvPointType_PropsInteraction;
  static constexpr AdvPointType ItemAchieve = Define_Game_AdvPointType_ItemAchieve;
  static constexpr AdvPointType PlayerDead = Define_Game_AdvPointType_PlayerDead;
  static constexpr AdvPointType PlayerLocation = Define_Game_AdvPointType_PlayerLocation;
  static constexpr AdvPointType PlayerLootNewItem = Define_Game_AdvPointType_PlayerLootNewItem;
  static constexpr AdvPointType SubBossKill = Define_Game_AdvPointType_SubBossKill;
  static constexpr AdvPointType BossKill = Define_Game_AdvPointType_BossKill;
  static constexpr AdvPointType HighEndPropsInteraction = Define_Game_AdvPointType_HighEndPropsInteraction;
  static constexpr AdvPointType Treasure = Define_Game_AdvPointType_Treasure;
  static constexpr AdvPointType EntranceFee = Define_Game_AdvPointType_EntranceFee;
  static constexpr AdvPointType PlayerKillAssist = Define_Game_AdvPointType_PlayerKillAssist;
  static constexpr AdvPointType MonsterKillAssist = Define_Game_AdvPointType_MonsterKillAssist;
  static constexpr AdvPointType SubBossKillAssist = Define_Game_AdvPointType_SubBossKillAssist;
  static constexpr AdvPointType BossKillAssist = Define_Game_AdvPointType_BossKillAssist;
  static inline bool AdvPointType_IsValid(int value) {
    return Define_Game_AdvPointType_IsValid(value);
  }
  static constexpr AdvPointType AdvPointType_MIN = Define_Game_AdvPointType_AdvPointType_MIN;
  static constexpr AdvPointType AdvPointType_MAX = Define_Game_AdvPointType_AdvPointType_MAX;
  static constexpr int AdvPointType_ARRAYSIZE = Define_Game_AdvPointType_AdvPointType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* AdvPointType_descriptor() {
    return Define_Game_AdvPointType_descriptor();
  }
  template <typename T>
  static inline const std::string& AdvPointType_Name(T value) {
    return Define_Game_AdvPointType_Name(value);
  }
  static inline bool AdvPointType_Parse(absl::string_view name, AdvPointType* value) {
    return Define_Game_AdvPointType_Parse(name, value);
  }
  using GameType = Define_Game_GameType;
  static constexpr GameType NONE_MODE = Define_Game_GameType_NONE_MODE;
  static constexpr GameType DUNGEON_TRIO_NORMAL = Define_Game_GameType_DUNGEON_TRIO_NORMAL;
  static constexpr GameType DUNGEON_TRIO_HIGH_ROLLER = Define_Game_GameType_DUNGEON_TRIO_HIGH_ROLLER;
  static constexpr GameType DUNGEON_SOLO_NORMAL = Define_Game_GameType_DUNGEON_SOLO_NORMAL;
  static constexpr GameType DUNGEON_DUO_NORMAL = Define_Game_GameType_DUNGEON_DUO_NORMAL;
  static constexpr GameType DUNGEON_SOLO_HIGH_ROLLER = Define_Game_GameType_DUNGEON_SOLO_HIGH_ROLLER;
  static constexpr GameType DUNGEON_DUO_HIGH_ROLLER = Define_Game_GameType_DUNGEON_DUO_HIGH_ROLLER;
  static constexpr GameType ARENA_DUO = Define_Game_GameType_ARENA_DUO;
  static constexpr GameType ARENA_TRIO = Define_Game_GameType_ARENA_TRIO;
  static inline bool GameType_IsValid(int value) {
    return Define_Game_GameType_IsValid(value);
  }
  static constexpr GameType GameType_MIN = Define_Game_GameType_GameType_MIN;
  static constexpr GameType GameType_MAX = Define_Game_GameType_GameType_MAX;
  static constexpr int GameType_ARRAYSIZE = Define_Game_GameType_GameType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* GameType_descriptor() {
    return Define_Game_GameType_descriptor();
  }
  template <typename T>
  static inline const std::string& GameType_Name(T value) {
    return Define_Game_GameType_Name(value);
  }
  static inline bool GameType_Parse(absl::string_view name, GameType* value) {
    return Define_Game_GameType_Parse(name, value);
  }
  using Floor = Define_Game_Floor;
  static constexpr Floor NONE_FLOOR = Define_Game_Floor_NONE_FLOOR;
  static constexpr Floor FLOOR_1F = Define_Game_Floor_FLOOR_1F;
  static constexpr Floor FLOOR_2F = Define_Game_Floor_FLOOR_2F;
  static constexpr Floor FLOOR_3F = Define_Game_Floor_FLOOR_3F;
  static inline bool Floor_IsValid(int value) {
    return Define_Game_Floor_IsValid(value);
  }
  static constexpr Floor Floor_MIN = Define_Game_Floor_Floor_MIN;
  static constexpr Floor Floor_MAX = Define_Game_Floor_Floor_MAX;
  static constexpr int Floor_ARRAYSIZE = Define_Game_Floor_Floor_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Floor_descriptor() {
    return Define_Game_Floor_descriptor();
  }
  template <typename T>
  static inline const std::string& Floor_Name(T value) {
    return Define_Game_Floor_Name(value);
  }
  static inline bool Floor_Parse(absl::string_view name, Floor* value) {
    return Define_Game_Floor_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:DC.Packet.Defines.Define_Game)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Define_Game_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Define_Game& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct__5fDefins_2eproto;
};
// -------------------------------------------------------------------

class Define_Equipment final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:DC.Packet.Defines.Define_Equipment) */ {
 public:
  inline Define_Equipment() : Define_Equipment(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Define_Equipment(
      ::google::protobuf::internal::ConstantInitialized);

  inline Define_Equipment(const Define_Equipment& from) : Define_Equipment(nullptr, from) {}
  inline Define_Equipment(Define_Equipment&& from) noexcept
      : Define_Equipment(nullptr, std::move(from)) {}
  inline Define_Equipment& operator=(const Define_Equipment& from) {
    CopyFrom(from);
    return *this;
  }
  inline Define_Equipment& operator=(Define_Equipment&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Define_Equipment& default_instance() {
    return *internal_default_instance();
  }
  static inline const Define_Equipment* internal_default_instance() {
    return reinterpret_cast<const Define_Equipment*>(
        &_Define_Equipment_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(Define_Equipment& a, Define_Equipment& b) { a.Swap(&b); }
  inline void Swap(Define_Equipment* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Define_Equipment* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Define_Equipment* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<Define_Equipment>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Define_Equipment& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Define_Equipment& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DC.Packet.Defines.Define_Equipment"; }

 protected:
  explicit Define_Equipment(::google::protobuf::Arena* arena);
  Define_Equipment(::google::protobuf::Arena* arena, const Define_Equipment& from);
  Define_Equipment(::google::protobuf::Arena* arena, Define_Equipment&& from) noexcept
      : Define_Equipment(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using SlotId = Define_Equipment_SlotId;
  static constexpr SlotId NONE = Define_Equipment_SlotId_NONE;
  static constexpr SlotId HEAD = Define_Equipment_SlotId_HEAD;
  static constexpr SlotId CHEST = Define_Equipment_SlotId_CHEST;
  static constexpr SlotId HANDS = Define_Equipment_SlotId_HANDS;
  static constexpr SlotId LEGS = Define_Equipment_SlotId_LEGS;
  static constexpr SlotId FOOT = Define_Equipment_SlotId_FOOT;
  static constexpr SlotId BELT_A = Define_Equipment_SlotId_BELT_A;
  static constexpr SlotId BELT_B = Define_Equipment_SlotId_BELT_B;
  static constexpr SlotId UTILITY_A_1 = Define_Equipment_SlotId_UTILITY_A_1;
  static constexpr SlotId UTILITY_B_1 = Define_Equipment_SlotId_UTILITY_B_1;
  static constexpr SlotId PRIMARY_A = Define_Equipment_SlotId_PRIMARY_A;
  static constexpr SlotId SECONDARY_A = Define_Equipment_SlotId_SECONDARY_A;
  static constexpr SlotId PRIMARY_B = Define_Equipment_SlotId_PRIMARY_B;
  static constexpr SlotId SECONDARY_B = Define_Equipment_SlotId_SECONDARY_B;
  static constexpr SlotId UTILITY_A_2 = Define_Equipment_SlotId_UTILITY_A_2;
  static constexpr SlotId UTILITY_A_3 = Define_Equipment_SlotId_UTILITY_A_3;
  static constexpr SlotId UTILITY_B_2 = Define_Equipment_SlotId_UTILITY_B_2;
  static constexpr SlotId UTILITY_B_3 = Define_Equipment_SlotId_UTILITY_B_3;
  static constexpr SlotId SOULHEART = Define_Equipment_SlotId_SOULHEART;
  static constexpr SlotId NECKLACE = Define_Equipment_SlotId_NECKLACE;
  static constexpr SlotId RING_A = Define_Equipment_SlotId_RING_A;
  static constexpr SlotId RING_B = Define_Equipment_SlotId_RING_B;
  static constexpr SlotId BACK = Define_Equipment_SlotId_BACK;
  static inline bool SlotId_IsValid(int value) {
    return Define_Equipment_SlotId_IsValid(value);
  }
  static constexpr SlotId SlotId_MIN = Define_Equipment_SlotId_SlotId_MIN;
  static constexpr SlotId SlotId_MAX = Define_Equipment_SlotId_SlotId_MAX;
  static constexpr int SlotId_ARRAYSIZE = Define_Equipment_SlotId_SlotId_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* SlotId_descriptor() {
    return Define_Equipment_SlotId_descriptor();
  }
  template <typename T>
  static inline const std::string& SlotId_Name(T value) {
    return Define_Equipment_SlotId_Name(value);
  }
  static inline bool SlotId_Parse(absl::string_view name, SlotId* value) {
    return Define_Equipment_SlotId_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:DC.Packet.Defines.Define_Equipment)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Define_Equipment_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Define_Equipment& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct__5fDefins_2eproto;
};
// -------------------------------------------------------------------

class Define_Coupon final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:DC.Packet.Defines.Define_Coupon) */ {
 public:
  inline Define_Coupon() : Define_Coupon(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Define_Coupon(
      ::google::protobuf::internal::ConstantInitialized);

  inline Define_Coupon(const Define_Coupon& from) : Define_Coupon(nullptr, from) {}
  inline Define_Coupon(Define_Coupon&& from) noexcept
      : Define_Coupon(nullptr, std::move(from)) {}
  inline Define_Coupon& operator=(const Define_Coupon& from) {
    CopyFrom(from);
    return *this;
  }
  inline Define_Coupon& operator=(Define_Coupon&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Define_Coupon& default_instance() {
    return *internal_default_instance();
  }
  static inline const Define_Coupon* internal_default_instance() {
    return reinterpret_cast<const Define_Coupon*>(
        &_Define_Coupon_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(Define_Coupon& a, Define_Coupon& b) { a.Swap(&b); }
  inline void Swap(Define_Coupon* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Define_Coupon* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Define_Coupon* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<Define_Coupon>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Define_Coupon& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Define_Coupon& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DC.Packet.Defines.Define_Coupon"; }

 protected:
  explicit Define_Coupon(::google::protobuf::Arena* arena);
  Define_Coupon(::google::protobuf::Arena* arena, const Define_Coupon& from);
  Define_Coupon(::google::protobuf::Arena* arena, Define_Coupon&& from) noexcept
      : Define_Coupon(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Type = Define_Coupon_Type;
  static constexpr Type NONE_TYPE = Define_Coupon_Type_NONE_TYPE;
  static constexpr Type MADRINAS = Define_Coupon_Type_MADRINAS;
  static inline bool Type_IsValid(int value) {
    return Define_Coupon_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = Define_Coupon_Type_Type_MIN;
  static constexpr Type Type_MAX = Define_Coupon_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = Define_Coupon_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return Define_Coupon_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return Define_Coupon_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return Define_Coupon_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:DC.Packet.Defines.Define_Coupon)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Define_Coupon_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Define_Coupon& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct__5fDefins_2eproto;
};
// -------------------------------------------------------------------

class Define_Common final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:DC.Packet.Defines.Define_Common) */ {
 public:
  inline Define_Common() : Define_Common(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Define_Common(
      ::google::protobuf::internal::ConstantInitialized);

  inline Define_Common(const Define_Common& from) : Define_Common(nullptr, from) {}
  inline Define_Common(Define_Common&& from) noexcept
      : Define_Common(nullptr, std::move(from)) {}
  inline Define_Common& operator=(const Define_Common& from) {
    CopyFrom(from);
    return *this;
  }
  inline Define_Common& operator=(Define_Common&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Define_Common& default_instance() {
    return *internal_default_instance();
  }
  static inline const Define_Common* internal_default_instance() {
    return reinterpret_cast<const Define_Common*>(
        &_Define_Common_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(Define_Common& a, Define_Common& b) { a.Swap(&b); }
  inline void Swap(Define_Common* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Define_Common* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Define_Common* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<Define_Common>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Define_Common& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Define_Common& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DC.Packet.Defines.Define_Common"; }

 protected:
  explicit Define_Common(::google::protobuf::Arena* arena);
  Define_Common(::google::protobuf::Arena* arena, const Define_Common& from);
  Define_Common(::google::protobuf::Arena* arena, Define_Common&& from) noexcept
      : Define_Common(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using MetaLocation = Define_Common_MetaLocation;
  static constexpr MetaLocation NONE = Define_Common_MetaLocation_NONE;
  static constexpr MetaLocation INGAME = Define_Common_MetaLocation_INGAME;
  static constexpr MetaLocation PLAY = Define_Common_MetaLocation_PLAY;
  static constexpr MetaLocation LEADERBOARD = Define_Common_MetaLocation_LEADERBOARD;
  static constexpr MetaLocation LOADOUT = Define_Common_MetaLocation_LOADOUT;
  static constexpr MetaLocation MERCHANT = Define_Common_MetaLocation_MERCHANT;
  static constexpr MetaLocation TRADE = Define_Common_MetaLocation_TRADE;
  static constexpr MetaLocation CLASS = Define_Common_MetaLocation_CLASS;
  static constexpr MetaLocation CHARACTER_SELECT = Define_Common_MetaLocation_CHARACTER_SELECT;
  static constexpr MetaLocation OFFLINE = Define_Common_MetaLocation_OFFLINE;
  static constexpr MetaLocation CUSTOMIZE = Define_Common_MetaLocation_CUSTOMIZE;
  static constexpr MetaLocation SHOP = Define_Common_MetaLocation_SHOP;
  static constexpr MetaLocation RECRUIT = Define_Common_MetaLocation_RECRUIT;
  static inline bool MetaLocation_IsValid(int value) {
    return Define_Common_MetaLocation_IsValid(value);
  }
  static constexpr MetaLocation MetaLocation_MIN = Define_Common_MetaLocation_MetaLocation_MIN;
  static constexpr MetaLocation MetaLocation_MAX = Define_Common_MetaLocation_MetaLocation_MAX;
  static constexpr int MetaLocation_ARRAYSIZE = Define_Common_MetaLocation_MetaLocation_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* MetaLocation_descriptor() {
    return Define_Common_MetaLocation_descriptor();
  }
  template <typename T>
  static inline const std::string& MetaLocation_Name(T value) {
    return Define_Common_MetaLocation_Name(value);
  }
  static inline bool MetaLocation_Parse(absl::string_view name, MetaLocation* value) {
    return Define_Common_MetaLocation_Parse(name, value);
  }
  using ServerLocation = Define_Common_ServerLocation;
  static constexpr ServerLocation NONE_LOCATION = Define_Common_ServerLocation_NONE_LOCATION;
  static constexpr ServerLocation LOCAL = Define_Common_ServerLocation_LOCAL;
  static constexpr ServerLocation QA = Define_Common_ServerLocation_QA;
  static constexpr ServerLocation PLAY_TEST = Define_Common_ServerLocation_PLAY_TEST;
  static constexpr ServerLocation NA = Define_Common_ServerLocation_NA;
  static inline bool ServerLocation_IsValid(int value) {
    return Define_Common_ServerLocation_IsValid(value);
  }
  static constexpr ServerLocation ServerLocation_MIN = Define_Common_ServerLocation_ServerLocation_MIN;
  static constexpr ServerLocation ServerLocation_MAX = Define_Common_ServerLocation_ServerLocation_MAX;
  static constexpr int ServerLocation_ARRAYSIZE = Define_Common_ServerLocation_ServerLocation_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ServerLocation_descriptor() {
    return Define_Common_ServerLocation_descriptor();
  }
  template <typename T>
  static inline const std::string& ServerLocation_Name(T value) {
    return Define_Common_ServerLocation_Name(value);
  }
  static inline bool ServerLocation_Parse(absl::string_view name, ServerLocation* value) {
    return Define_Common_ServerLocation_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:DC.Packet.Defines.Define_Common)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Define_Common_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Define_Common& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct__5fDefins_2eproto;
};
// -------------------------------------------------------------------

class Define_Class final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:DC.Packet.Defines.Define_Class) */ {
 public:
  inline Define_Class() : Define_Class(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Define_Class(
      ::google::protobuf::internal::ConstantInitialized);

  inline Define_Class(const Define_Class& from) : Define_Class(nullptr, from) {}
  inline Define_Class(Define_Class&& from) noexcept
      : Define_Class(nullptr, std::move(from)) {}
  inline Define_Class& operator=(const Define_Class& from) {
    CopyFrom(from);
    return *this;
  }
  inline Define_Class& operator=(Define_Class&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Define_Class& default_instance() {
    return *internal_default_instance();
  }
  static inline const Define_Class* internal_default_instance() {
    return reinterpret_cast<const Define_Class*>(
        &_Define_Class_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(Define_Class& a, Define_Class& b) { a.Swap(&b); }
  inline void Swap(Define_Class* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Define_Class* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Define_Class* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<Define_Class>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Define_Class& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Define_Class& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DC.Packet.Defines.Define_Class"; }

 protected:
  explicit Define_Class(::google::protobuf::Arena* arena);
  Define_Class(::google::protobuf::Arena* arena, const Define_Class& from);
  Define_Class(::google::protobuf::Arena* arena, Define_Class&& from) noexcept
      : Define_Class(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Type = Define_Class_Type;
  static constexpr Type NONE_TYPE = Define_Class_Type_NONE_TYPE;
  static constexpr Type PERK = Define_Class_Type_PERK;
  static constexpr Type SKILL = Define_Class_Type_SKILL;
  static constexpr Type SPELL = Define_Class_Type_SPELL;
  static constexpr Type MUSIC = Define_Class_Type_MUSIC;
  static constexpr Type SHAPE_SHIFT = Define_Class_Type_SHAPE_SHIFT;
  static inline bool Type_IsValid(int value) {
    return Define_Class_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = Define_Class_Type_Type_MIN;
  static constexpr Type Type_MAX = Define_Class_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = Define_Class_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return Define_Class_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return Define_Class_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return Define_Class_Type_Parse(name, value);
  }
  using Move = Define_Class_Move;
  static constexpr Move NONE_MOVE = Define_Class_Move_NONE_MOVE;
  static constexpr Move EQUIP = Define_Class_Move_EQUIP;
  static constexpr Move UN_EQUIP = Define_Class_Move_UN_EQUIP;
  static inline bool Move_IsValid(int value) {
    return Define_Class_Move_IsValid(value);
  }
  static constexpr Move Move_MIN = Define_Class_Move_Move_MIN;
  static constexpr Move Move_MAX = Define_Class_Move_Move_MAX;
  static constexpr int Move_ARRAYSIZE = Define_Class_Move_Move_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Move_descriptor() {
    return Define_Class_Move_descriptor();
  }
  template <typename T>
  static inline const std::string& Move_Name(T value) {
    return Define_Class_Move_Name(value);
  }
  static inline bool Move_Parse(absl::string_view name, Move* value) {
    return Define_Class_Move_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:DC.Packet.Defines.Define_Class)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Define_Class_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Define_Class& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct__5fDefins_2eproto;
};
// -------------------------------------------------------------------

class Define_Chat final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:DC.Packet.Defines.Define_Chat) */ {
 public:
  inline Define_Chat() : Define_Chat(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Define_Chat(
      ::google::protobuf::internal::ConstantInitialized);

  inline Define_Chat(const Define_Chat& from) : Define_Chat(nullptr, from) {}
  inline Define_Chat(Define_Chat&& from) noexcept
      : Define_Chat(nullptr, std::move(from)) {}
  inline Define_Chat& operator=(const Define_Chat& from) {
    CopyFrom(from);
    return *this;
  }
  inline Define_Chat& operator=(Define_Chat&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Define_Chat& default_instance() {
    return *internal_default_instance();
  }
  static inline const Define_Chat* internal_default_instance() {
    return reinterpret_cast<const Define_Chat*>(
        &_Define_Chat_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(Define_Chat& a, Define_Chat& b) { a.Swap(&b); }
  inline void Swap(Define_Chat* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Define_Chat* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Define_Chat* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<Define_Chat>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Define_Chat& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Define_Chat& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DC.Packet.Defines.Define_Chat"; }

 protected:
  explicit Define_Chat(::google::protobuf::Arena* arena);
  Define_Chat(::google::protobuf::Arena* arena, const Define_Chat& from);
  Define_Chat(::google::protobuf::Arena* arena, Define_Chat&& from) noexcept
      : Define_Chat(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Type = Define_Chat_Type;
  static constexpr Type NONE_TYPE = Define_Chat_Type_NONE_TYPE;
  static constexpr Type NORMAL = Define_Chat_Type_NORMAL;
  static constexpr Type WHISPER = Define_Chat_Type_WHISPER;
  static inline bool Type_IsValid(int value) {
    return Define_Chat_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = Define_Chat_Type_Type_MIN;
  static constexpr Type Type_MAX = Define_Chat_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = Define_Chat_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return Define_Chat_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return Define_Chat_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return Define_Chat_Type_Parse(name, value);
  }
  using RoomType = Define_Chat_RoomType;
  static constexpr RoomType ROOM_TYPE_WEAPON = Define_Chat_RoomType_ROOM_TYPE_WEAPON;
  static constexpr RoomType ROOM_TYPE_ARMOR = Define_Chat_RoomType_ROOM_TYPE_ARMOR;
  static constexpr RoomType ROOM_TYPE_UTILITY = Define_Chat_RoomType_ROOM_TYPE_UTILITY;
  static constexpr RoomType ROOM_TYPE_ETC = Define_Chat_RoomType_ROOM_TYPE_ETC;
  static inline bool RoomType_IsValid(int value) {
    return Define_Chat_RoomType_IsValid(value);
  }
  static constexpr RoomType RoomType_MIN = Define_Chat_RoomType_RoomType_MIN;
  static constexpr RoomType RoomType_MAX = Define_Chat_RoomType_RoomType_MAX;
  static constexpr int RoomType_ARRAYSIZE = Define_Chat_RoomType_RoomType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* RoomType_descriptor() {
    return Define_Chat_RoomType_descriptor();
  }
  template <typename T>
  static inline const std::string& RoomType_Name(T value) {
    return Define_Chat_RoomType_Name(value);
  }
  static inline bool RoomType_Parse(absl::string_view name, RoomType* value) {
    return Define_Chat_RoomType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:DC.Packet.Defines.Define_Chat)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Define_Chat_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Define_Chat& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct__5fDefins_2eproto;
};
// -------------------------------------------------------------------

class Define_Character final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:DC.Packet.Defines.Define_Character) */ {
 public:
  inline Define_Character() : Define_Character(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Define_Character(
      ::google::protobuf::internal::ConstantInitialized);

  inline Define_Character(const Define_Character& from) : Define_Character(nullptr, from) {}
  inline Define_Character(Define_Character&& from) noexcept
      : Define_Character(nullptr, std::move(from)) {}
  inline Define_Character& operator=(const Define_Character& from) {
    CopyFrom(from);
    return *this;
  }
  inline Define_Character& operator=(Define_Character&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Define_Character& default_instance() {
    return *internal_default_instance();
  }
  static inline const Define_Character* internal_default_instance() {
    return reinterpret_cast<const Define_Character*>(
        &_Define_Character_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(Define_Character& a, Define_Character& b) { a.Swap(&b); }
  inline void Swap(Define_Character* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Define_Character* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Define_Character* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<Define_Character>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Define_Character& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Define_Character& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DC.Packet.Defines.Define_Character"; }

 protected:
  explicit Define_Character(::google::protobuf::Arena* arena);
  Define_Character(::google::protobuf::Arena* arena, const Define_Character& from);
  Define_Character(::google::protobuf::Arena* arena, Define_Character&& from) noexcept
      : Define_Character(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using LengthNickName = Define_Character_LengthNickName;
  static constexpr LengthNickName NONE = Define_Character_LengthNickName_NONE;
  static constexpr LengthNickName MIN = Define_Character_LengthNickName_MIN;
  static constexpr LengthNickName MAX = Define_Character_LengthNickName_MAX;
  static inline bool LengthNickName_IsValid(int value) {
    return Define_Character_LengthNickName_IsValid(value);
  }
  static constexpr LengthNickName LengthNickName_MIN = Define_Character_LengthNickName_LengthNickName_MIN;
  static constexpr LengthNickName LengthNickName_MAX = Define_Character_LengthNickName_LengthNickName_MAX;
  static constexpr int LengthNickName_ARRAYSIZE = Define_Character_LengthNickName_LengthNickName_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* LengthNickName_descriptor() {
    return Define_Character_LengthNickName_descriptor();
  }
  template <typename T>
  static inline const std::string& LengthNickName_Name(T value) {
    return Define_Character_LengthNickName_Name(value);
  }
  static inline bool LengthNickName_Parse(absl::string_view name, LengthNickName* value) {
    return Define_Character_LengthNickName_Parse(name, value);
  }
  using Limit = Define_Character_Limit;
  static constexpr Limit NONE_Limit = Define_Character_Limit_NONE_Limit;
  static constexpr Limit MAX_COUNT = Define_Character_Limit_MAX_COUNT;
  static inline bool Limit_IsValid(int value) {
    return Define_Character_Limit_IsValid(value);
  }
  static constexpr Limit Limit_MIN = Define_Character_Limit_Limit_MIN;
  static constexpr Limit Limit_MAX = Define_Character_Limit_Limit_MAX;
  static constexpr int Limit_ARRAYSIZE = Define_Character_Limit_Limit_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Limit_descriptor() {
    return Define_Character_Limit_descriptor();
  }
  template <typename T>
  static inline const std::string& Limit_Name(T value) {
    return Define_Character_Limit_Name(value);
  }
  static inline bool Limit_Parse(absl::string_view name, Limit* value) {
    return Define_Character_Limit_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:DC.Packet.Defines.Define_Character)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Define_Character_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Define_Character& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct__5fDefins_2eproto;
};
// -------------------------------------------------------------------

class Define_Account final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:DC.Packet.Defines.Define_Account) */ {
 public:
  inline Define_Account() : Define_Account(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Define_Account(
      ::google::protobuf::internal::ConstantInitialized);

  inline Define_Account(const Define_Account& from) : Define_Account(nullptr, from) {}
  inline Define_Account(Define_Account&& from) noexcept
      : Define_Account(nullptr, std::move(from)) {}
  inline Define_Account& operator=(const Define_Account& from) {
    CopyFrom(from);
    return *this;
  }
  inline Define_Account& operator=(Define_Account&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Define_Account& default_instance() {
    return *internal_default_instance();
  }
  static inline const Define_Account* internal_default_instance() {
    return reinterpret_cast<const Define_Account*>(
        &_Define_Account_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Define_Account& a, Define_Account& b) { a.Swap(&b); }
  inline void Swap(Define_Account* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Define_Account* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Define_Account* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<Define_Account>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Define_Account& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Define_Account& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DC.Packet.Defines.Define_Account"; }

 protected:
  explicit Define_Account(::google::protobuf::Arena* arena);
  Define_Account(::google::protobuf::Arena* arena, const Define_Account& from);
  Define_Account(::google::protobuf::Arena* arena, Define_Account&& from) noexcept
      : Define_Account(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using LengthText = Define_Account_LengthText;
  static constexpr LengthText NONE = Define_Account_LengthText_NONE;
  static constexpr LengthText MIN = Define_Account_LengthText_MIN;
  static constexpr LengthText MAX = Define_Account_LengthText_MAX;
  static inline bool LengthText_IsValid(int value) {
    return Define_Account_LengthText_IsValid(value);
  }
  static constexpr LengthText LengthText_MIN = Define_Account_LengthText_LengthText_MIN;
  static constexpr LengthText LengthText_MAX = Define_Account_LengthText_LengthText_MAX;
  static constexpr int LengthText_ARRAYSIZE = Define_Account_LengthText_LengthText_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* LengthText_descriptor() {
    return Define_Account_LengthText_descriptor();
  }
  template <typename T>
  static inline const std::string& LengthText_Name(T value) {
    return Define_Account_LengthText_Name(value);
  }
  static inline bool LengthText_Parse(absl::string_view name, LengthText* value) {
    return Define_Account_LengthText_Parse(name, value);
  }
  using CurrencyType = Define_Account_CurrencyType;
  static constexpr CurrencyType CURRENCY_NONE = Define_Account_CurrencyType_CURRENCY_NONE;
  static constexpr CurrencyType BLUE_STONE_SHARD = Define_Account_CurrencyType_BLUE_STONE_SHARD;
  static constexpr CurrencyType RED_STONE_SHARD = Define_Account_CurrencyType_RED_STONE_SHARD;
  static inline bool CurrencyType_IsValid(int value) {
    return Define_Account_CurrencyType_IsValid(value);
  }
  static constexpr CurrencyType CurrencyType_MIN = Define_Account_CurrencyType_CurrencyType_MIN;
  static constexpr CurrencyType CurrencyType_MAX = Define_Account_CurrencyType_CurrencyType_MAX;
  static constexpr int CurrencyType_ARRAYSIZE = Define_Account_CurrencyType_CurrencyType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* CurrencyType_descriptor() {
    return Define_Account_CurrencyType_descriptor();
  }
  template <typename T>
  static inline const std::string& CurrencyType_Name(T value) {
    return Define_Account_CurrencyType_Name(value);
  }
  static inline bool CurrencyType_Parse(absl::string_view name, CurrencyType* value) {
    return Define_Account_CurrencyType_Parse(name, value);
  }
  using LoginType = Define_Account_LoginType;
  static constexpr LoginType LOGIN_TYPE_NONE = Define_Account_LoginType_LOGIN_TYPE_NONE;
  static constexpr LoginType STEAM = Define_Account_LoginType_STEAM;
  static constexpr LoginType EPIC = Define_Account_LoginType_EPIC;
  static constexpr LoginType IRONMACE = Define_Account_LoginType_IRONMACE;
  static constexpr LoginType CHAF = Define_Account_LoginType_CHAF;
  static constexpr LoginType MICROSOFT = Define_Account_LoginType_MICROSOFT;
  static inline bool LoginType_IsValid(int value) {
    return Define_Account_LoginType_IsValid(value);
  }
  static constexpr LoginType LoginType_MIN = Define_Account_LoginType_LoginType_MIN;
  static constexpr LoginType LoginType_MAX = Define_Account_LoginType_LoginType_MAX;
  static constexpr int LoginType_ARRAYSIZE = Define_Account_LoginType_LoginType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* LoginType_descriptor() {
    return Define_Account_LoginType_descriptor();
  }
  template <typename T>
  static inline const std::string& LoginType_Name(T value) {
    return Define_Account_LoginType_Name(value);
  }
  static inline bool LoginType_Parse(absl::string_view name, LoginType* value) {
    return Define_Account_LoginType_Parse(name, value);
  }
  using AccountStatus = Define_Account_AccountStatus;
  static constexpr AccountStatus ACCOUNT_STATUS_NONE = Define_Account_AccountStatus_ACCOUNT_STATUS_NONE;
  static constexpr AccountStatus ACCOUNT_STATUS_SQUIRE = Define_Account_AccountStatus_ACCOUNT_STATUS_SQUIRE;
  static constexpr AccountStatus ACCOUNT_STATUS_LEGEND = Define_Account_AccountStatus_ACCOUNT_STATUS_LEGEND;
  static inline bool AccountStatus_IsValid(int value) {
    return Define_Account_AccountStatus_IsValid(value);
  }
  static constexpr AccountStatus AccountStatus_MIN = Define_Account_AccountStatus_AccountStatus_MIN;
  static constexpr AccountStatus AccountStatus_MAX = Define_Account_AccountStatus_AccountStatus_MAX;
  static constexpr int AccountStatus_ARRAYSIZE = Define_Account_AccountStatus_AccountStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* AccountStatus_descriptor() {
    return Define_Account_AccountStatus_descriptor();
  }
  template <typename T>
  static inline const std::string& AccountStatus_Name(T value) {
    return Define_Account_AccountStatus_Name(value);
  }
  static inline bool AccountStatus_Parse(absl::string_view name, AccountStatus* value) {
    return Define_Account_AccountStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:DC.Packet.Defines.Define_Account)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Define_Account_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Define_Account& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct__5fDefins_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Define_Account

// -------------------------------------------------------------------

// Define_Character

// -------------------------------------------------------------------

// Define_Party

// -------------------------------------------------------------------

// Define_Item

// -------------------------------------------------------------------

// Define_Equipment

// -------------------------------------------------------------------

// Define_Message

// -------------------------------------------------------------------

// Define_Match

// -------------------------------------------------------------------

// Define_Stat

// -------------------------------------------------------------------

// Define_Game

// -------------------------------------------------------------------

// Define_Common

// -------------------------------------------------------------------

// Define_Class

// -------------------------------------------------------------------

// Define_Chat

// -------------------------------------------------------------------

// Define_Trade

// -------------------------------------------------------------------

// Operate

// -------------------------------------------------------------------

// Define_Hack

// -------------------------------------------------------------------

// Define_Report

// -------------------------------------------------------------------

// Define_Log

// -------------------------------------------------------------------

// Define_Karma

// -------------------------------------------------------------------

// Define_Coupon

// -------------------------------------------------------------------

// Define_Shop

// -------------------------------------------------------------------

// Define_Reward

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace Defines
}  // namespace Packet
}  // namespace DC


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::DC::Packet::Defines::Define_Account_LengthText> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::DC::Packet::Defines::Define_Account_LengthText>() {
  return ::DC::Packet::Defines::Define_Account_LengthText_descriptor();
}
template <>
struct is_proto_enum<::DC::Packet::Defines::Define_Account_CurrencyType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::DC::Packet::Defines::Define_Account_CurrencyType>() {
  return ::DC::Packet::Defines::Define_Account_CurrencyType_descriptor();
}
template <>
struct is_proto_enum<::DC::Packet::Defines::Define_Account_LoginType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::DC::Packet::Defines::Define_Account_LoginType>() {
  return ::DC::Packet::Defines::Define_Account_LoginType_descriptor();
}
template <>
struct is_proto_enum<::DC::Packet::Defines::Define_Account_AccountStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::DC::Packet::Defines::Define_Account_AccountStatus>() {
  return ::DC::Packet::Defines::Define_Account_AccountStatus_descriptor();
}
template <>
struct is_proto_enum<::DC::Packet::Defines::Define_Character_LengthNickName> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::DC::Packet::Defines::Define_Character_LengthNickName>() {
  return ::DC::Packet::Defines::Define_Character_LengthNickName_descriptor();
}
template <>
struct is_proto_enum<::DC::Packet::Defines::Define_Character_Limit> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::DC::Packet::Defines::Define_Character_Limit>() {
  return ::DC::Packet::Defines::Define_Character_Limit_descriptor();
}
template <>
struct is_proto_enum<::DC::Packet::Defines::Define_Party_MemberCountLimit> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::DC::Packet::Defines::Define_Party_MemberCountLimit>() {
  return ::DC::Packet::Defines::Define_Party_MemberCountLimit_descriptor();
}
template <>
struct is_proto_enum<::DC::Packet::Defines::Define_Item_InventoryId> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::DC::Packet::Defines::Define_Item_InventoryId>() {
  return ::DC::Packet::Defines::Define_Item_InventoryId_descriptor();
}
template <>
struct is_proto_enum<::DC::Packet::Defines::Define_Item_rarityType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::DC::Packet::Defines::Define_Item_rarityType>() {
  return ::DC::Packet::Defines::Define_Item_rarityType_descriptor();
}
template <>
struct is_proto_enum<::DC::Packet::Defines::Define_Item_LootState> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::DC::Packet::Defines::Define_Item_LootState>() {
  return ::DC::Packet::Defines::Define_Item_LootState_descriptor();
}
template <>
struct is_proto_enum<::DC::Packet::Defines::Define_Equipment_SlotId> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::DC::Packet::Defines::Define_Equipment_SlotId>() {
  return ::DC::Packet::Defines::Define_Equipment_SlotId_descriptor();
}
template <>
struct is_proto_enum<::DC::Packet::Defines::Define_Message_LoopFlag> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::DC::Packet::Defines::Define_Message_LoopFlag>() {
  return ::DC::Packet::Defines::Define_Message_LoopFlag_descriptor();
}
template <>
struct is_proto_enum<::DC::Packet::Defines::Define_Message_UpdateFlag> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::DC::Packet::Defines::Define_Message_UpdateFlag>() {
  return ::DC::Packet::Defines::Define_Message_UpdateFlag_descriptor();
}
template <>
struct is_proto_enum<::DC::Packet::Defines::Define_Message_SelectFlag> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::DC::Packet::Defines::Define_Message_SelectFlag>() {
  return ::DC::Packet::Defines::Define_Message_SelectFlag_descriptor();
}
template <>
struct is_proto_enum<::DC::Packet::Defines::Define_Match_Match_Region> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::DC::Packet::Defines::Define_Match_Match_Region>() {
  return ::DC::Packet::Defines::Define_Match_Match_Region_descriptor();
}
template <>
struct is_proto_enum<::DC::Packet::Defines::Define_Stat_StatType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::DC::Packet::Defines::Define_Stat_StatType>() {
  return ::DC::Packet::Defines::Define_Stat_StatType_descriptor();
}
template <>
struct is_proto_enum<::DC::Packet::Defines::Define_Game_AdvPointType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::DC::Packet::Defines::Define_Game_AdvPointType>() {
  return ::DC::Packet::Defines::Define_Game_AdvPointType_descriptor();
}
template <>
struct is_proto_enum<::DC::Packet::Defines::Define_Game_GameType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::DC::Packet::Defines::Define_Game_GameType>() {
  return ::DC::Packet::Defines::Define_Game_GameType_descriptor();
}
template <>
struct is_proto_enum<::DC::Packet::Defines::Define_Game_Floor> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::DC::Packet::Defines::Define_Game_Floor>() {
  return ::DC::Packet::Defines::Define_Game_Floor_descriptor();
}
template <>
struct is_proto_enum<::DC::Packet::Defines::Define_Common_MetaLocation> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::DC::Packet::Defines::Define_Common_MetaLocation>() {
  return ::DC::Packet::Defines::Define_Common_MetaLocation_descriptor();
}
template <>
struct is_proto_enum<::DC::Packet::Defines::Define_Common_ServerLocation> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::DC::Packet::Defines::Define_Common_ServerLocation>() {
  return ::DC::Packet::Defines::Define_Common_ServerLocation_descriptor();
}
template <>
struct is_proto_enum<::DC::Packet::Defines::Define_Class_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::DC::Packet::Defines::Define_Class_Type>() {
  return ::DC::Packet::Defines::Define_Class_Type_descriptor();
}
template <>
struct is_proto_enum<::DC::Packet::Defines::Define_Class_Move> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::DC::Packet::Defines::Define_Class_Move>() {
  return ::DC::Packet::Defines::Define_Class_Move_descriptor();
}
template <>
struct is_proto_enum<::DC::Packet::Defines::Define_Chat_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::DC::Packet::Defines::Define_Chat_Type>() {
  return ::DC::Packet::Defines::Define_Chat_Type_descriptor();
}
template <>
struct is_proto_enum<::DC::Packet::Defines::Define_Chat_RoomType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::DC::Packet::Defines::Define_Chat_RoomType>() {
  return ::DC::Packet::Defines::Define_Chat_RoomType_descriptor();
}
template <>
struct is_proto_enum<::DC::Packet::Defines::Define_Trade_Requirement_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::DC::Packet::Defines::Define_Trade_Requirement_Type>() {
  return ::DC::Packet::Defines::Define_Trade_Requirement_Type_descriptor();
}
template <>
struct is_proto_enum<::DC::Packet::Defines::Operate_Policy> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::DC::Packet::Defines::Operate_Policy>() {
  return ::DC::Packet::Defines::Operate_Policy_descriptor();
}
template <>
struct is_proto_enum<::DC::Packet::Defines::Define_Hack_Policy> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::DC::Packet::Defines::Define_Hack_Policy>() {
  return ::DC::Packet::Defines::Define_Hack_Policy_descriptor();
}
template <>
struct is_proto_enum<::DC::Packet::Defines::Define_Hack_banType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::DC::Packet::Defines::Define_Hack_banType>() {
  return ::DC::Packet::Defines::Define_Hack_banType_descriptor();
}
template <>
struct is_proto_enum<::DC::Packet::Defines::Define_Report_Category> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::DC::Packet::Defines::Define_Report_Category>() {
  return ::DC::Packet::Defines::Define_Report_Category_descriptor();
}
template <>
struct is_proto_enum<::DC::Packet::Defines::Define_Log_Level> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::DC::Packet::Defines::Define_Log_Level>() {
  return ::DC::Packet::Defines::Define_Log_Level_descriptor();
}
template <>
struct is_proto_enum<::DC::Packet::Defines::Define_Karma_Action> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::DC::Packet::Defines::Define_Karma_Action>() {
  return ::DC::Packet::Defines::Define_Karma_Action_descriptor();
}
template <>
struct is_proto_enum<::DC::Packet::Defines::Define_Karma_Status> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::DC::Packet::Defines::Define_Karma_Status>() {
  return ::DC::Packet::Defines::Define_Karma_Status_descriptor();
}
template <>
struct is_proto_enum<::DC::Packet::Defines::Define_Coupon_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::DC::Packet::Defines::Define_Coupon_Type>() {
  return ::DC::Packet::Defines::Define_Coupon_Type_descriptor();
}
template <>
struct is_proto_enum<::DC::Packet::Defines::Define_Shop_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::DC::Packet::Defines::Define_Shop_Type>() {
  return ::DC::Packet::Defines::Define_Shop_Type_descriptor();
}
template <>
struct is_proto_enum<::DC::Packet::Defines::Define_Shop_PaymentMethod> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::DC::Packet::Defines::Define_Shop_PaymentMethod>() {
  return ::DC::Packet::Defines::Define_Shop_PaymentMethod_descriptor();
}
template <>
struct is_proto_enum<::DC::Packet::Defines::Define_Shop_SalesChannelType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::DC::Packet::Defines::Define_Shop_SalesChannelType>() {
  return ::DC::Packet::Defines::Define_Shop_SalesChannelType_descriptor();
}
template <>
struct is_proto_enum<::DC::Packet::Defines::Define_Shop_ChangeNickNameType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::DC::Packet::Defines::Define_Shop_ChangeNickNameType>() {
  return ::DC::Packet::Defines::Define_Shop_ChangeNickNameType_descriptor();
}
template <>
struct is_proto_enum<::DC::Packet::Defines::Define_Reward_RewardType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::DC::Packet::Defines::Define_Reward_RewardType>() {
  return ::DC::Packet::Defines::Define_Reward_RewardType_descriptor();
}
template <>
struct is_proto_enum<::DC::Packet::Defines::CharacterGenderType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::DC::Packet::Defines::CharacterGenderType>() {
  return ::DC::Packet::Defines::CharacterGenderType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED__5fDefins_2eproto_2epb_2eh
